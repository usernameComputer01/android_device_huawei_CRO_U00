From 490e1dae9723211713d7eb0a153f28837bf9d0c4 Mon Sep 17 00:00:00 2001
From: root <root@localhost.local>
Date: Sun, 8 Jan 2023 04:11:25 +0300
Subject: [PATCH] MTK-Camera

Change-Id: I3369a601becf5cc3e722ec206e32dc9f695fb8c9
---
 core/java/android/hardware/Camera.java        | 5315 ++++++++++++-----
 core/jni/Android.mk                           |    5 +
 core/jni/android_hardware_Camera.cpp          |  552 ++
 ...ndroid_hardware_camera2_CameraMetadata.cpp |   23 +
 .../android_hardware_camera2_CameraMetadata.h |    5 +
 5 files changed, 4389 insertions(+), 1511 deletions(-)

diff --git a/core/java/android/hardware/Camera.java b/core/java/android/hardware/Camera.java
index dd15d388..8fcf63bd 100644
--- a/core/java/android/hardware/Camera.java
+++ b/core/java/android/hardware/Camera.java
@@ -48,6 +48,20 @@ import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 
+//!++
+import android.os.Binder;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStreamReader;
+import java.nio.ByteOrder;
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+import android.hardware.camera2.impl.CameraMetadataNative;
+import android.hardware.camera2.CaptureResult;
+import android.hardware.camera2.CameraCharacteristics;
+//!--
+
+
 /**
  * The Camera class is used to set image capture settings, start/stop preview,
  * snap pictures, and retrieve frames for encoding for video.  This class is a
@@ -159,6 +173,87 @@ public class Camera {
     private static final int CAMERA_MSG_META_DATA        = 0x2000;
     /* ### QC ADD-ONS: END */
 
+   //!++
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY   = 0x40000000;  //  extended notify message
+    private static final int MTK_CAMERA_MSG_EXT_DATA     = 0x80000000;  //  extended data message
+    //!--
+    //!++
+    //
+    // Extended notify message (MTK_CAMERA_MSG_EXT_NOTIFY)
+    // These match the enums in mediatek/frameworks-ext/av/include/camera/MtkCamera.h
+    //
+    // Smile Detection
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_SMILE_DETECT     = 0x00000001;
+    //
+    // Auto Scene Detection
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_ASD              = 0x00000002;
+    //
+    // Burst Shutter Callback
+    //  ext2: 0:not the last one, 1:the last one
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER    = 0x00000004;
+    //
+    // End notify for Continuous shot
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END   = 0x00000006;
+    //
+    // Last preview frame showed when capture in ZSD mode
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_ZSD_PREVIEW_DONE = 0x00000007;
+    //
+    // Raw Dump mode Stopped
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_RAW_DUMP_STOPPED  = 0x00000012;
+    //
+    // Gesture Detection
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_GESTURE_DETECT  = 0x00000013;
+
+    // Stereo Feature: warning message
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_WARNING  = 0x00000014;
+
+    // Stereo Feature: distance value
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_DISTANCE = 0x00000015;
+
+    // Result & Static metadata
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_METADATA_DONE = 0x00000016;
+
+    // notify for Image before compress when taking capture
+    private static final int MTK_CAMERA_MSG_EXT_NOTIFY_IMAGE_UNCOMPRESSED= 0x00000017;
+    //
+    //--------------------------------------------------------------------------
+    //
+    // Extended data message (MTK_CAMERA_MSG_EXT_DATA)
+    // These match the enums in mediatek/frameworks-ext/av/include/camera/MtkCamera.h
+    //
+    // Auto Panorama
+    //  int[0]: 0:mAutoRamaMoveCallback, 1:mAutoRamaCallback
+    //  int[1~]:depends on
+    private static final int MTK_CAMERA_MSG_EXT_DATA_AUTORAMA           = 0x00000001;
+    //
+    // AF Window Results
+    private static final int MTK_CAMERA_MSG_EXT_DATA_AF                 = 0x00000002;
+    //
+    // Burst Shot (EV Shot)
+    //  int[0]: the total shut count.
+    //  int[1]: count-down shut number; 0: the last one shut.
+    private static final int MTK_CAMERA_MSG_EXT_DATA_BURST_SHOT         = 0x00000003;
+    private static final int MTK_CAMERA_MSG_EXT_DATA_OT                 = 0x00000005;
+
+    //
+    //
+    //FB
+    private static final int MTK_CAMERA_MSG_EXT_DATA_FACEBEAUTY         = 0x00000006;
+    //
+    //HDR
+    private static final int MTK_CAMERA_MSG_EXT_DATA_HDR                = 0x00000008;
+    //
+    //!--
+    //Stereo Camera JPS
+    private static final int MTK_CAMERA_MSG_EXT_DATA_JPS                = 0x00000011;
+
+    //Stereo Debug Data
+    //int[0]: data type.
+    private static final int MTK_CAMERA_MSG_EXT_DATA_STEREO_DBG         = 0x00000012;
+
+    // raw16
+    private static final int MTK_CAMERA_MSG_EXT_DATA_RAW16              = 0x00000013;
+
     private long mNativeContext; // accessed by native methods
     private EventHandler mEventHandler;
     private ShutterCallback mShutterCallback;
@@ -171,11 +266,53 @@ public class Camera {
     private AutoFocusMoveCallback mAutoFocusMoveCallback;
     private OnZoomChangeListener mZoomListener;
     private FaceDetectionListener mFaceListener;
+    private ObjectTrackingListener mObjectListener;
     private ErrorCallback mErrorCallback;
+    //!++
+    private SmileCallback mSmileCallback;
+    private GestureCallback mGestureCallback;
+    //auto panorama
+    private AutoRamaCallback mAutoRamaCallback;
+    private AutoRamaMoveCallback mAutoRamaMoveCallback;
+    //HDR
+    private HdrOriginalCallback mHdrOriginalCallback;
+
+    //Stereo Camera Jps
+    private StereoCameraJpsCallback mStereoCameraJpsCallback;
+    private StereoCameraWarningCallback mStereoCameraWarningCallback;
+    private DistanceInfoCallback mDistanceInfoCallback;
+    private StereoCameraMaskCallback mStereoCameraMaskCallback;
+    //FB
+    private FbOriginalCallback mFbOriginalCallback;
+    //ASD
+    private AsdCallback mAsdCallback;
+    //AF Data
+    private AFDataCallback mAFDataCallback;
+    private boolean mStereo3DModeForCamera = false;
+    // ZSD preview done
+    private ZSDPreviewDone mPreviewDoneCallback;
+    private PreviewRawDumpCallback mPreviewRawDumpCallback;
+    // Continuous shot done
+    private ContinuousShotCallback mCSDoneCallback;
+    // static & result metadata
+    private MetadataCallback mMetadataCallbacks;
+    // raw16
+    private PictureCallback mRaw16Callbacks;
+    //A callback before image compressing,
+    //Notify that AP can take picture
+    private PictureCallback mUncompressedImageCallback;
+    // enable raw16
+    private boolean mEnableRaw16 = false;
+    //!--
+
     private boolean mOneShot;
     private boolean mWithBuffer;
     private boolean mFaceDetectionRunning = false;
+
+    private Face mObjectFace = new Face();
+    private Rect mObjectRect = new Rect();
     private final Object mAutoFocusCallbackLock = new Object();
+    private final Object mObjectCallbackLock = new Object();
 
     private static final int NO_ERROR = 0;
     private static final int EACCESS = -13;
@@ -1114,6 +1251,10 @@ public class Camera {
 
         @Override
         public void handleMessage(Message msg) {
+            //!++
+            // For debug
+            Log.i(TAG, "handleMessage: " + msg.what);
+            //!--
             switch(msg.what) {
             case CAMERA_MSG_SHUTTER:
                 if (mShutterCallback != null) {
@@ -1192,6 +1333,252 @@ public class Camera {
                     mAutoFocusMoveCallback.onAutoFocusMoving(msg.arg1 == 0 ? false : true, mCamera);
                 }
                 return;
+
+            //!++
+            case MTK_CAMERA_MSG_EXT_NOTIFY:
+                switch(msg.arg1) {
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_SMILE_DETECT:
+                    if (mSmileCallback != null) {
+                        mSmileCallback.onSmile();
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_GESTURE_DETECT:
+                    if (mGestureCallback != null) {
+                        mGestureCallback.onGesture();
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_ASD:
+                    if (mAsdCallback != null) {
+                        mAsdCallback.onDetected(msg.arg2);
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_NOTIFY_METADATA_DONE:
+                    if (mEnableRaw16) {
+                        CameraMetadataNative result_meta = new CameraMetadataNative();
+                        CameraMetadataNative characteristic_meta = new CameraMetadataNative();
+                        getMetadata(result_meta, characteristic_meta);
+                        //
+                        CaptureResult result = new CaptureResult(result_meta, 0);
+                        CameraCharacteristics characteristic = new CameraCharacteristics(characteristic_meta);
+                        //
+                        mMetadataCallbacks.onMetadataReceived(result, characteristic);
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END:
+                    if (mCSDoneCallback != null) {
+                        mCSDoneCallback.onConinuousShotDone(msg.arg2);
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_NOTIFY_ZSD_PREVIEW_DONE:
+                    if (mPreviewDoneCallback != null) {
+                        mPreviewDoneCallback.onPreviewDone();
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_WARNING:
+                    if (mStereoCameraWarningCallback != null) {
+                        int message = msg.arg2;
+                        // There are three warning messages info in arg2 with int32 type
+                        //            bit0:large lv diff;
+                        //            bit1:low light;
+                        //            bit2:close shot
+                        // we need to decode the message types
+                        int[] type = new int[3];
+                        int warnType = -1;
+                        for (int i = 0; i < 3; i++) {
+                            type[i] = (int) message & 1;
+                            message = message >> 1;
+                        }
+                        // we need to notify user by order bit0-->bit2-->bit1
+                        if (type[0] == 1) {
+                            warnType = 0;
+                        } else if (type[2] == 1) {
+                            warnType = 2;
+                        } else if (type[1] == 1) {
+                            warnType = 1;
+                        } else {
+                            warnType = 3;
+                        }
+                        if (warnType != -1) {
+                            Log.i(TAG, "Stereo Camera warning message type " + warnType);
+                            mStereoCameraWarningCallback.onWarning(warnType);
+                        }
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_STEREO_DISTANCE:
+                    if (mDistanceInfoCallback != null) {
+                        String info = String.valueOf(msg.arg2);
+                        if (info != null) {
+                            Log.i(TAG, "Distance info: Info = " + info);
+                            mDistanceInfoCallback.onInfo(info);
+                        }
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_NOTIFY_IMAGE_UNCOMPRESSED:
+                    if (mUncompressedImageCallback != null) {
+                        mUncompressedImageCallback.onPictureTaken(null, mCamera);
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_NOTIFY_RAW_DUMP_STOPPED:
+                    if (mPreviewRawDumpCallback != null)
+                    {
+                        mPreviewRawDumpCallback.onNotify(MTK_CAMERA_MSG_EXT_NOTIFY_RAW_DUMP_STOPPED);
+                    }
+                default:
+                    Log.e(TAG, "Unknown MTK-extended notify message type " + msg.arg1);
+                    break;
+                }
+                return;
+
+            case MTK_CAMERA_MSG_EXT_DATA:
+                switch(msg.arg1) {
+
+                case MTK_CAMERA_MSG_EXT_DATA_AUTORAMA: {
+
+                        byte[] byteArray = (byte[]) msg.obj;
+                        byte[] byteHead = new byte[16];
+                        System.arraycopy(byteArray, 0, byteHead, 0, 16);
+                        Log.i(TAG, "MTK_CAMERA_MSG_EXT_DATA_AUTORAMA: byteArray.length = " + byteArray.length);
+
+                        IntBuffer intBuf = ByteBuffer.wrap(byteHead).order(ByteOrder.nativeOrder()).asIntBuffer();
+                        if (0 == intBuf.get(0)) {
+                            if (mAutoRamaMoveCallback != null) {
+                                int x   = intBuf.get(1);
+                                int y   = intBuf.get(2);
+                                int dir = intBuf.get(3);
+                                int xy  = ((0x0000FFFF & x) << 16) + (0x0000FFFF & y);
+                                Log.i(TAG, "call mAutoRamaMoveCallback: " + mAutoRamaCallback + " dir:" + dir + " x:" + x + " y:" + y + " xy:" + xy);
+                                mAutoRamaMoveCallback.onFrame(xy, dir);
+                            }
+                        } else {
+                            Log.i(TAG, "call mAutoRamaCallback: " + mAutoRamaCallback);
+                            if (mAutoRamaCallback != null) {
+                                if (1 == intBuf.get(0)) {
+                                    Log.i(TAG, "capturing frame");
+                                    mAutoRamaCallback.onCapture(null);
+                                } else if (2 == intBuf.get(0)) {
+                                    Log.i(TAG, "image is merged over");
+                                    byte[] jpegData = new byte[byteArray.length - 4];
+                                    System.arraycopy(byteArray, 4, jpegData, 0, byteArray.length - 4);
+                                    mAutoRamaCallback.onCapture(jpegData);
+                                }
+
+                            }
+                        }
+                        byteHead = null;
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_DATA_AF: {
+
+                        byte[] byteArray = (byte[]) msg.obj;
+
+                        Log.i(TAG, "MTK_CAMERA_MSG_EXT_DATA_AF: byteArray.length = " + byteArray.length);
+/*
+                        IntBuffer intBuf = ByteBuffer.wrap(byteArray).order(ByteOrder.nativeOrder()).asIntBuffer();
+                        Log.i(TAG, "intBuf.limit() = " + intBuf.limit());
+                        for (int i = 0; i < intBuf.limit(); i++)
+                        {
+                            Log.i(TAG, "intBuf " + i + " = " + intBuf.get(i));
+                        }
+*/
+                        if (mAFDataCallback != null) {
+                            AFDataCallback afDatacb = mAFDataCallback;
+                            afDatacb.onAFData((byte[]) msg.obj, mCamera);
+                        }
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_DATA_OT: {
+                    byte[] byteArray = (byte[]) msg.obj;
+
+                    Log.i(TAG,
+                            "MTK_CAMERA_MSG_EXT_DATA_OT: byteArray.length = "
+                                    + byteArray.length);
+
+                    IntBuffer intBuf = ByteBuffer.wrap(byteArray)
+                            .order(ByteOrder.nativeOrder()).asIntBuffer();
+                    synchronized (mObjectCallbackLock) {
+                        if (mObjectListener != null) {
+                            Log.i(TAG, "OT callback0:" + intBuf.get(0));
+                              if (intBuf.get(0) == 1) {
+                                  mObjectRect.left = intBuf.get(1);
+                                  mObjectRect.top = intBuf.get(2);
+                                  mObjectRect.right = intBuf.get(3);
+                                  mObjectRect.bottom = intBuf.get(4);
+                                  mObjectFace.rect = mObjectRect;
+                                  mObjectFace.score = intBuf.get(5);
+                                  mObjectListener.onObjectTracking(mObjectFace,
+                                          mCamera);
+                              } else {
+                                  mObjectListener.onObjectTracking(null, mCamera);
+                              }
+                          }
+                    }
+                }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_DATA_HDR:
+                    if (mHdrOriginalCallback != null) {
+                        Log.i(TAG, "HDR Original callback");
+                        byte[] byteArray = ((byte[]) msg.obj);
+                        byte[] jpegData = new byte[byteArray.length - 4];
+                        System.arraycopy(byteArray, 4, jpegData, 0, byteArray.length - 4);
+                        mHdrOriginalCallback.onCapture(jpegData);
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_DATA_FACEBEAUTY:
+                    if (mFbOriginalCallback != null) {
+                        byte[] byteArray = ((byte[]) msg.obj);
+                        byte[] jpegData = new byte[byteArray.length - 4];
+                        System.arraycopy(byteArray, 4, jpegData, 0, byteArray.length - 4);
+                        Log.i(TAG, "FB Original callback, VFB enable : "
+                                + (SystemProperties.getInt("ro.mtk_cam_vfb", 0) == 1 ? true : false));
+                        // becuase current msg =6 have change to FB callback
+                        if (SystemProperties.getInt("ro.mtk_cam_vfb", 0) == 1 && mJpegCallback != null) {
+                            Log.i(TAG,
+                                    "FB Original callback,will call mJpegCallback.onPictureTaken");
+                            mJpegCallback.onPictureTaken(jpegData, mCamera);
+                        } else {
+                            mFbOriginalCallback.onCapture(jpegData);
+                        }
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_DATA_JPS:
+                    if (mStereoCameraJpsCallback != null) {
+                        byte[] byteArray = ((byte[]) msg.obj);
+                        byte[] jpegData = new byte[byteArray.length - 4];
+                        Log.i(TAG, "MTK_CAMERA_MSG_EXT_DATA_JPS: jpegData.length = " + jpegData.length);
+                        System.arraycopy(byteArray, 4, jpegData, 0, byteArray.length - 4);
+                        mStereoCameraJpsCallback.onCapture(jpegData);
+                    }
+                    break;
+
+                case MTK_CAMERA_MSG_EXT_DATA_STEREO_DBG:
+                    if (mStereoCameraMaskCallback != null) {
+                        byte[] byteArray = ((byte[]) msg.obj);
+                        byte[] jpegData = new byte[byteArray.length - 4];
+                        Log.i(TAG, "MTK_CAMERA_MSG_EXT_DATA_STEREO_DBG: jpegData.length = " + jpegData.length);
+                        System.arraycopy(byteArray, 4, jpegData, 0, byteArray.length - 4);
+                        mStereoCameraMaskCallback.onCapture(jpegData);
+                    }
+                    break;
+                case MTK_CAMERA_MSG_EXT_DATA_RAW16:
+                    if (mEnableRaw16) {
+                        mRaw16Callbacks.onPictureTaken((byte[]) msg.obj, mCamera);
+                    }
+                    break;
+                default:
+                    Log.e(TAG, "Unknown MTK-extended data message type " + msg.arg1);
+                    break;
+                }
+                return;
+            //!--
+
             /* ### QC ADD-ONS: START */
             case CAMERA_MSG_STATS_DATA:
                 int statsdata[] = new int[257];
@@ -1493,6 +1880,44 @@ public class Camera {
         mFaceDetectionRunning = false;
     }
 
+    /**
+    * @hide
+    *
+    * set result metadata & characteristics metadata  & raw16 callback.
+    */
+    public final void setRaw16Callback(MetadataCallback meta, PictureCallback raw16)
+    {
+        Log.i(TAG, "setRaw16Callback");
+        mMetadataCallbacks = meta;
+        mRaw16Callbacks = raw16;
+    }
+
+    /**
+    * @hide
+    *
+    * enable result metadata & characteristics metadata  & raw16 callback.
+    */
+    public final void enableRaw16(boolean enable)
+    {
+        Log.i(TAG, "enableRaw16 " + enable);
+        mEnableRaw16 = enable;
+        enableRaw16Callback(mEnableRaw16);
+    }
+
+    /**
+    * @hide
+    *
+    * set result & characteristics metadata callback.
+    */
+    public native final void getMetadata(CameraMetadataNative result, CameraMetadataNative characteristic);
+
+    /**
+    * @hide
+    *
+    * set result & characteristics metadata callback.
+    */
+    public native final void enableRaw16Callback(boolean enable);
+
     /**
      * Zooms to the requested value smoothly. The driver will notify {@link
      * OnZoomChangeListener} of the zoom value and whether zoom is stopped at
@@ -1910,6 +2335,22 @@ public class Camera {
      */
     public static final int CAMERA_ERROR_SERVER_DIED = 100;
 
+    //!++
+    /**  Memory is not enough.
+     *   @see Camera.ErrorCallback
+     * @hide
+     * @internal
+     */
+    public static final int CAMERA_ERROR_NO_MEMORY = 1000;
+
+
+    /**  STOP current feature and reset. Unlock UI. Due to wrong happened accidently.
+     *   @see Camera.ErrorCallback
+     * @hide
+     * @internal
+     */
+    public static final int CAMERA_ERROR_RESET = 1001;
+    //!--
     /**
      * Callback interface for camera error notification.
      *
@@ -1942,2131 +2383,3857 @@ public class Camera {
         mErrorCallback = cb;
     }
 
-    private native final void native_setParameters(String params);
-    private native final String native_getParameters();
+    //!++
+    private native static String native_getProperty(String key, String def);
+    private native static void native_setProperty(String key, String val);
 
     /**
-     * Changes the settings for this Camera service.
+     * @hide
      *
-     * @param params the Parameters to use for this Camera service
-     * @throws RuntimeException if any parameter is invalid or not supported.
-     * @see #getParameters()
+     * Get the value for the given key.
+     * @return if the key isn't found, return def if it isn't null, or an empty string otherwise
      */
-    public void setParameters(Parameters params) {
-        // If using preview allocations, don't allow preview size changes
-        if (mUsingPreviewAllocation) {
-            Size newPreviewSize = params.getPreviewSize();
-            Size currentPreviewSize = getParameters().getPreviewSize();
-            if (newPreviewSize.width != currentPreviewSize.width ||
-                    newPreviewSize.height != currentPreviewSize.height) {
-                throw new IllegalStateException("Cannot change preview size" +
-                        " while a preview allocation is configured.");
-            }
-        }
-
-        native_setParameters(params.flatten());
+    public static String getProperty(String key, String def) {
+        return native_getProperty(key, def);
     }
 
     /**
-     * Returns the current settings for this Camera service.
-     * If modifications are made to the returned Parameters, they must be passed
-     * to {@link #setParameters(Camera.Parameters)} to take effect.
-     *
-     * @see #setParameters(Camera.Parameters)
-     */
-    public Parameters getParameters() {
-        Parameters p = new Parameters();
-        String s = native_getParameters();
-        p.unflatten(s);
-        return p;
-    }
-
-    /** @hide
-     * Returns the current cct value of white balance.
-     *
-     * If it's in AWB mode, cct is determined by stats/awb module.
-     *
-     * If it's in Manual WB mode, it actually returns cct value
-     *     set by user via {@link #setParameters(Camera.Parameters)}.
+     * @hide
+     * @internal
+     * @param key: the given key to set, val: the value set to the key
+     * Set the value for the given key.
      */
-    public int getWBCurrentCCT() {
-        Parameters p = new Parameters();
-        String s = native_getParameters();
-        p.unflatten(s);
-
-        int cct = 0;
-        if (p.getWBCurrentCCT() != null) {
-            cct = Integer.parseInt(p.getWBCurrentCCT());
-        }
-
-        return cct;
+    public static void setProperty(String key, String val) {
+        native_setProperty(key, val);
     }
 
+    //
     /**
-     * Returns an empty {@link Parameters} for testing purpose.
-     *
-     * @return a Parameter object.
-     *
      * @hide
+     * An interface which contains a callback for the detection of a smile
      */
-    public static Parameters getEmptyParameters() {
-        Camera camera = new Camera();
-        return camera.new Parameters();
+    public interface SmileCallback
+    {
+        /**
+         * @internal
+         * Callback for smile detected
+         */
+        void onSmile();
     }
 
-    /* ### QC ADD-ONS: START */
-    private static int byteToInt(byte[] b, int offset) {
-        int value = 0;
-        for (int i = 0; i < 4; i++) {
-            int shift = (4 - 1 - i) * 8;
-            value += (b[(3-i) + offset] & 0x000000FF) << shift;
-        }
-        return value;
-    }
-    /** @hide
-     * Handles the callback for when Camera Data is available.
-     * data is read from the camera.
+    /**
+     * @hide
+     * An interface which contains a callback for the detection of a gesture
      */
-    public interface CameraDataCallback {
+    public interface GestureCallback
+    {
         /**
-         * Callback for when camera data is available.
+         * @internal
+         * Callback for gesture detected
          *
-         * @param data   a int array of the camera data
-         * @param camera the Camera service object
          */
-        void onCameraData(int[] data, Camera camera);
-    };
+        void onGesture();
+    }
 
-    /** @hide
-     * Set camera histogram mode and registers a callback function to run.
-     *  Only valid after startPreview() has been called.
+    /**
+     * @hide
+     * @internal
      *
+     * Registers a callback to be invoked when a smile face is detected
      * @param cb the callback to run
      */
-    public final void setHistogramMode(CameraDataCallback cb)
+    public final void setSmileCallback(SmileCallback cb)
     {
-        mCameraDataCallback = cb;
-        native_setHistogramMode(cb!=null);
+        mSmileCallback = cb;
     }
-    private native final void native_setHistogramMode(boolean mode);
 
-    /** @hide
-     * Set camera histogram command to send data.
-     *
+    /**
+     * @hide
+     * @internal
+     * Registers a callback to be invoked when a gesture is detected
+     * @param cb the callback to run
      */
-    public final void sendHistogramData()
+    public final void setGestureCallback(GestureCallback cb)
     {
-        native_sendHistogramData();
+        mGestureCallback = cb;
     }
-    private native final void native_sendHistogramData();
 
-    /** @hide
-     * Handles the callback for when Camera Meta Data is available.
-     * Meta data is read from the camera.
+    //
+
+    /**
+     * @hide
+     *
+     * Do panorama with number of images
      */
-    public interface CameraMetaDataCallback {
-        /**
-         * Callback for when camera meta data is available.
-         *
-         * @param data   a byte array of the camera meta data
-         * @param camera the Camera service object
-         */
-        void onCameraMetaData(byte[] data, Camera camera);
-    };
+    public native final void doPanorama(int num);
 
-    /** @hide
-     * Set camera meta data and registers a callback function to run.
-     *  Only valid after startPreview() has been called.
+    /**
+     * @hide
      *
-     * @param cb the callback to run
+     * Cancel panorama
      */
-    public final void setMetadataCb(CameraMetaDataCallback cb)
-    {
-        mCameraMetaDataCallback = cb;
-        native_setMetadataCb(cb!=null);
-    }
-    private native final void native_setMetadataCb(boolean mode);
+    public native void cancelPanorama();
 
-    /** @hide
-     * Set camera face detection command to send meta data.
+    /**
+     * @hide
+     * @internal
+     *
+     * Start the SD (smile detection) preview mode.
+     *
+     * During the SD preview mode, the applications can call stopSmileDetection to
+     * leave the SD preview mode and then to return to the normal preview mode.
+     *
+     * During the SD preview mode, it will return to the normal preview mode
+     * automatically if the applications call takePicture. In this case, a call
+     * to stopSmileDetection is not needed.
+     *
+     * During the SD preview mode, if any smile is detected, a callback to the
+     * applications will be invoked. And then the applications should call
+     * takePicture, which is illustrated as above.
+     *
+     * @throws RuntimeException if the method fails.
      */
-    public final void sendMetaData()
-    {
-        native_sendMetaData();
+    public void startSmileDetection() {
+        startSDPreview();
     }
-    private native final void native_sendMetaData();
 
-    /** @hide
-     * Configure longshot mode. Available only in ZSL.
+    private native void startSDPreview();
+
+    /**
+     * @hide
+     * @internal
      *
-     * @param enable enable/disable this mode
+     * Cancel the SD (smile detection) preview mode.
+     *
+     * During the SD preview mode, the applications can call stopSmileDetection to
+     * leave the SD preview mode and then to return to the normal preview mode.
+     * Otherwise, do not call this method.
+     *
+     * @throws RuntimeException if the method fails.
      */
-    public final void setLongshot(boolean enable)
-    {
-        native_setLongshot(enable);
+    public void stopSmileDetection() {
+        cancelSDPreview();
     }
-    private native final void native_setLongshot(boolean enable);
 
-    /** @hide
-     * Stop longshot. Available only in ZSL.
+    private native void cancelSDPreview();
+
+    /**
+     * @hide
+     * @internal
+     * Start the GD (gesture detection) preview mode.
+     *
+     * During the GD preview mode, the applications can call stopGestureDetection to
+     * leave the GD preview mode and then to return to the normal preview mode.
+     *
+     * During the GD preview mode, it will return to the normal preview mode
+     * automatically if the applications call takePicture. In this case, a call
+     * to stopGestureDetection is not needed.
+     *
+     * During the GD preview mode, if any gesture is detected, a callback to the
+     * applications will be invoked. And then the applications should call
+     * takePicture, which is illustrated as above.
+     *
+     * @throws RuntimeException if the method fails.
      */
-    public final void stopLongshot()
-    {
-        native_stopLongshot();
+    public void startGestureDetection() {
+        startGDPreview();
     }
-    private native final void native_stopLongshot();
 
-     /** @hide
-     * Handles the Touch Co-ordinate.
-     */
-     public class Coordinate {
-        /**
-         * Sets the x,y co-ordinates for a touch event
-         *
-         * @param x the x co-ordinate (pixels)
-         * @param y the y co-ordinate (pixels)
-         */
-        public Coordinate(int x, int y) {
-            xCoordinate = x;
-            yCoordinate = y;
-        }
-        /**
-         * Compares {@code obj} to this co-ordinate.
-         *
-         * @param obj the object to compare this co-ordinate with.
-         * @return {@code true} if the xCoordinate and yCoordinate of {@code obj} is the
-         *         same as those of this coordinate. {@code false} otherwise.
-         */
-        @Override
-        public boolean equals(Object obj) {
-            if (!(obj instanceof Coordinate)) {
-                return false;
-            }
-            Coordinate c = (Coordinate) obj;
-            return xCoordinate == c.xCoordinate && yCoordinate == c.yCoordinate;
-        }
-
-        /** x co-ordinate for the touch event*/
-        public int xCoordinate;
-
-        /** y co-ordinate for the touch event */
-        public int yCoordinate;
-    };
+    private native void startGDPreview();
 
-    /** @hide
-     * Returns the current focus position.
+    /**
+     * @hide
+     * @internal
+     * Cancel the GD (gesture detection) preview mode.
      *
-     * If it's in AF mode, it's the lens position after af is done.
+     * During the GD preview mode, the applications can call stopGestureDetection to
+     * leave the GD preview mode and then to return to the normal preview mode.
+     * Otherwise, do not call this method.
      *
-     * If it's in Manual Focus mode, it actually returns the value
-     *     set by user via {@link #setParameters(Camera.Parameters)}.
+     * @throws RuntimeException if the method fails.
      */
-    public int getCurrentFocusPosition() {
-        Parameters p = new Parameters();
-        String s = native_getParameters();
-        p.unflatten(s);
+    public void stopGestureDetection() {
+        cancelGDPreview();
+    }
 
-        int focus_pos = -1;
-        if (p.getCurrentFocusPosition() != null) {
-            focus_pos = Integer.parseInt(p.getCurrentFocusPosition());
-        }
-        return focus_pos;
+    private native void cancelGDPreview();
+
+    //ASD
+  /**
+    * @hide
+    * An interface which contains a callback for the auto scene detection
+    */
+    public interface AsdCallback
+    {
+        /**
+          * @internal
+          * @param scene the scene detected
+          */
+        void onDetected(int scene);
     }
 
-    /* ### QC ADD-ONS: END */
     /**
-     * Returns a copied {@link Parameters}; for shim use only.
-     *
-     * @param parameters a non-{@code null} parameters
-     * @return a Parameter object, with all the parameters copied from {@code parameters}.
+     * @hide
+     * @internal
      *
-     * @throws NullPointerException if {@code parameters} was {@code null}
+     * Registers a callback to be invoked when auto scene is detected
+     * @param cb the callback to run
+     */
+    public final void setAsdCallback(AsdCallback cb)
+    {
+        mAsdCallback = cb;
+    }
+
+
+    /**
+     * Callback interface used to deliver focus data.
+     **
      * @hide
      */
-    public static Parameters getParametersCopy(Camera.Parameters parameters) {
-        if (parameters == null) {
-            throw new NullPointerException("parameters must not be null");
-        }
+     public interface AFDataCallback
+    {
+        void onAFData(byte[] data, Camera camera);
+    };
 
-        Camera camera = parameters.getOuter();
-        Parameters p = camera.new Parameters();
-        p.copyFrom(parameters);
+    /**
+     * @hide
+     *
+     * Registers a callback to be invoked when in focus
+     * @param cb the callback to run
+     */
+    public final void setAFDataCallback(AFDataCallback cb) {
+        mAFDataCallback = cb;
+    }
 
-        return p;
+    // auto panorama
+    /**
+      * @hide
+      * An interface which contains a callback for the auto panorama
+      */
+    public interface AutoRamaCallback
+    {
+        /**
+          * @internal
+          * @param jpegData the captured jpegdata
+          */
+        void onCapture(byte[] jpegData);
+
+    }
+
+   /**
+     * @hide
+     * An interface which contains a callback for the auto panorama movtion vector
+     */
+    public interface AutoRamaMoveCallback
+    {
+        /**
+         * @internal
+         * @param xx the pointer
+         * @param yy direction
+         */
+        void onFrame(int xx, int yy);
     }
 
     /**
-     * Image size (width and height dimensions).
-     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
-     *             applications.
+     * @hide
+     * An interface which contains a callback for result & static metadata
      */
-    @Deprecated
-    public class Size {
+    public interface MetadataCallback
+    {
         /**
-         * Sets the dimensions for pictures.
-         *
-         * @param w the photo width (pixels)
-         * @param h the photo height (pixels)
+         * on receive result & static metadata
          */
-        public Size(int w, int h) {
-            width = w;
-            height = h;
-        }
+        void onMetadataReceived(CaptureResult result, CameraCharacteristics characteristic);
+
+    }
+
+    /**
+     * @hide
+     * An interface which contains a callback for HDR origin image
+     */
+    public interface HdrOriginalCallback
+    {
         /**
-         * Compares {@code obj} to this size.
-         *
-         * @param obj the object to compare this size with.
-         * @return {@code true} if the width and height of {@code obj} is the
-         *         same as those of this size. {@code false} otherwise.
+         * @internal
+         * @param originJpegData capture data
          */
-        @Override
-        public boolean equals(Object obj) {
-            if (!(obj instanceof Size)) {
-                return false;
-            }
-            Size s = (Size) obj;
-            return width == s.width && height == s.height;
-        }
-        @Override
-        public int hashCode() {
-            return width * 32713 + height;
-        }
-        /** width of the picture */
-        public int width;
-        /** height of the picture */
-        public int height;
-    };
+        void onCapture(byte[] originJpegData);
+    }
 
     /**
-     * <p>The Area class is used for choosing specific metering and focus areas for
-     * the camera to use when calculating auto-exposure, auto-white balance, and
-     * auto-focus.</p>
-     *
-     * <p>To find out how many simultaneous areas a given camera supports, use
-     * {@link Parameters#getMaxNumMeteringAreas()} and
-     * {@link Parameters#getMaxNumFocusAreas()}. If metering or focusing area
-     * selection is unsupported, these methods will return 0.</p>
-     *
-     * <p>Each Area consists of a rectangle specifying its bounds, and a weight
-     * that determines its importance. The bounds are relative to the camera's
-     * current field of view. The coordinates are mapped so that (-1000, -1000)
-     * is always the top-left corner of the current field of view, and (1000,
-     * 1000) is always the bottom-right corner of the current field of
-     * view. Setting Areas with bounds outside that range is not allowed. Areas
-     * with zero or negative width or height are not allowed.</p>
-     *
-     * <p>The weight must range from 1 to 1000, and represents a weight for
-     * every pixel in the area. This means that a large metering area with
-     * the same weight as a smaller area will have more effect in the
-     * metering result.  Metering areas can overlap and the driver
-     * will add the weights in the overlap region.</p>
-     *
-     * @see Parameters#setFocusAreas(List)
-     * @see Parameters#getFocusAreas()
-     * @see Parameters#getMaxNumFocusAreas()
-     * @see Parameters#setMeteringAreas(List)
-     * @see Parameters#getMeteringAreas()
-     * @see Parameters#getMaxNumMeteringAreas()
-     *
-     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
-     *             applications.
+     * @hide
+     * An interface which contains a callback for stere Camera JPS image
      */
-    @Deprecated
-    public static class Area {
+    public interface StereoCameraJpsCallback
+    {
         /**
-         * Create an area with specified rectangle and weight.
-         *
-         * @param rect the bounds of the area.
-         * @param weight the weight of the area.
+         * @internal
+         * @param originJpegData capture data
          */
-        public Area(Rect rect, int weight) {
-            this.rect = rect;
-            this.weight = weight;
-        }
+        void onCapture(byte[] originJpegData);
+    }
+
+    /**
+     * @hide
+     * An interface which contains a callback for stere Camera Warning Message
+     */
+    public interface StereoCameraWarningCallback
+    {
         /**
-         * Compares {@code obj} to this area.
-         *
-         * @param obj the object to compare this area with.
-         * @return {@code true} if the rectangle and weight of {@code obj} is
-         *         the same as those of this area. {@code false} otherwise.
+         * @internal
+         * @param type warning type
          */
-        @Override
-        public boolean equals(Object obj) {
-            if (!(obj instanceof Area)) {
-                return false;
-            }
-            Area a = (Area) obj;
-            if (rect == null) {
-                if (a.rect != null) return false;
-            } else {
-                if (!rect.equals(a.rect)) return false;
-            }
-            return weight == a.weight;
-        }
+        void onWarning(int type);
+    }
 
+    /**
+     * @hide
+     * An interface which contains a callback for stere Camera Distance Info
+     */
+    public interface DistanceInfoCallback
+    {
         /**
-         * Bounds of the area. (-1000, -1000) represents the top-left of the
-         * camera field of view, and (1000, 1000) represents the bottom-right of
-         * the field of view. Setting bounds outside that range is not
-         * allowed. Bounds with zero or negative width or height are not
-         * allowed.
-         *
-         * @see Parameters#getFocusAreas()
-         * @see Parameters#getMeteringAreas()
+         * @internal
+         * @param info distance info
          */
-        public Rect rect;
+        void onInfo(String info);
+    }
 
+    /**
+     * @hide
+     * An interface which contains a callback for stere Camera Mask info
+     */
+    public interface StereoCameraMaskCallback
+    {
         /**
-         * Weight of the area. The weight must range from 1 to 1000, and
-         * represents a weight for every pixel in the area. This means that a
-         * large metering area with the same weight as a smaller area will have
-         * more effect in the metering result.  Metering areas can overlap and
-         * the driver will add the weights in the overlap region.
-         *
-         * @see Parameters#getFocusAreas()
-         * @see Parameters#getMeteringAreas()
+         * @internal
+         * @param originJpegData capture data
          */
-        public int weight;
+        void onCapture(byte[] originJpegData);
+    }
+    /**
+     * @hide
+     * An interface which contains a callback for FB origin image
+     */
+    public interface FbOriginalCallback
+    {
+        /**
+         * @internal
+         * @param originJpegData capture data
+         */
+        void onCapture(byte[] originJpegData);
     }
 
     /**
-     * Camera service settings.
-     *
-     * <p>To make camera parameters take effect, applications have to call
-     * {@link Camera#setParameters(Camera.Parameters)}. For example, after
-     * {@link Camera.Parameters#setWhiteBalance} is called, white balance is not
-     * actually changed until {@link Camera#setParameters(Camera.Parameters)}
-     * is called with the changed parameters object.
+     * @hide
+     * @internal
      *
-     * <p>Different devices may have different camera capabilities, such as
-     * picture size or flash modes. The application should query the camera
-     * capabilities before setting parameters. For example, the application
-     * should call {@link Camera.Parameters#getSupportedColorEffects()} before
-     * calling {@link Camera.Parameters#setColorEffect(String)}. If the
-     * camera does not support color effects,
-     * {@link Camera.Parameters#getSupportedColorEffects()} will return null.
+     * Registers a callback to be invoked when a image for autorama is taken
+     * @param cb the callback to run
+     */
+    public final void setAutoRamaCallback(AutoRamaCallback cb)
+    {
+        mAutoRamaCallback = cb;
+    }
+
+    /**
+     * @hide
+     * @internal
      *
-     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
-     *             applications.
+     * Registers a callback to be invoked when the motion vector is calculated
+     * @param cb the callback to run
      */
-    @Deprecated
-    public class Parameters {
-        // Parameter keys to communicate with the camera driver.
-        private static final String KEY_PREVIEW_SIZE = "preview-size";
-        private static final String KEY_PREVIEW_FORMAT = "preview-format";
-        private static final String KEY_PREVIEW_FRAME_RATE = "preview-frame-rate";
-        private static final String KEY_PREVIEW_FPS_RANGE = "preview-fps-range";
-        private static final String KEY_PICTURE_SIZE = "picture-size";
-        private static final String KEY_PICTURE_FORMAT = "picture-format";
-        private static final String KEY_JPEG_THUMBNAIL_SIZE = "jpeg-thumbnail-size";
-        private static final String KEY_JPEG_THUMBNAIL_WIDTH = "jpeg-thumbnail-width";
-        private static final String KEY_JPEG_THUMBNAIL_HEIGHT = "jpeg-thumbnail-height";
-        private static final String KEY_JPEG_THUMBNAIL_QUALITY = "jpeg-thumbnail-quality";
-        private static final String KEY_JPEG_QUALITY = "jpeg-quality";
-        private static final String KEY_ROTATION = "rotation";
-        private static final String KEY_GPS_LATITUDE = "gps-latitude";
-        private static final String KEY_GPS_LONGITUDE = "gps-longitude";
-        private static final String KEY_GPS_ALTITUDE = "gps-altitude";
-        private static final String KEY_GPS_TIMESTAMP = "gps-timestamp";
-        private static final String KEY_GPS_PROCESSING_METHOD = "gps-processing-method";
-        private static final String KEY_WHITE_BALANCE = "whitebalance";
-        private static final String KEY_EFFECT = "effect";
-        private static final String KEY_ANTIBANDING = "antibanding";
-        private static final String KEY_SCENE_MODE = "scene-mode";
-        private static final String KEY_FLASH_MODE = "flash-mode";
-        private static final String KEY_FOCUS_MODE = "focus-mode";
-        private static final String KEY_FOCUS_AREAS = "focus-areas";
-        private static final String KEY_MAX_NUM_FOCUS_AREAS = "max-num-focus-areas";
-        private static final String KEY_FOCAL_LENGTH = "focal-length";
-        private static final String KEY_HORIZONTAL_VIEW_ANGLE = "horizontal-view-angle";
-        private static final String KEY_VERTICAL_VIEW_ANGLE = "vertical-view-angle";
-        private static final String KEY_EXPOSURE_COMPENSATION = "exposure-compensation";
-        private static final String KEY_MAX_EXPOSURE_COMPENSATION = "max-exposure-compensation";
-        private static final String KEY_MIN_EXPOSURE_COMPENSATION = "min-exposure-compensation";
-        private static final String KEY_EXPOSURE_COMPENSATION_STEP = "exposure-compensation-step";
-        private static final String KEY_AUTO_EXPOSURE_LOCK = "auto-exposure-lock";
-        private static final String KEY_AUTO_EXPOSURE_LOCK_SUPPORTED = "auto-exposure-lock-supported";
-        private static final String KEY_AUTO_WHITEBALANCE_LOCK = "auto-whitebalance-lock";
-        private static final String KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED = "auto-whitebalance-lock-supported";
-        private static final String KEY_METERING_AREAS = "metering-areas";
-        private static final String KEY_MAX_NUM_METERING_AREAS = "max-num-metering-areas";
-        private static final String KEY_ZOOM = "zoom";
-        private static final String KEY_MAX_ZOOM = "max-zoom";
-        private static final String KEY_ZOOM_RATIOS = "zoom-ratios";
-        private static final String KEY_ZOOM_SUPPORTED = "zoom-supported";
-        private static final String KEY_SMOOTH_ZOOM_SUPPORTED = "smooth-zoom-supported";
-        private static final String KEY_FOCUS_DISTANCES = "focus-distances";
-        private static final String KEY_VIDEO_SIZE = "video-size";
-        private static final String KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO =
-                                            "preferred-preview-size-for-video";
-        private static final String KEY_MAX_NUM_DETECTED_FACES_HW = "max-num-detected-faces-hw";
-        private static final String KEY_MAX_NUM_DETECTED_FACES_SW = "max-num-detected-faces-sw";
-        private static final String KEY_RECORDING_HINT = "recording-hint";
-        private static final String KEY_VIDEO_SNAPSHOT_SUPPORTED = "video-snapshot-supported";
-        private static final String KEY_VIDEO_STABILIZATION = "video-stabilization";
-        private static final String KEY_VIDEO_STABILIZATION_SUPPORTED = "video-stabilization-supported";
+    public final void setAutoRamaMoveCallback(AutoRamaMoveCallback cb)
+    {
+        mAutoRamaMoveCallback = cb;
+    }
+
+    /**
+     * @hide
+     * @internal
+     * Registers a callback to be invoke when HDR origin image is taken
+     * @param cb the callback to run
+     */
+    public final void setHdrOriginalCallback(HdrOriginalCallback cb)
+    {
+        mHdrOriginalCallback = cb;
+    }
+
+    /**
+     * @hide
+     * @internal
+     * Registers a callback to be invoke when Stereo Camera JPS image is taken
+     * @param cb the callback to run
+     */
+    public final void setStereoCameraJpsCallback(StereoCameraJpsCallback cb)
+    {
+        mStereoCameraJpsCallback = cb;
+    }
+
+    /**
+     * @hide
+     *
+     * Registers a callback to be invoke when Stereo Camera warning is taken
+     * @param cb the callback to run
+     */
+    public final void setStereoCameraWarningCallback(StereoCameraWarningCallback cb)
+    {
+        mStereoCameraWarningCallback = cb;
+    }
+
+    /**
+     * @hide
+     *
+     * Registers a callback to be invoke when Distance info is taken
+     * @param cb the callback to run
+     */
+    public final void setDistanceInfoCallback(DistanceInfoCallback cb)
+    {
+        mDistanceInfoCallback = cb;
+    }
+
+    /**
+     * @hide
+     *
+     * Registers a callback to be invoke when Mask info is taken
+     * @param cb the callback to run
+     */
+    public final void setStereoCameraMaskCallback(StereoCameraMaskCallback cb)
+    {
+        mStereoCameraMaskCallback = cb;
+    }
+
+    /**
+     * @hide
+     *
+     * Registers a callback to be invoke when HDR origin image is taken
+     * @param cb the callback to run
+     */
+    public final void setFbOriginalCallback(FbOriginalCallback cb)
+    {
+        mFbOriginalCallback = cb;
+    }
+
+    /**
+     * @hide
+     * Registers a callback to be invoke when uncompressed image is taken
+     * @param cb the callback to run
+     */
+    public final void setUncompressedImageCallback(PictureCallback cb)
+    {
+        mUncompressedImageCallback = cb;
+    }
+   /**
+    * @hide
+    * @internal
+    *
+    * Start to capture number of images of panorama.
+    * @param num number of images
+    */
+    public final void startAutoRama(int num) {
+        startAUTORAMA(num);
+    }
+
+    private native final void startAUTORAMA(int num);
+
+    /**
+    * @hide
+    * @internal
+    *
+    * Stop auto panorama
+    * @param isMerge if isMerge is 1, there will be an autorama callback when merge is done
+    */
+    public void stopAutoRama(int isMerge) {
+        stopAUTORAMA(isMerge);
+    }
+
+    private native void stopAUTORAMA(int isMerge);
+
+     /**
+    * @hide
+    *
+    * Start to capture number of images of 3d panorama.
+    */
+    public native final void start3DSHOT(int num);
+
+    /**
+     * @hide
+     *
+    * Stop 3D panorama, if isMerge is 1, there will be a callback when merge is done
+    */
+    public native void stop3DSHOT(int isMerge);
+
+    /**
+     * @hide
+     * Start MainFace
+     */
+    public final void setMainFaceCoordinate(int x, int y) {
+        setMainFace(x, y);
+    }
+    private native final void setMainFace(int x, int y);
+
+    /**
+     * @hide
+     * Stop MainFace
+     */
+    public final void cancelMainFaceInfo() {
+        cancelMainFace();
+    }
+    private native final void cancelMainFace();
+
+    /**
+     * @hide
+     * @internal
+     * Start ObjectTracking
+     */
+    public final void startObjectTracking(int x, int y) {
+        startOT(x, y);
+    }
+    private native final void startOT(int x, int y);
+
+    /**
+     * @hide
+     * @internal
+     * Stop ObjectTracking
+     */
+    public final void stopObjectTracking() {
+        stopOT();
+    }
+    private native final void stopOT();
+    /**
+     * @hide
+     * Callback interface for Object Tracking in the preview frame.
+     *
+     */
+    public interface ObjectTrackingListener {
+        /**
+         * Notify the listener of the detected Object in the preview frame.
+         * @internal
+         * @param face The detected Object
+         * @param camera  The {@link Camera} service object
+         */
+        void onObjectTracking(Face face, Camera camera);
+    }
+   /**
+     * @hide
+     * Registers a listener to be notified about the faces detected in the
+     * preview frame.
+     * @internal
+     * @param listener the listener to notify
+     * @see #startObjectTracking(int x, int y)
+     */
+    public final void setObjectTrackingListener(ObjectTrackingListener listener) {
+        synchronized (mObjectCallbackLock) {
+            mObjectListener = listener;
+        }
+    }
+
+    /**
+     * @hide
+     * @internal
+     *
+     * Cancel continuous shot
+     */
+    public native void cancelContinuousShot();
+
+    /**
+     * @hide
+     * @internal
+     * @param speed : the speed set for continuous shot
+     * set speed of continuous shot(xx fps)
+     */
+    public native void setContinuousShotSpeed(int speed);
+
+    /**
+     * @hide
+     * An interface which contains a callback for the zero shutter delay preview
+     */
+    public interface ZSDPreviewDone {
+        public void onPreviewDone();
+    }
+
+    /**
+     * @hide
+     *
+     */
+    public interface PreviewRawDumpCallback {
+        public void onNotify(int code);
+    }
+
+    /**
+     * @hide
+     */
+    public void setPreviewRawDumpCallback(PreviewRawDumpCallback callback) {
+        mPreviewRawDumpCallback = callback;
+    }
+    /**
+     * @hide
+     * @internal
+     * Registers a callback to be invoked when a preview frame is done
+     * @param ZSDPreviewDone
+     */
+    public void setPreviewDoneCallback(ZSDPreviewDone callback) {
+        mPreviewDoneCallback = callback;
+    }
+
+    /**
+     * @hide
+     * An interface which contains a callback for the continuous shot
+     */
+    public interface ContinuousShotCallback {
+      /**
+        * @internal
+        * @param capture number
+        */
+        public void onConinuousShotDone(int capNum);
+    }
+    /**
+     * @hide
+     * @internal
+     * Registers a callback to be invoked when continuous shot is done
+     * @param ContinuousShotCallback
+     */
+    public void setContinuousShotCallback(ContinuousShotCallback callback) {
+        mCSDoneCallback = callback;
+    }
+    //!--
+
+    private native final void native_setParameters(String params);
+    private native final String native_getParameters();
+
+    /**
+     * Changes the settings for this Camera service.
+     *
+     * @param params the Parameters to use for this Camera service
+     * @throws RuntimeException if any parameter is invalid or not supported.
+     * @see #getParameters()
+     */
+    public void setParameters(Parameters params) {
+        // If using preview allocations, don't allow preview size changes
+        if (mUsingPreviewAllocation) {
+            Size newPreviewSize = params.getPreviewSize();
+            Size currentPreviewSize = getParameters().getPreviewSize();
+            if (newPreviewSize.width != currentPreviewSize.width ||
+                    newPreviewSize.height != currentPreviewSize.height) {
+                throw new IllegalStateException("Cannot change preview size" +
+                        " while a preview allocation is configured.");
+            }
+        }
+
+        native_setParameters(params.flatten());
+    }
+
+    /**
+     * Returns the current settings for this Camera service.
+     * If modifications are made to the returned Parameters, they must be passed
+     * to {@link #setParameters(Camera.Parameters)} to take effect.
+     *
+     * @see #setParameters(Camera.Parameters)
+     */
+    public Parameters getParameters() {
+        Parameters p = new Parameters();
+        String s = native_getParameters();
+        p.unflatten(s);
+        //!++
+        Log.i(TAG, "Camera framework getParameters =" + s);
+        p.setStereo3DMode(mStereo3DModeForCamera);
+        if (!"1".equals(SystemProperties.get("ro.mtk_bsp_package"))) {
+            // Some applications will dynamically change the preview size, and cause the
+            // frame buffer with the wrong data. For example: Google Goggle
+            // Therefore, we will only return one preview size to avoid screen fuzzy issue
+            if (isRestricted(android.os.Binder.getCallingPid())) {
+                if ("tablet".equals(android.os.SystemProperties.get("ro.build.characteristics", null)))
+                {
+                    String size = "760x480";
+                    Log.i(TAG, "change preview size to " + size + " for process: "
+                        + android.os.Binder.getCallingPid());
+                    p.set(Parameters.KEY_PREVIEW_SIZE + Parameters.SUPPORTED_VALUES_SUFFIX, size);
+                    p.set(Parameters.KEY_PREVIEW_SIZE, size);
+                }
+                else
+                {
+                    //String size = getScreenSize();
+                    //Log.i(TAG, "change preview size to " + size + " for process: "
+                    //    + android.os.Binder.getCallingPid());
+                    //p.set(Parameters.KEY_PREVIEW_SIZE+Parameters.SUPPORTED_VALUES_SUFFIX, size);
+                    //p.set(Parameters.KEY_PREVIEW_SIZE, size);
+                }
+            }
+        }
+        //!--
+        return p;
+    }
+
+    /** @hide
+     * Returns the current cct value of white balance.
+     *
+     * If it's in AWB mode, cct is determined by stats/awb module.
+     *
+     * If it's in Manual WB mode, it actually returns cct value
+     *     set by user via {@link #setParameters(Camera.Parameters)}.
+     */
+    public int getWBCurrentCCT() {
+        Parameters p = new Parameters();
+        String s = native_getParameters();
+        p.unflatten(s);
+
+        int cct = 0;
+        if (p.getWBCurrentCCT() != null) {
+            cct = Integer.parseInt(p.getWBCurrentCCT());
+        }
+
+        return cct;
+    }
+
+    //!++
+    /**
+     * Determine if the target process is restricted to get the all preview size list
+     * TRUE means the device is restricted
+     * FALSE means the device is not restricted
+     *
+     * @hide
+     */
+    public static boolean isRestricted(int pid) {
+        boolean ret = false;
+        String f = "/proc/" + pid + "/cmdline";
+
+        FileInputStream in = null;
+        try {
+            in = new FileInputStream(f);
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        }
+
+        InputStreamReader inReader = new InputStreamReader(in);
+        StringBuilder buffer = new StringBuilder();
+        char buf[] = new char[1];
+        try {
+            while (inReader.read(buf) != -1) {
+                buffer.append(buf[0]);
+            }
+            inReader.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        if (buffer.toString().contains("com.google.android.apps.unveil")) {
+            ret = true;
+        }
+        return ret;
+    }
+    /**
+     * M: Return the device's screen size
+     * The format is like: "800x480"
+     * The default screen size is "800x480"
+     *
+     * @hide
+     */
+    public static String getScreenSize() {
+        final String mHD720NOPK = "1184x720";
+        final String mWVGAScreenSize = "800x480";
+        final String mQhdScreenSize = "960x540";
+        final String m720P = "1280x720";
+        /// M: Default size is 800x480
+        String screenSize = mWVGAScreenSize;
+
+        /// M: Get screen size from display
+        android.hardware.display.DisplayManagerGlobal dmGlobal = android.hardware.display.DisplayManagerGlobal.getInstance();
+        android.view.Display dispaly = dmGlobal.getCompatibleDisplay(android.view.Display.DEFAULT_DISPLAY,
+                                                    android.view.DisplayAdjustments.DEFAULT_DISPLAY_ADJUSTMENTS);
+        android.graphics.Point size = new android.graphics.Point();
+        dispaly.getSize(size);
+
+        /// M: Put larger size in the front
+        if (size.x > size.y) {
+            screenSize = size.x + "x" + size.y;
+        } else {
+            screenSize = size.y + "x" + size.x;
+        }
+
+        /// M: For special screen size, change the return value
+        if (mHD720NOPK.equals(screenSize)) {
+            screenSize = mWVGAScreenSize;
+        } else if (mQhdScreenSize.equals(screenSize)) {
+            screenSize = mWVGAScreenSize;
+        } else if (m720P.equals(screenSize)) {
+            screenSize = mWVGAScreenSize;
+        }
+
+        Log.i(TAG, "Screen size = " + screenSize);
+        return screenSize;
+    }
+
+    /**
+     * @hide
+     *
+     * Enable stereo 3D camera mode
+     *
+     * This should be called before {@link #Camera.Parameters#getPreviewSize()), {@link #Camera.Parameters#getSupportedPreviewSizes()}.
+     * Otherwise, wrong sizes may be returned.
+     *
+     * @param enable true: enable stereo3d_mode, false: disable (default)
+     */
+    public void setStereo3DModeForCamera(boolean enable) {
+        mStereo3DModeForCamera = enable;
+    }
+    //!--
+
+    /**
+     * Returns an empty {@link Parameters} for testing purpose.
+     *
+     * @return a Parameter object.
+     *
+     * @hide
+     */
+    public static Parameters getEmptyParameters() {
+        Camera camera = new Camera();
+        return camera.new Parameters();
+    }
+
+    /* ### QC ADD-ONS: START */
+    private static int byteToInt(byte[] b, int offset) {
+        int value = 0;
+        for (int i = 0; i < 4; i++) {
+            int shift = (4 - 1 - i) * 8;
+            value += (b[(3-i) + offset] & 0x000000FF) << shift;
+        }
+        return value;
+    }
+    /** @hide
+     * Handles the callback for when Camera Data is available.
+     * data is read from the camera.
+     */
+    public interface CameraDataCallback {
+        /**
+         * Callback for when camera data is available.
+         *
+         * @param data   a int array of the camera data
+         * @param camera the Camera service object
+         */
+        void onCameraData(int[] data, Camera camera);
+    };
+
+    /** @hide
+     * Set camera histogram mode and registers a callback function to run.
+     *  Only valid after startPreview() has been called.
+     *
+     * @param cb the callback to run
+     */
+    public final void setHistogramMode(CameraDataCallback cb)
+    {
+        mCameraDataCallback = cb;
+        native_setHistogramMode(cb!=null);
+    }
+    private native final void native_setHistogramMode(boolean mode);
+
+    /** @hide
+     * Set camera histogram command to send data.
+     *
+     */
+    public final void sendHistogramData()
+    {
+        native_sendHistogramData();
+    }
+    private native final void native_sendHistogramData();
+
+    /** @hide
+     * Handles the callback for when Camera Meta Data is available.
+     * Meta data is read from the camera.
+     */
+    public interface CameraMetaDataCallback {
+        /**
+         * Callback for when camera meta data is available.
+         *
+         * @param data   a byte array of the camera meta data
+         * @param camera the Camera service object
+         */
+        void onCameraMetaData(byte[] data, Camera camera);
+    };
+
+    /** @hide
+     * Set camera meta data and registers a callback function to run.
+     *  Only valid after startPreview() has been called.
+     *
+     * @param cb the callback to run
+     */
+    public final void setMetadataCb(CameraMetaDataCallback cb)
+    {
+        mCameraMetaDataCallback = cb;
+        native_setMetadataCb(cb!=null);
+    }
+    private native final void native_setMetadataCb(boolean mode);
+
+    /** @hide
+     * Set camera face detection command to send meta data.
+     */
+    public final void sendMetaData()
+    {
+        native_sendMetaData();
+    }
+    private native final void native_sendMetaData();
+
+    /** @hide
+     * Configure longshot mode. Available only in ZSL.
+     *
+     * @param enable enable/disable this mode
+     */
+    public final void setLongshot(boolean enable)
+    {
+        native_setLongshot(enable);
+    }
+    private native final void native_setLongshot(boolean enable);
+
+    /** @hide
+     * Stop longshot. Available only in ZSL.
+     */
+    public final void stopLongshot()
+    {
+        native_stopLongshot();
+    }
+    private native final void native_stopLongshot();
+
+     /** @hide
+     * Handles the Touch Co-ordinate.
+     */
+     public class Coordinate {
+        /**
+         * Sets the x,y co-ordinates for a touch event
+         *
+         * @param x the x co-ordinate (pixels)
+         * @param y the y co-ordinate (pixels)
+         */
+        public Coordinate(int x, int y) {
+            xCoordinate = x;
+            yCoordinate = y;
+        }
+        /**
+         * Compares {@code obj} to this co-ordinate.
+         *
+         * @param obj the object to compare this co-ordinate with.
+         * @return {@code true} if the xCoordinate and yCoordinate of {@code obj} is the
+         *         same as those of this coordinate. {@code false} otherwise.
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof Coordinate)) {
+                return false;
+            }
+            Coordinate c = (Coordinate) obj;
+            return xCoordinate == c.xCoordinate && yCoordinate == c.yCoordinate;
+        }
+
+        /** x co-ordinate for the touch event*/
+        public int xCoordinate;
+
+        /** y co-ordinate for the touch event */
+        public int yCoordinate;
+    };
+
+    /** @hide
+     * Returns the current focus position.
+     *
+     * If it's in AF mode, it's the lens position after af is done.
+     *
+     * If it's in Manual Focus mode, it actually returns the value
+     *     set by user via {@link #setParameters(Camera.Parameters)}.
+     */
+    public int getCurrentFocusPosition() {
+        Parameters p = new Parameters();
+        String s = native_getParameters();
+        p.unflatten(s);
+
+        int focus_pos = -1;
+        if (p.getCurrentFocusPosition() != null) {
+            focus_pos = Integer.parseInt(p.getCurrentFocusPosition());
+        }
+        return focus_pos;
+    }
+
+    /* ### QC ADD-ONS: END */
+    /**
+     * Returns a copied {@link Parameters}; for shim use only.
+     *
+     * @param parameters a non-{@code null} parameters
+     * @return a Parameter object, with all the parameters copied from {@code parameters}.
+     *
+     * @throws NullPointerException if {@code parameters} was {@code null}
+     * @hide
+     */
+    public static Parameters getParametersCopy(Camera.Parameters parameters) {
+        if (parameters == null) {
+            throw new NullPointerException("parameters must not be null");
+        }
+
+        Camera camera = parameters.getOuter();
+        Parameters p = camera.new Parameters();
+        p.copyFrom(parameters);
+
+        return p;
+    }
+
+    /**
+     * Image size (width and height dimensions).
+     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
+     *             applications.
+     */
+    @Deprecated
+    public class Size {
+        /**
+         * Sets the dimensions for pictures.
+         *
+         * @param w the photo width (pixels)
+         * @param h the photo height (pixels)
+         */
+        public Size(int w, int h) {
+            width = w;
+            height = h;
+        }
+        /**
+         * Compares {@code obj} to this size.
+         *
+         * @param obj the object to compare this size with.
+         * @return {@code true} if the width and height of {@code obj} is the
+         *         same as those of this size. {@code false} otherwise.
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof Size)) {
+                return false;
+            }
+            Size s = (Size) obj;
+            return width == s.width && height == s.height;
+        }
+        @Override
+        public int hashCode() {
+            return width * 32713 + height;
+        }
+        /** width of the picture */
+        public int width;
+        /** height of the picture */
+        public int height;
+    };
+
+    /**
+     * <p>The Area class is used for choosing specific metering and focus areas for
+     * the camera to use when calculating auto-exposure, auto-white balance, and
+     * auto-focus.</p>
+     *
+     * <p>To find out how many simultaneous areas a given camera supports, use
+     * {@link Parameters#getMaxNumMeteringAreas()} and
+     * {@link Parameters#getMaxNumFocusAreas()}. If metering or focusing area
+     * selection is unsupported, these methods will return 0.</p>
+     *
+     * <p>Each Area consists of a rectangle specifying its bounds, and a weight
+     * that determines its importance. The bounds are relative to the camera's
+     * current field of view. The coordinates are mapped so that (-1000, -1000)
+     * is always the top-left corner of the current field of view, and (1000,
+     * 1000) is always the bottom-right corner of the current field of
+     * view. Setting Areas with bounds outside that range is not allowed. Areas
+     * with zero or negative width or height are not allowed.</p>
+     *
+     * <p>The weight must range from 1 to 1000, and represents a weight for
+     * every pixel in the area. This means that a large metering area with
+     * the same weight as a smaller area will have more effect in the
+     * metering result.  Metering areas can overlap and the driver
+     * will add the weights in the overlap region.</p>
+     *
+     * @see Parameters#setFocusAreas(List)
+     * @see Parameters#getFocusAreas()
+     * @see Parameters#getMaxNumFocusAreas()
+     * @see Parameters#setMeteringAreas(List)
+     * @see Parameters#getMeteringAreas()
+     * @see Parameters#getMaxNumMeteringAreas()
+     *
+     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
+     *             applications.
+     */
+    @Deprecated
+    public static class Area {
+        /**
+         * Create an area with specified rectangle and weight.
+         *
+         * @param rect the bounds of the area.
+         * @param weight the weight of the area.
+         */
+        public Area(Rect rect, int weight) {
+            this.rect = rect;
+            this.weight = weight;
+        }
+        /**
+         * Compares {@code obj} to this area.
+         *
+         * @param obj the object to compare this area with.
+         * @return {@code true} if the rectangle and weight of {@code obj} is
+         *         the same as those of this area. {@code false} otherwise.
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof Area)) {
+                return false;
+            }
+            Area a = (Area) obj;
+            if (rect == null) {
+                if (a.rect != null) return false;
+            } else {
+                if (!rect.equals(a.rect)) return false;
+            }
+            return weight == a.weight;
+        }
+
+        /**
+         * Bounds of the area. (-1000, -1000) represents the top-left of the
+         * camera field of view, and (1000, 1000) represents the bottom-right of
+         * the field of view. Setting bounds outside that range is not
+         * allowed. Bounds with zero or negative width or height are not
+         * allowed.
+         *
+         * @see Parameters#getFocusAreas()
+         * @see Parameters#getMeteringAreas()
+         */
+        public Rect rect;
+
+        /**
+         * Weight of the area. The weight must range from 1 to 1000, and
+         * represents a weight for every pixel in the area. This means that a
+         * large metering area with the same weight as a smaller area will have
+         * more effect in the metering result.  Metering areas can overlap and
+         * the driver will add the weights in the overlap region.
+         *
+         * @see Parameters#getFocusAreas()
+         * @see Parameters#getMeteringAreas()
+         */
+        public int weight;
+    }
+
+    /**
+     * Camera service settings.
+     *
+     * <p>To make camera parameters take effect, applications have to call
+     * {@link Camera#setParameters(Camera.Parameters)}. For example, after
+     * {@link Camera.Parameters#setWhiteBalance} is called, white balance is not
+     * actually changed until {@link Camera#setParameters(Camera.Parameters)}
+     * is called with the changed parameters object.
+     *
+     * <p>Different devices may have different camera capabilities, such as
+     * picture size or flash modes. The application should query the camera
+     * capabilities before setting parameters. For example, the application
+     * should call {@link Camera.Parameters#getSupportedColorEffects()} before
+     * calling {@link Camera.Parameters#setColorEffect(String)}. If the
+     * camera does not support color effects,
+     * {@link Camera.Parameters#getSupportedColorEffects()} will return null.
+     *
+     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new
+     *             applications.
+     */
+    @Deprecated
+    public class Parameters {
+        // Parameter keys to communicate with the camera driver.
+        private static final String KEY_PREVIEW_SIZE = "preview-size";
+        private static final String KEY_PREVIEW_FORMAT = "preview-format";
+        private static final String KEY_PREVIEW_FRAME_RATE = "preview-frame-rate";
+        private static final String KEY_PREVIEW_FPS_RANGE = "preview-fps-range";
+        private static final String KEY_PICTURE_SIZE = "picture-size";
+        private static final String KEY_PICTURE_FORMAT = "picture-format";
+        private static final String KEY_JPEG_THUMBNAIL_SIZE = "jpeg-thumbnail-size";
+        private static final String KEY_JPEG_THUMBNAIL_WIDTH = "jpeg-thumbnail-width";
+        private static final String KEY_JPEG_THUMBNAIL_HEIGHT = "jpeg-thumbnail-height";
+        private static final String KEY_JPEG_THUMBNAIL_QUALITY = "jpeg-thumbnail-quality";
+        private static final String KEY_JPEG_QUALITY = "jpeg-quality";
+        private static final String KEY_ROTATION = "rotation";
+        private static final String KEY_GPS_LATITUDE = "gps-latitude";
+        private static final String KEY_GPS_LONGITUDE = "gps-longitude";
+        private static final String KEY_GPS_ALTITUDE = "gps-altitude";
+        private static final String KEY_GPS_TIMESTAMP = "gps-timestamp";
+        private static final String KEY_GPS_PROCESSING_METHOD = "gps-processing-method";
+        private static final String KEY_WHITE_BALANCE = "whitebalance";
+        private static final String KEY_EFFECT = "effect";
+        private static final String KEY_ANTIBANDING = "antibanding";
+        private static final String KEY_SCENE_MODE = "scene-mode";
+        private static final String KEY_FLASH_MODE = "flash-mode";
+        private static final String KEY_FOCUS_MODE = "focus-mode";
+        private static final String KEY_FOCUS_AREAS = "focus-areas";
+        private static final String KEY_MAX_NUM_FOCUS_AREAS = "max-num-focus-areas";
+        private static final String KEY_FOCAL_LENGTH = "focal-length";
+        private static final String KEY_HORIZONTAL_VIEW_ANGLE = "horizontal-view-angle";
+        private static final String KEY_VERTICAL_VIEW_ANGLE = "vertical-view-angle";
+        private static final String KEY_EXPOSURE_COMPENSATION = "exposure-compensation";
+        private static final String KEY_MAX_EXPOSURE_COMPENSATION = "max-exposure-compensation";
+        private static final String KEY_MIN_EXPOSURE_COMPENSATION = "min-exposure-compensation";
+        private static final String KEY_EXPOSURE_COMPENSATION_STEP = "exposure-compensation-step";
+        private static final String KEY_AUTO_EXPOSURE_LOCK = "auto-exposure-lock";
+        private static final String KEY_AUTO_EXPOSURE_LOCK_SUPPORTED = "auto-exposure-lock-supported";
+        private static final String KEY_AUTO_WHITEBALANCE_LOCK = "auto-whitebalance-lock";
+        private static final String KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED = "auto-whitebalance-lock-supported";
+        private static final String KEY_METERING_AREAS = "metering-areas";
+        private static final String KEY_MAX_NUM_METERING_AREAS = "max-num-metering-areas";
+        private static final String KEY_ZOOM = "zoom";
+        private static final String KEY_MAX_ZOOM = "max-zoom";
+        private static final String KEY_ZOOM_RATIOS = "zoom-ratios";
+        private static final String KEY_ZOOM_SUPPORTED = "zoom-supported";
+        private static final String KEY_SMOOTH_ZOOM_SUPPORTED = "smooth-zoom-supported";
+        private static final String KEY_FOCUS_DISTANCES = "focus-distances";
+        private static final String KEY_VIDEO_SIZE = "video-size";
+        private static final String KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO =
+                                            "preferred-preview-size-for-video";
+        private static final String KEY_HSVR_PRV_SIZE = "hsvr-prv-size";
+        private static final String KEY_HSVR_PRV_FPS = "hsvr-prv-fps";
+        private static final String KEY_MAX_NUM_DETECTED_FACES_HW = "max-num-detected-faces-hw";
+        private static final String KEY_MAX_NUM_DETECTED_FACES_SW = "max-num-detected-faces-sw";
+        private static final String KEY_RECORDING_HINT = "recording-hint";
+        private static final String KEY_VIDEO_SNAPSHOT_SUPPORTED = "video-snapshot-supported";
+        private static final String KEY_VIDEO_STABILIZATION = "video-stabilization";
+        private static final String KEY_VIDEO_STABILIZATION_SUPPORTED = "video-stabilization-supported";
+        private static final String KEY_PDAF_SUPPORTED = "pdaf-supported";
+        //!++
+        private static final String KEY_ISOSPEED_MODE = "iso-speed";
+        private static final String KEY_FD_MODE = "fd-mode";
+        private static final String KEY_EDGE_MODE = "edge";
+        private static final String KEY_HUE_MODE = "hue";
+        private static final String KEY_SATURATION_MODE = "saturation";
+        private static final String KEY_BRIGHTNESS_MODE = "brightness";
+        private static final String KEY_CONTRAST_MODE = "contrast";
+        private static final String KEY_CAMERA_MODE = "mtk-cam-mode";
+        private static final String KEY_FPS_MODE = "fps-mode";
+        private static final String KEY_RAW_SAVE_MODE = "rawsave-mode";
+        private static final String KEY_FOCUS_ENG_MODE = "afeng-mode";
+        private static final String KEY_FOCUS_ENG_STEP = "afeng-pos";
+        private static final String KEY_FOCUS_ENG_MAX_STEP = "afeng-max-focus-step";
+        private static final String KEY_FOCUS_ENG_MIN_STEP = "afeng-min-focus-step";
+        private static final String KEY_FOCUS_ENG_BEST_STEP = "afeng-best-focus-step";
+        private static final String KEY_RAW_DUMP_FLAG = "afeng_raw_dump_flag";
+        private static final String KEY_PREVIEW_DUMP_RESOLUTION = "prv-dump-res";
+
+        private static final String KEY_ENG_AE_ENABLE = "ae-e";
+        private static final String KEY_ENG_PREVIEW_SHUTTER_SPEED = "prv-ss";
+        private static final String KEY_ENG_PREVIEW_SENSOR_GAIN = "prv-sr-g";
+        private static final String KEY_ENG_PREVIEW_ISP_GAIN = "prv-isp-g";
+        private static final String KEY_ENG_PREVIEW_AE_INDEX = "prv-ae-i";
+        private static final String KEY_ENG_CAPTURE_SENSOR_GAIN = "cap-sr-g";
+        private static final String KEY_ENG_CAPTURE_ISP_GAIN = "cap-isp-g";
+        private static final String KEY_ENG_CAPTURE_SHUTTER_SPEED = "cap-ss";
+        private static final String KEY_ENG_CAPTURE_ISO = "cap-iso";
+        private static final String KEY_ENG_FLASH_DUTY_VALUE = "flash-duty-value";
+        private static final String KEY_ENG_FLASH_DUTY_MIN = "flash-duty-min";
+        private static final String KEY_ENG_FLASH_DUTY_MAX = "flash-duty-max";
+        private static final String KEY_ENG_ZSD_ENABLE = "eng-zsd-e";
+        private static final String KEY_SENSOR_TYPE = "sensor-type";
+        private static final String KEY_ENG_PREVIEW_FPS = "eng-prv-fps";
+        private static final String KEY_ENG_MSG = "eng-msg";
+        private static final String KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL = "focus-fs-fi";
+        private static final String KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX = "focus-fs-fi-max";
+        private static final String KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN = "focus-fs-fi-min";
+        private static final String KEY_ENG_PREVIEW_FRAME_INTERVAL_IN_US = "eng-prv-fius";
+        private static final String KEY_ENG_PARAMETER1 = "eng-p1";
+        private static final String KEY_ENG_PARAMETER2 = "eng-p2";
+        private static final String KEY_ENG_PARAMETER3 = "eng-p3";
+        private static final String KEY_ENG_SAVE_SHADING_TABLE = "eng-s-shad-t";
+        private static final String KEY_ENG_SHADING_TABLE = "eng-shad-t";
+        private static final String KEY_ENG_EV_CALBRATION_OFFSET_VALUE = "ev-cal-o";
+        private static final String KEY_ENG_MFLL_SUPPORTED = "eng-mfll-s";
+        private static final String KEY_ENG_MFLL_ENABLE = "eng-mfll-e";
+        private static final String KEY_ENG_MFLL_PICTURE_COUNT = "eng-mfll-pc";
+        private static final String KEY_ENG_SENOSR_MODE_SLIM_VIDEO1_SUPPORTED = "sv1-s";
+        private static final String KEY_ENG_SENOSR_MODE_SLIM_VIDEO2_SUPPORTED = "sv2-s";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_RESIZE_TO_2M_SUPPORTED = "vdr-r2m-s";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_RESIZE_TO_4K2K_SUPPORTED = "vdr-r4k2k-s";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_CROP_CENTER_2M_SUPPORTED = "vdr-cc2m-s";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_SUPPORTED = "vrd-mfr-s";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_ENABLE = "vrd-mfr-e";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_MIN = "vrd-mfr-min";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_MAX = "vrd-mfr-max";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_RANGE_LOW = "vrd-mfr-low";
+        private static final String KEY_ENG_VIDEO_RAW_DUMP_MANUAL_FRAME_RATE_RANGE_HIGH = "vrd-mfr-high";
+        private static final String KEY_ENG_MTK_AWB_SUPPORTED = "mtk-awb-s";
+        private static final String KEY_ENG_SENSOR_AWB_SUPPORTED = "sr-awb-s";
+        private static final String KEY_ENG_MTK_AWB_ENABLE = "mtk-awb-e";
+        private static final String KEY_ENG_SENSOR_AWB_ENABLE = "sr-awb-e";
+        private static final String KEY_ENG_MTK_SHADING_SUPPORTED = "mtk-shad-s";
+        private static final String KEY_ENG_MTK_1to3_SHADING_SUPPORTED = "mtk-123-shad-s";
+        private static final String KEY_ENG_SENSOR_SHADNING_SUPPORTED = "sr-shad-s";
+        private static final String KEY_ENG_MTK_SHADING_ENABLE = "mtk-shad-e";
+        private static final String KEY_ENG_MTK_1to3_SHADING_ENABLE = "mtk-123-shad-e";
+        private static final String KEY_ENG_SENSOR_SHADNING_ENABLE = "sr-shad-e";
+
+        private static final String KEY_CAPTURE_MODE = "cap-mode";
+        private static final String KEY_CAPTURE_PATH = "capfname";
+        private static final String KEY_BURST_SHOT_NUM = "burst-num";
+        private static final String KEY_MATV_PREVIEW_DELAY = "tv-delay";
+        private static final String KEY_SENSOR_DEV = "sensor-dev";
+        private static final String KEY_EIS_MODE = "eis-mode";
+        private static final String KEY_AFLAMP_MODE = "aflamp-mode";
+        private static final String KEY_ZSD_MODE = "zsd-mode";
+        private static final String KEY_CONTINUOUS_SPEED_MODE = "continuous-shot-speed";
+        //
+        private static final String KEY_ZSD_SUPPORTED = "zsd-supported";
+    private static final String KEY_MUTE_RECORDING_SOUND = "rec-mute-ogg";
+        // Exposure meter mode for OT
+        private static final String KEY_EXPOSURE_METER_MODE = "exposure-meter";
+        // add for pip
+        private static final String KEY_MAX_FRAME_RATE_ZSD_ON = "pip-fps-zsd-on";
+        private static final String KEY_MAX_FRAME_RATE_ZSD_OFF = "pip-fps-zsd-off";
+        private static final String KEY_DYNAMIC_FRAME_RATE = "dynamic-frame-rate";
+        private static final String KEY_DYNAMIC_FRAME_RATE_SUPPORTED = "dynamic-frame-rate-supported";
+        // add for image refocus
+        private static final String KEY_REFOCUS_JPS_FILE_NAME = "refocus-jps-file-name";
+        private static final String KEY_STEREO_REFOCUS_MODE = "stereo-image-refocus";
+        private static final String KEY_STEREO_DEPTHAF_MODE = "stereo-depth-af";
+        private static final String KEY_STEREO_DISTANCE_MODE = "stereo-distance-measurement";
+    /**
+     * @hide
+    */
+        public static final String WHITE_BALANCE_TUNGSTEN = "tungsten";
+        //!--
+        // Parameter key suffix for supported values.
+        private static final String SUPPORTED_VALUES_SUFFIX = "-values";
+
+        private static final String TRUE = "true";
+        private static final String FALSE = "false";
+
+        // Values for white balance settings.
+        public static final String WHITE_BALANCE_AUTO = "auto";
+        public static final String WHITE_BALANCE_INCANDESCENT = "incandescent";
+        public static final String WHITE_BALANCE_FLUORESCENT = "fluorescent";
+        public static final String WHITE_BALANCE_WARM_FLUORESCENT = "warm-fluorescent";
+        public static final String WHITE_BALANCE_DAYLIGHT = "daylight";
+        public static final String WHITE_BALANCE_CLOUDY_DAYLIGHT = "cloudy-daylight";
+        public static final String WHITE_BALANCE_TWILIGHT = "twilight";
+        public static final String WHITE_BALANCE_SHADE = "shade";
+        /** @hide
+         * wb manual cct mode.
+         */
+        public static final String WHITE_BALANCE_MANUAL_CCT = "manual-cct";
+
+        // Values for color effect settings.
+        public static final String EFFECT_NONE = "none";
+        public static final String EFFECT_MONO = "mono";
+        public static final String EFFECT_NEGATIVE = "negative";
+        public static final String EFFECT_SOLARIZE = "solarize";
+        public static final String EFFECT_SEPIA = "sepia";
+        public static final String EFFECT_POSTERIZE = "posterize";
+        public static final String EFFECT_WHITEBOARD = "whiteboard";
+        public static final String EFFECT_BLACKBOARD = "blackboard";
+        public static final String EFFECT_AQUA = "aqua";
+
+        // Values for antibanding settings.
+        public static final String ANTIBANDING_AUTO = "auto";
+        public static final String ANTIBANDING_50HZ = "50hz";
+        public static final String ANTIBANDING_60HZ = "60hz";
+        public static final String ANTIBANDING_OFF = "off";
+
+        //!++
+        // Add for STEREO 3D
+
+        private static final String ON = "on";
+        private static final String OFF = "off";
+        /**
+         *@hide
+         */
+        private static final String KEY_STEREO3D_PRE = "stereo3d-";
+        /**
+         *@hide
+         */
+        public static final String KEY_STEREO3D_TYPE = "type";
+        /**
+         *@hide
+         */
+        public static final String KEY_STEREO3D_MODE = "mode";
+        /**
+         *@hide
+         */
+        public static final String STEREO3D_TYPE_OFF = "off";
+        /**
+         * Frame sequential
+         *@hide
+         */
+        public static final String STEREO3D_TYPE_FRAMESEQ = "frame_seq";
+        /**
+         * Side-by-side
+         *@hide
+         */
+        public static final String STEREO3D_TYPE_SIDEBYSIDE = "sidebyside";
+        /**
+         * Top-bottom
+         *@hide
+         */
+        public static final String STEREO3D_TYPE_TOPBOTTOM = "topbottom";
+        /**
+         *@hide
+         */
+        private boolean mStereo3DMode = false;
+        //for EIS mode
+        /**
+         * Eletric image stablization on
+         * @hide
+         */
+        public static final String EIS_MODE_ON = "on";
+        /**
+         * Eletric image stablization off
+         * @hide
+         */
+        public static final String EIS_MODE_OFF = "off";
+        //!--
+
+        // Values for flash mode settings.
+        /**
+         * Flash will not be fired.
+         */
+        public static final String FLASH_MODE_OFF = "off";
+
+        /**
+         * Flash will be fired automatically when required. The flash may be fired
+         * during preview, auto-focus, or snapshot depending on the driver.
+         */
+        public static final String FLASH_MODE_AUTO = "auto";
+
+        /**
+         * Flash will always be fired during snapshot. The flash may also be
+         * fired during preview or auto-focus depending on the driver.
+         */
+        public static final String FLASH_MODE_ON = "on";
+
+        /**
+         * Flash will be fired in red-eye reduction mode.
+         */
+        public static final String FLASH_MODE_RED_EYE = "red-eye";
+
+        /**
+         * Constant emission of light during preview, auto-focus and snapshot.
+         * This can also be used for video recording.
+         */
+        public static final String FLASH_MODE_TORCH = "torch";
+
+        /** @hide
+         * Scene mode is off.
+         */
+        public static final String SCENE_MODE_ASD = "asd";
+
+        /**
+         * Scene mode is off.
+         */
+        public static final String SCENE_MODE_AUTO = "auto";
+
+        /**
+         * Take photos of fast moving objects. Same as {@link
+         * #SCENE_MODE_SPORTS}.
+         */
+        public static final String SCENE_MODE_ACTION = "action";
+
+        /**
+         * Take people pictures.
+         */
+        public static final String SCENE_MODE_PORTRAIT = "portrait";
+
+        /**
+         * Take pictures on distant objects.
+         */
+        public static final String SCENE_MODE_LANDSCAPE = "landscape";
+
+        /**
+         * Take photos at night.
+         */
+        public static final String SCENE_MODE_NIGHT = "night";
+
+        /**
+         * Take people pictures at night.
+         */
+        public static final String SCENE_MODE_NIGHT_PORTRAIT = "night-portrait";
+
+        /**
+         * Take photos in a theater. Flash light is off.
+         */
+        public static final String SCENE_MODE_THEATRE = "theatre";
+
+        /**
+         * Take pictures on the beach.
+         */
+        public static final String SCENE_MODE_BEACH = "beach";
+
+        /**
+         * Take pictures on the snow.
+         */
+        public static final String SCENE_MODE_SNOW = "snow";
+
+        /**
+         * Take sunset photos.
+         */
+        public static final String SCENE_MODE_SUNSET = "sunset";
+
+        /**
+         * Avoid blurry pictures (for example, due to hand shake).
+         */
+        public static final String SCENE_MODE_STEADYPHOTO = "steadyphoto";
+
+        /**
+         * For shooting firework displays.
+         */
+        public static final String SCENE_MODE_FIREWORKS = "fireworks";
+
+        /**
+         * Take photos of fast moving objects. Same as {@link
+         * #SCENE_MODE_ACTION}.
+         */
+        public static final String SCENE_MODE_SPORTS = "sports";
+
+        /**
+         * Take indoor low-light shot.
+         */
+        public static final String SCENE_MODE_PARTY = "party";
+
+        /**
+         * Capture the naturally warm color of scenes lit by candles.
+         */
+        public static final String SCENE_MODE_CANDLELIGHT = "candlelight";
+        /** @hide
+        * SCENE_MODE_BACKLIGHT
+        **/
+        public static final String SCENE_MODE_BACKLIGHT = "backlight";
+        /** @hide
+        * SCENE_MODE_FLOWERS
+        **/
+        public static final String SCENE_MODE_FLOWERS = "flowers";
+
+        /**
+         * Applications are looking for a barcode. Camera driver will be
+         * optimized for barcode reading.
+         */
+        public static final String SCENE_MODE_BARCODE = "barcode";
+
+        /**
+         * Capture a scene using high dynamic range imaging techniques. The
+         * camera will return an image that has an extended dynamic range
+         * compared to a regular capture. Capturing such an image may take
+         * longer than a regular capture.
+         */
+        public static final String SCENE_MODE_HDR = "hdr";
+
+        /**
+         * Auto-focus mode. Applications should call {@link
+         * #autoFocus(AutoFocusCallback)} to start the focus in this mode.
+         */
+        public static final String FOCUS_MODE_AUTO = "auto";
+
+        /**
+         * Focus is set at infinity. Applications should not call
+         * {@link #autoFocus(AutoFocusCallback)} in this mode.
+         */
+        public static final String FOCUS_MODE_INFINITY = "infinity";
+
+        /**
+         * Macro (close-up) focus mode. Applications should call
+         * {@link #autoFocus(AutoFocusCallback)} to start the focus in this
+         * mode.
+         */
+        public static final String FOCUS_MODE_MACRO = "macro";
+
+        /**
+         * Focus is fixed. The camera is always in this mode if the focus is not
+         * adjustable. If the camera has auto-focus, this mode can fix the
+         * focus, which is usually at hyperfocal distance. Applications should
+         * not call {@link #autoFocus(AutoFocusCallback)} in this mode.
+         */
+        public static final String FOCUS_MODE_FIXED = "fixed";
+
+        /** @hide
+         * Normal focus mode. Applications should call
+         * {@link #autoFocus(AutoFocusCallback)} to start the focus in this
+         * mode.
+         */
+        public static final String FOCUS_MODE_NORMAL = "normal";
+
+        /**
+         * Extended depth of field (EDOF). Focusing is done digitally and
+         * continuously. Applications should not call {@link
+         * #autoFocus(AutoFocusCallback)} in this mode.
+         */
+        public static final String FOCUS_MODE_EDOF = "edof";
+
+       //!++
+        /*
+         * for Camera mode
+        */
+        /**
+          * @hide
+         */
+        public static final int CAMERA_MODE_NORMAL  = 0;
+        /**
+          * @hide
+         */
+        public static final int CAMERA_MODE_MTK_PRV = 1;
+        /**
+          * @hide
+         */
+        public static final int CAMERA_MODE_MTK_VDO = 2;
+        /**
+          * @hide
+         */
+        public static final int CAMERA_MODE_MTK_VT  = 3;
+
+        /*
+         * for AF engineer mode
+        */
+        /**
+          * @hide
+         */
+        public static final int FOCUS_ENG_MODE_NONE = 0;
+        /**
+          * @hide
+         */
+        public static final int FOCUS_ENG_MODE_BRACKET = 1;
+        /**
+          * @hide
+         */
+        public static final int FOCUS_ENG_MODE_FULLSCAN = 2;
+        /**
+          * @hide
+         */
+        public static final int FOCUS_ENG_MODE_FULLSCAN_REPEAT = 3;
+        /**
+          * @hide
+         */
+        public static final int FOCUS_ENG_MODE_REPEAT = 4;
+        /**
+          * @hide
+         */
+        public static final String FOCUS_MODE_MANUAL = "manual";
+        /**
+          * @hide
+         */
+        public static final String FOCUS_MODE_FULLSCAN = "fullscan";
+
+        /**
+          * @hide
+         */
+        public static final int PREVIEW_DUMP_RESOLUTION_NORMAL  = 0;
+        /**
+          * @hide
+         */
+        public static final int PREVIEW_DUMP_RESOLUTION_CROP = 1;
+
+
+        // Values for capture mode settings.
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_NORMAL = "normal";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_BEST_SHOT = "bestshot";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_EV_BRACKET_SHOT = "evbracketshot";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_BURST_SHOT = "burstshot";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_SMILE_SHOT = "smileshot";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_GESTURE_SHOT = "gestureshot";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_PANORAMA_SHOT = "autorama";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_HDR = "hdr";
+        /**
+          * @hide
+         */
+        public static final String CAPTURE_MODE_ASD = "asd";
+        /**
+         * @hide
+         */
+        public static final String CAPTURE_MODE_FB = "face_beauty";
+        /**
+         * @hide
+         */
+        public static final String KEY_MAX_NUM_DETECTED_OBJECT = "max-num-ot";
+        /**
+         * @hide
+         */
+        public static final String CAPTURE_MODE_S3D = "single3d";
+        /**
+         * @hide
+         */
+        public static final String CAPTURE_MODE_PANORAMA3D = "panorama3dmode";
+        /**
+         * @hide
+         */
+        public static final String CAPTURE_MODE_CONTINUOUS_SHOT = "continuousshot";
 
-        // Parameter key suffix for supported values.
-        private static final String SUPPORTED_VALUES_SUFFIX = "-values";
+        // Values for KEY_SENSOR_DEV
+        /**
+         * @hide
+         */
+        public static final String SENSOR_DEV_MAIN = "main";
+        /**
+         * @hide
+         */
+        public static final String SENSOR_DEV_SUB =  "sub";
+        /**
+         * @hide
+         */
+        public static final String SENSOR_DEV_ATV = "atv";
+        //!--
 
-        private static final String TRUE = "true";
-        private static final String FALSE = "false";
+        /**
+         * Continuous auto focus mode intended for video recording. The camera
+         * continuously tries to focus. This is the best choice for video
+         * recording because the focus changes smoothly . Applications still can
+         * call {@link #takePicture(Camera.ShutterCallback,
+         * Camera.PictureCallback, Camera.PictureCallback)} in this mode but the
+         * subject may not be in focus. Auto focus starts when the parameter is
+         * set.
+         *
+         * <p>Since API level 14, applications can call {@link
+         * #autoFocus(AutoFocusCallback)} in this mode. The focus callback will
+         * immediately return with a boolean that indicates whether the focus is
+         * sharp or not. The focus position is locked after autoFocus call. If
+         * applications want to resume the continuous focus, cancelAutoFocus
+         * must be called. Restarting the preview will not resume the continuous
+         * autofocus. To stop continuous focus, applications should change the
+         * focus mode to other modes.
+         *
+         * @see #FOCUS_MODE_CONTINUOUS_PICTURE
+         */
+        public static final String FOCUS_MODE_CONTINUOUS_VIDEO = "continuous-video";
+
+        /**
+         * Continuous auto focus mode intended for taking pictures. The camera
+         * continuously tries to focus. The speed of focus change is more
+         * aggressive than {@link #FOCUS_MODE_CONTINUOUS_VIDEO}. Auto focus
+         * starts when the parameter is set.
+         *
+         * <p>Applications can call {@link #autoFocus(AutoFocusCallback)} in
+         * this mode. If the autofocus is in the middle of scanning, the focus
+         * callback will return when it completes. If the autofocus is not
+         * scanning, the focus callback will immediately return with a boolean
+         * that indicates whether the focus is sharp or not. The apps can then
+         * decide if they want to take a picture immediately or to change the
+         * focus mode to auto, and run a full autofocus cycle. The focus
+         * position is locked after autoFocus call. If applications want to
+         * resume the continuous focus, cancelAutoFocus must be called.
+         * Restarting the preview will not resume the continuous autofocus. To
+         * stop continuous focus, applications should change the focus mode to
+         * other modes.
+         *
+         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
+         */
+        public static final String FOCUS_MODE_CONTINUOUS_PICTURE = "continuous-picture";
 
-        // Values for white balance settings.
-        public static final String WHITE_BALANCE_AUTO = "auto";
-        public static final String WHITE_BALANCE_INCANDESCENT = "incandescent";
-        public static final String WHITE_BALANCE_FLUORESCENT = "fluorescent";
-        public static final String WHITE_BALANCE_WARM_FLUORESCENT = "warm-fluorescent";
-        public static final String WHITE_BALANCE_DAYLIGHT = "daylight";
-        public static final String WHITE_BALANCE_CLOUDY_DAYLIGHT = "cloudy-daylight";
-        public static final String WHITE_BALANCE_TWILIGHT = "twilight";
-        public static final String WHITE_BALANCE_SHADE = "shade";
         /** @hide
-         * wb manual cct mode.
+         *  manual focus mode
          */
-        public static final String WHITE_BALANCE_MANUAL_CCT = "manual-cct";
+        public static final String FOCUS_MODE_MANUAL_POSITION = "manual";
 
-        // Values for color effect settings.
-        public static final String EFFECT_NONE = "none";
-        public static final String EFFECT_MONO = "mono";
-        public static final String EFFECT_NEGATIVE = "negative";
-        public static final String EFFECT_SOLARIZE = "solarize";
-        public static final String EFFECT_SEPIA = "sepia";
-        public static final String EFFECT_POSTERIZE = "posterize";
-        public static final String EFFECT_WHITEBOARD = "whiteboard";
-        public static final String EFFECT_BLACKBOARD = "blackboard";
-        public static final String EFFECT_AQUA = "aqua";
+        // Indices for focus distance array.
+        /**
+         * The array index of near focus distance for use with
+         * {@link #getFocusDistances(float[])}.
+         */
+        public static final int FOCUS_DISTANCE_NEAR_INDEX = 0;
 
-        // Values for antibanding settings.
-        public static final String ANTIBANDING_AUTO = "auto";
-        public static final String ANTIBANDING_50HZ = "50hz";
-        public static final String ANTIBANDING_60HZ = "60hz";
-        public static final String ANTIBANDING_OFF = "off";
+        /**
+         * The array index of optimal focus distance for use with
+         * {@link #getFocusDistances(float[])}.
+         */
+        public static final int FOCUS_DISTANCE_OPTIMAL_INDEX = 1;
 
-        // Values for flash mode settings.
         /**
-         * Flash will not be fired.
+         * The array index of far focus distance for use with
+         * {@link #getFocusDistances(float[])}.
          */
-        public static final String FLASH_MODE_OFF = "off";
+        public static final int FOCUS_DISTANCE_FAR_INDEX = 2;
 
         /**
-         * Flash will be fired automatically when required. The flash may be fired
-         * during preview, auto-focus, or snapshot depending on the driver.
+         * The array index of minimum preview fps for use with {@link
+         * #getPreviewFpsRange(int[])} or {@link
+         * #getSupportedPreviewFpsRange()}.
          */
-        public static final String FLASH_MODE_AUTO = "auto";
+        public static final int PREVIEW_FPS_MIN_INDEX = 0;
 
         /**
-         * Flash will always be fired during snapshot. The flash may also be
-         * fired during preview or auto-focus depending on the driver.
+         * The array index of maximum preview fps for use with {@link
+         * #getPreviewFpsRange(int[])} or {@link
+         * #getSupportedPreviewFpsRange()}.
          */
-        public static final String FLASH_MODE_ON = "on";
+        public static final int PREVIEW_FPS_MAX_INDEX = 1;
+
+        // Formats for setPreviewFormat and setPictureFormat.
+        private static final String PIXEL_FORMAT_YUV422SP = "yuv422sp";
+        private static final String PIXEL_FORMAT_YUV420SP = "yuv420sp";
+        private static final String PIXEL_FORMAT_YUV420SP_ADRENO = "yuv420sp-adreno";
+        private static final String PIXEL_FORMAT_YUV422I = "yuv422i-yuyv";
+        private static final String PIXEL_FORMAT_YUV420P = "yuv420p";
+        private static final String PIXEL_FORMAT_RGB565 = "rgb565";
+        private static final String PIXEL_FORMAT_JPEG = "jpeg";
+        private static final String PIXEL_FORMAT_BAYER_RGGB = "bayer-rggb";
+        private static final String PIXEL_FORMAT_RAW = "raw";
+        private static final String PIXEL_FORMAT_YV12 = "yv12";
+        private static final String PIXEL_FORMAT_NV12 = "nv12";
+
+        /**
+         * Order matters: Keys that are {@link #set(String, String) set} later
+         * will take precedence over keys that are set earlier (if the two keys
+         * conflict with each other).
+         *
+         * <p>One example is {@link #setPreviewFpsRange(int, int)} , since it
+         * conflicts with {@link #setPreviewFrameRate(int)} whichever key is set later
+         * is the one that will take precedence.
+         * </p>
+         */
+        private final LinkedHashMap<String, String> mMap;
+
+        private Parameters() {
+            mMap = new LinkedHashMap<String, String>(/*initialCapacity*/64);
+        }
+
+        /**
+         * Overwrite existing parameters with a copy of the ones from {@code other}.
+         *
+         * <b>For use by the legacy shim only.</b>
+         *
+         * @hide
+         */
+        public void copyFrom(Parameters other) {
+            if (other == null) {
+                throw new NullPointerException("other must not be null");
+            }
+
+            mMap.putAll(other.mMap);
+        }
+
+        private Camera getOuter() {
+            return Camera.this;
+        }
+
+
+        /**
+         * Value equality check.
+         *
+         * @hide
+         */
+        public boolean same(Parameters other) {
+            if (this == other) {
+                return true;
+            }
+            return other != null && Parameters.this.mMap.equals(other.mMap);
+        }
+
+        /**
+         * Writes the current Parameters to the log.
+         * @hide
+         * @deprecated
+         */
+        @Deprecated
+        public void dump() {
+            Log.e(TAG, "dump: size=" + mMap.size());
+            for (String k : mMap.keySet()) {
+                Log.e(TAG, "dump: " + k + "=" + mMap.get(k));
+            }
+        }
+
+        /**
+         * Creates a single string with all the parameters set in
+         * this Parameters object.
+         * <p>The {@link #unflatten(String)} method does the reverse.</p>
+         *
+         * @return a String with all values from this Parameters object, in
+         *         semi-colon delimited key-value pairs
+         */
+        public String flatten() {
+            StringBuilder flattened = new StringBuilder(128);
+            for (String k : mMap.keySet()) {
+                flattened.append(k);
+                flattened.append("=");
+                flattened.append(mMap.get(k));
+                flattened.append(";");
+            }
+            // chop off the extra semicolon at the end
+            flattened.deleteCharAt(flattened.length()-1);
+            return flattened.toString();
+        }
+
+        /**
+         * Takes a flattened string of parameters and adds each one to
+         * this Parameters object.
+         * <p>The {@link #flatten()} method does the reverse.</p>
+         *
+         * @param flattened a String of parameters (key-value paired) that
+         *                  are semi-colon delimited
+         */
+        public void unflatten(String flattened) {
+            mMap.clear();
+
+            TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(';');
+            splitter.setString(flattened);
+            for (String kv : splitter) {
+                int pos = kv.indexOf('=');
+                if (pos == -1) {
+                    continue;
+                }
+                String k = kv.substring(0, pos);
+                String v = kv.substring(pos + 1);
+                mMap.put(k, v);
+            }
+        }
 
-        /**
-         * Flash will be fired in red-eye reduction mode.
-         */
-        public static final String FLASH_MODE_RED_EYE = "red-eye";
+        public void remove(String key) {
+            mMap.remove(key);
+        }
 
         /**
-         * Constant emission of light during preview, auto-focus and snapshot.
-         * This can also be used for video recording.
+         * Sets a String parameter.
+         *
+         * @param key   the key name for the parameter
+         * @param value the String value of the parameter
          */
-        public static final String FLASH_MODE_TORCH = "torch";
+        public void set(String key, String value) {
+            Log.v(TAG, "set Key = " + key + ", value = " + value);
+            if (key.indexOf('=') != -1 || key.indexOf(';') != -1 || key.indexOf(0) != -1) {
+                Log.e(TAG, "Key \"" + key + "\" contains invalid character (= or ; or \\0)");
+                return;
+            }
+            if (value.indexOf('=') != -1 || value.indexOf(';') != -1 || value.indexOf(0) != -1) {
+                Log.e(TAG, "Value \"" + value + "\" contains invalid character (= or ; or \\0)");
+                return;
+            }
 
-        /** @hide
-         * Scene mode is off.
-         */
-        public static final String SCENE_MODE_ASD = "asd";
+            put(key, value);
+        }
 
         /**
-         * Scene mode is off.
+         * Sets an integer parameter.
+         *
+         * @param key   the key name for the parameter
+         * @param value the int value of the parameter
          */
-        public static final String SCENE_MODE_AUTO = "auto";
+        public void set(String key, int value) {
+            put(key, Integer.toString(value));
+        }
 
-        /**
-         * Take photos of fast moving objects. Same as {@link
-         * #SCENE_MODE_SPORTS}.
-         */
-        public static final String SCENE_MODE_ACTION = "action";
+        private void put(String key, String value) {
+            /*
+             * Remove the key if it already exists.
+             *
+             * This way setting a new value for an already existing key will always move
+             * that key to be ordered the latest in the map.
+             */
+            mMap.remove(key);
+            mMap.put(key, value);
+        }
+
+        private void set(String key, List<Area> areas) {
+            if (areas == null) {
+                set(key, "(0,0,0,0,0)");
+            } else {
+                StringBuilder buffer = new StringBuilder();
+                for (int i = 0; i < areas.size(); i++) {
+                    Area area = areas.get(i);
+                    Rect rect = area.rect;
+                    buffer.append('(');
+                    buffer.append(rect.left);
+                    buffer.append(',');
+                    buffer.append(rect.top);
+                    buffer.append(',');
+                    buffer.append(rect.right);
+                    buffer.append(',');
+                    buffer.append(rect.bottom);
+                    buffer.append(',');
+                    buffer.append(area.weight);
+                    buffer.append(')');
+                    if (i != areas.size() - 1) buffer.append(',');
+                }
+                set(key, buffer.toString());
+            }
+        }
 
         /**
-         * Take people pictures.
+         * Returns the value of a String parameter.
+         *
+         * @param key the key name for the parameter
+         * @return the String value of the parameter
          */
-        public static final String SCENE_MODE_PORTRAIT = "portrait";
+        public String get(String key) {
+            return mMap.get(key);
+        }
 
         /**
-         * Take pictures on distant objects.
+         * Returns the value of an integer parameter.
+         *
+         * @param key the key name for the parameter
+         * @return the int value of the parameter
          */
-        public static final String SCENE_MODE_LANDSCAPE = "landscape";
+        public int getInt(String key) {
+            return Integer.parseInt(mMap.get(key));
+        }
 
         /**
-         * Take photos at night.
+         * Sets the dimensions for preview pictures. If the preview has already
+         * started, applications should stop the preview first before changing
+         * preview size.
+         *
+         * The sides of width and height are based on camera orientation. That
+         * is, the preview size is the size before it is rotated by display
+         * orientation. So applications need to consider the display orientation
+         * while setting preview size. For example, suppose the camera supports
+         * both 480x320 and 320x480 preview sizes. The application wants a 3:2
+         * preview ratio. If the display orientation is set to 0 or 180, preview
+         * size should be set to 480x320. If the display orientation is set to
+         * 90 or 270, preview size should be set to 320x480. The display
+         * orientation should also be considered while setting picture size and
+         * thumbnail size.
+         *
+         * @param width  the width of the pictures, in pixels
+         * @param height the height of the pictures, in pixels
+         * @see #setDisplayOrientation(int)
+         * @see #getCameraInfo(int, CameraInfo)
+         * @see #setPictureSize(int, int)
+         * @see #setJpegThumbnailSize(int, int)
          */
-        public static final String SCENE_MODE_NIGHT = "night";
+        public void setPreviewSize(int width, int height) {
+            String v = Integer.toString(width) + "x" + Integer.toString(height);
+            set((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PREVIEW_SIZE, v);
+        }
 
         /**
-         * Take people pictures at night.
+         * Returns the dimensions setting for preview pictures.
+         *
+         * @return a Size object with the width and height setting
+         *          for the preview picture
          */
-        public static final String SCENE_MODE_NIGHT_PORTRAIT = "night-portrait";
+        public Size getPreviewSize() {
+            String pair = get((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PREVIEW_SIZE);
+            return strToSize(pair);
+        }
 
         /**
-         * Take photos in a theater. Flash light is off.
+         * Gets the supported preview sizes.
+         *
+         * @return a list of Size object. This method will always return a list
+         *         with at least one element.
          */
-        public static final String SCENE_MODE_THEATRE = "theatre";
+        public List<Size> getSupportedPreviewSizes() {
+            String str = get((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PREVIEW_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
 
         /**
-         * Take pictures on the beach.
+         * <p>Gets the supported video frame sizes that can be used by
+         * MediaRecorder.</p>
+         *
+         * <p>If the returned list is not null, the returned list will contain at
+         * least one Size and one of the sizes in the returned list must be
+         * passed to MediaRecorder.setVideoSize() for camcorder application if
+         * camera is used as the video source. In this case, the size of the
+         * preview can be different from the resolution of the recorded video
+         * during video recording.</p>
+         *
+         * @return a list of Size object if camera has separate preview and
+         *         video output; otherwise, null is returned.
+         * @see #getPreferredPreviewSizeForVideo()
          */
-        public static final String SCENE_MODE_BEACH = "beach";
+        public List<Size> getSupportedVideoSizes() {
+            String str = get(KEY_VIDEO_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
 
         /**
-         * Take pictures on the snow.
+         * Returns the preferred or recommended preview size (width and height)
+         * in pixels for video recording. Camcorder applications should
+         * set the preview size to a value that is not larger than the
+         * preferred preview size. In other words, the product of the width
+         * and height of the preview size should not be larger than that of
+         * the preferred preview size. In addition, we recommend to choose a
+         * preview size that has the same aspect ratio as the resolution of
+         * video to be recorded.
+         *
+         * @return the preferred preview size (width and height) in pixels for
+         *         video recording if getSupportedVideoSizes() does not return
+         *         null; otherwise, null is returned.
+         * @see #getSupportedVideoSizes()
          */
-        public static final String SCENE_MODE_SNOW = "snow";
-
+        public Size getPreferredPreviewSizeForVideo() {
+            String pair = get(KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO);
+            return strToSize(pair);
+        }
         /**
-         * Take sunset photos.
+         * @hide
+         * add for slow motion preview size
+         * @return the list size will tell camera ap to choose right preview size
          */
-        public static final String SCENE_MODE_SUNSET = "sunset";
-
+        public Size getPreferredPreviewSizeForSlowMotionVideo() {
+            String pair = get(KEY_HSVR_PRV_SIZE);
+            return strToSize(pair);
+        }
         /**
-         * Avoid blurry pictures (for example, due to hand shake).
+         * @hide
+         * add for slow motion preview size
+         * @return the list size will tell camera ap to choose right preview size
          */
-        public static final String SCENE_MODE_STEADYPHOTO = "steadyphoto";
+        public List<Size> getSupportedSlowMotionVideoSizes() {
+            String str = get(KEY_HSVR_PRV_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
 
         /**
-         * For shooting firework displays.
+         * <p>Sets the dimensions for EXIF thumbnail in Jpeg picture. If
+         * applications set both width and height to 0, EXIF will not contain
+         * thumbnail.</p>
+         *
+         * <p>Applications need to consider the display orientation. See {@link
+         * #setPreviewSize(int,int)} for reference.</p>
+         *
+         * @param width  the width of the thumbnail, in pixels
+         * @param height the height of the thumbnail, in pixels
+         * @see #setPreviewSize(int,int)
          */
-        public static final String SCENE_MODE_FIREWORKS = "fireworks";
+        public void setJpegThumbnailSize(int width, int height) {
+            set(KEY_JPEG_THUMBNAIL_WIDTH, width);
+            set(KEY_JPEG_THUMBNAIL_HEIGHT, height);
+        }
 
         /**
-         * Take photos of fast moving objects. Same as {@link
-         * #SCENE_MODE_ACTION}.
+         * Returns the dimensions for EXIF thumbnail in Jpeg picture.
+         *
+         * @return a Size object with the height and width setting for the EXIF
+         *         thumbnails
          */
-        public static final String SCENE_MODE_SPORTS = "sports";
+        public Size getJpegThumbnailSize() {
+            return new Size(getInt(KEY_JPEG_THUMBNAIL_WIDTH),
+                            getInt(KEY_JPEG_THUMBNAIL_HEIGHT));
+        }
 
         /**
-         * Take indoor low-light shot.
+         * Gets the supported jpeg thumbnail sizes.
+         *
+         * @return a list of Size object. This method will always return a list
+         *         with at least two elements. Size 0,0 (no thumbnail) is always
+         *         supported.
          */
-        public static final String SCENE_MODE_PARTY = "party";
+        public List<Size> getSupportedJpegThumbnailSizes() {
+            String str = get(KEY_JPEG_THUMBNAIL_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
 
         /**
-         * Capture the naturally warm color of scenes lit by candles.
+         * Sets the quality of the EXIF thumbnail in Jpeg picture.
+         *
+         * @param quality the JPEG quality of the EXIF thumbnail. The range is 1
+         *                to 100, with 100 being the best.
          */
-        public static final String SCENE_MODE_CANDLELIGHT = "candlelight";
-        /** @hide
-        * SCENE_MODE_BACKLIGHT
-        **/
-        public static final String SCENE_MODE_BACKLIGHT = "backlight";
-        /** @hide
-        * SCENE_MODE_FLOWERS
-        **/
-        public static final String SCENE_MODE_FLOWERS = "flowers";
+        public void setJpegThumbnailQuality(int quality) {
+            set(KEY_JPEG_THUMBNAIL_QUALITY, quality);
+        }
 
         /**
-         * Applications are looking for a barcode. Camera driver will be
-         * optimized for barcode reading.
+         * Returns the quality setting for the EXIF thumbnail in Jpeg picture.
+         *
+         * @return the JPEG quality setting of the EXIF thumbnail.
          */
-        public static final String SCENE_MODE_BARCODE = "barcode";
+        public int getJpegThumbnailQuality() {
+            return getInt(KEY_JPEG_THUMBNAIL_QUALITY);
+        }
 
         /**
-         * Capture a scene using high dynamic range imaging techniques. The
-         * camera will return an image that has an extended dynamic range
-         * compared to a regular capture. Capturing such an image may take
-         * longer than a regular capture.
+         * Sets Jpeg quality of captured picture.
+         *
+         * @param quality the JPEG quality of captured picture. The range is 1
+         *                to 100, with 100 being the best.
          */
-        public static final String SCENE_MODE_HDR = "hdr";
+        public void setJpegQuality(int quality) {
+            set(KEY_JPEG_QUALITY, quality);
+        }
 
         /**
-         * Auto-focus mode. Applications should call {@link
-         * #autoFocus(AutoFocusCallback)} to start the focus in this mode.
+         * Returns the quality setting for the JPEG picture.
+         *
+         * @return the JPEG picture quality setting.
          */
-        public static final String FOCUS_MODE_AUTO = "auto";
+        public int getJpegQuality() {
+            return getInt(KEY_JPEG_QUALITY);
+        }
 
         /**
-         * Focus is set at infinity. Applications should not call
-         * {@link #autoFocus(AutoFocusCallback)} in this mode.
+         * Sets the rate at which preview frames are received. This is the
+         * target frame rate. The actual frame rate depends on the driver.
+         *
+         * @param fps the frame rate (frames per second)
+         * @deprecated replaced by {@link #setPreviewFpsRange(int,int)}
          */
-        public static final String FOCUS_MODE_INFINITY = "infinity";
+        @Deprecated
+        public void setPreviewFrameRate(int fps) {
+            set(KEY_PREVIEW_FRAME_RATE, fps);
+        }
 
         /**
-         * Macro (close-up) focus mode. Applications should call
-         * {@link #autoFocus(AutoFocusCallback)} to start the focus in this
-         * mode.
+         * Returns the setting for the rate at which preview frames are
+         * received. This is the target frame rate. The actual frame rate
+         * depends on the driver.
+         *
+         * @return the frame rate setting (frames per second)
+         * @deprecated replaced by {@link #getPreviewFpsRange(int[])}
          */
-        public static final String FOCUS_MODE_MACRO = "macro";
+        @Deprecated
+        public int getPreviewFrameRate() {
+            return getInt(KEY_PREVIEW_FRAME_RATE);
+        }
 
         /**
-         * Focus is fixed. The camera is always in this mode if the focus is not
-         * adjustable. If the camera has auto-focus, this mode can fix the
-         * focus, which is usually at hyperfocal distance. Applications should
-         * not call {@link #autoFocus(AutoFocusCallback)} in this mode.
+         * Gets the supported preview frame rates.
+         *
+         * @return a list of supported preview frame rates. null if preview
+         *         frame rate setting is not supported.
+         * @deprecated replaced by {@link #getSupportedPreviewFpsRange()}
          */
-        public static final String FOCUS_MODE_FIXED = "fixed";
+        @Deprecated
+        public List<Integer> getSupportedPreviewFrameRates() {
+            String str = get(KEY_PREVIEW_FRAME_RATE + SUPPORTED_VALUES_SUFFIX);
+            return splitInt(str);
+        }
 
-        /** @hide
-         * Normal focus mode. Applications should call
-         * {@link #autoFocus(AutoFocusCallback)} to start the focus in this
-         * mode.
+        /**
+         * Sets the minimum and maximum preview fps. This controls the rate of
+         * preview frames received in {@link PreviewCallback}. The minimum and
+         * maximum preview fps must be one of the elements from {@link
+         * #getSupportedPreviewFpsRange}.
+         *
+         * @param min the minimum preview fps (scaled by 1000).
+         * @param max the maximum preview fps (scaled by 1000).
+         * @throws RuntimeException if fps range is invalid.
+         * @see #setPreviewCallbackWithBuffer(Camera.PreviewCallback)
+         * @see #getSupportedPreviewFpsRange()
          */
-        public static final String FOCUS_MODE_NORMAL = "normal";
+        public void setPreviewFpsRange(int min, int max) {
+            set(KEY_PREVIEW_FPS_RANGE, "" + min + "," + max);
+        }
 
         /**
-         * Extended depth of field (EDOF). Focusing is done digitally and
-         * continuously. Applications should not call {@link
-         * #autoFocus(AutoFocusCallback)} in this mode.
+         * Returns the current minimum and maximum preview fps. The values are
+         * one of the elements returned by {@link #getSupportedPreviewFpsRange}.
+         *
+         * @return range the minimum and maximum preview fps (scaled by 1000).
+         * @see #PREVIEW_FPS_MIN_INDEX
+         * @see #PREVIEW_FPS_MAX_INDEX
+         * @see #getSupportedPreviewFpsRange()
          */
-        public static final String FOCUS_MODE_EDOF = "edof";
+        public void getPreviewFpsRange(int[] range) {
+            if (range == null || range.length != 2) {
+                throw new IllegalArgumentException(
+                        "range must be an array with two elements.");
+            }
+            splitInt(get(KEY_PREVIEW_FPS_RANGE), range);
+        }
 
         /**
-         * Continuous auto focus mode intended for video recording. The camera
-         * continuously tries to focus. This is the best choice for video
-         * recording because the focus changes smoothly . Applications still can
-         * call {@link #takePicture(Camera.ShutterCallback,
-         * Camera.PictureCallback, Camera.PictureCallback)} in this mode but the
-         * subject may not be in focus. Auto focus starts when the parameter is
-         * set.
-         *
-         * <p>Since API level 14, applications can call {@link
-         * #autoFocus(AutoFocusCallback)} in this mode. The focus callback will
-         * immediately return with a boolean that indicates whether the focus is
-         * sharp or not. The focus position is locked after autoFocus call. If
-         * applications want to resume the continuous focus, cancelAutoFocus
-         * must be called. Restarting the preview will not resume the continuous
-         * autofocus. To stop continuous focus, applications should change the
-         * focus mode to other modes.
+         * Gets the supported preview fps (frame-per-second) ranges. Each range
+         * contains a minimum fps and maximum fps. If minimum fps equals to
+         * maximum fps, the camera outputs frames in fixed frame rate. If not,
+         * the camera outputs frames in auto frame rate. The actual frame rate
+         * fluctuates between the minimum and the maximum. The values are
+         * multiplied by 1000 and represented in integers. For example, if frame
+         * rate is 26.623 frames per second, the value is 26623.
          *
-         * @see #FOCUS_MODE_CONTINUOUS_PICTURE
+         * @return a list of supported preview fps ranges. This method returns a
+         *         list with at least one element. Every element is an int array
+         *         of two values - minimum fps and maximum fps. The list is
+         *         sorted from small to large (first by maximum fps and then
+         *         minimum fps).
+         * @see #PREVIEW_FPS_MIN_INDEX
+         * @see #PREVIEW_FPS_MAX_INDEX
          */
-        public static final String FOCUS_MODE_CONTINUOUS_VIDEO = "continuous-video";
+        public List<int[]> getSupportedPreviewFpsRange() {
+            String str = get(KEY_PREVIEW_FPS_RANGE + SUPPORTED_VALUES_SUFFIX);
+            return splitRange(str);
+        }
 
         /**
-         * Continuous auto focus mode intended for taking pictures. The camera
-         * continuously tries to focus. The speed of focus change is more
-         * aggressive than {@link #FOCUS_MODE_CONTINUOUS_VIDEO}. Auto focus
-         * starts when the parameter is set.
+         * Sets the image format for preview pictures.
+         * <p>If this is never called, the default format will be
+         * {@link android.graphics.ImageFormat#NV21}, which
+         * uses the NV21 encoding format.</p>
          *
-         * <p>Applications can call {@link #autoFocus(AutoFocusCallback)} in
-         * this mode. If the autofocus is in the middle of scanning, the focus
-         * callback will return when it completes. If the autofocus is not
-         * scanning, the focus callback will immediately return with a boolean
-         * that indicates whether the focus is sharp or not. The apps can then
-         * decide if they want to take a picture immediately or to change the
-         * focus mode to auto, and run a full autofocus cycle. The focus
-         * position is locked after autoFocus call. If applications want to
-         * resume the continuous focus, cancelAutoFocus must be called.
-         * Restarting the preview will not resume the continuous autofocus. To
-         * stop continuous focus, applications should change the focus mode to
-         * other modes.
+         * <p>Use {@link Parameters#getSupportedPreviewFormats} to get a list of
+         * the available preview formats.
          *
-         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
+         * <p>It is strongly recommended that either
+         * {@link android.graphics.ImageFormat#NV21} or
+         * {@link android.graphics.ImageFormat#YV12} is used, since
+         * they are supported by all camera devices.</p>
+         *
+         * <p>For YV12, the image buffer that is received is not necessarily
+         * tightly packed, as there may be padding at the end of each row of
+         * pixel data, as described in
+         * {@link android.graphics.ImageFormat#YV12}. For camera callback data,
+         * it can be assumed that the stride of the Y and UV data is the
+         * smallest possible that meets the alignment requirements. That is, if
+         * the preview size is <var>width x height</var>, then the following
+         * equations describe the buffer index for the beginning of row
+         * <var>y</var> for the Y plane and row <var>c</var> for the U and V
+         * planes:
+         *
+         * {@code
+         * <pre>
+         * yStride   = (int) ceil(width / 16.0) * 16;
+         * uvStride  = (int) ceil( (yStride / 2) / 16.0) * 16;
+         * ySize     = yStride * height;
+         * uvSize    = uvStride * height / 2;
+         * yRowIndex = yStride * y;
+         * uRowIndex = ySize + uvSize + uvStride * c;
+         * vRowIndex = ySize + uvStride * c;
+         * size      = ySize + uvSize * 2;</pre>
+         * }
+         *
+         * @param pixel_format the desired preview picture format, defined by
+         *   one of the {@link android.graphics.ImageFormat} constants.  (E.g.,
+         *   <var>ImageFormat.NV21</var> (default), or
+         *   <var>ImageFormat.YV12</var>)
+         *
+         * @see android.graphics.ImageFormat
+         * @see android.hardware.Camera.Parameters#getSupportedPreviewFormats
          */
-        public static final String FOCUS_MODE_CONTINUOUS_PICTURE = "continuous-picture";
+        public void setPreviewFormat(int pixel_format) {
+            String s = cameraFormatForPixelFormat(pixel_format);
+            if (s == null) {
+                throw new IllegalArgumentException(
+                        "Invalid pixel_format=" + pixel_format);
+            }
 
-        /** @hide
-         *  manual focus mode
+            set(KEY_PREVIEW_FORMAT, s);
+        }
+
+        /**
+         * Returns the image format for preview frames got from
+         * {@link PreviewCallback}.
+         *
+         * @return the preview format.
+         * @see android.graphics.ImageFormat
+         * @see #setPreviewFormat
          */
-        public static final String FOCUS_MODE_MANUAL_POSITION = "manual";
+        public int getPreviewFormat() {
+            return pixelFormatForCameraFormat(get(KEY_PREVIEW_FORMAT));
+        }
 
-        // Indices for focus distance array.
         /**
-         * The array index of near focus distance for use with
-         * {@link #getFocusDistances(float[])}.
+         * Gets the supported preview formats. {@link android.graphics.ImageFormat#NV21}
+         * is always supported. {@link android.graphics.ImageFormat#YV12}
+         * is always supported since API level 12.
+         *
+         * @return a list of supported preview formats. This method will always
+         *         return a list with at least one element.
+         * @see android.graphics.ImageFormat
+         * @see #setPreviewFormat
          */
-        public static final int FOCUS_DISTANCE_NEAR_INDEX = 0;
+        public List<Integer> getSupportedPreviewFormats() {
+            String str = get(KEY_PREVIEW_FORMAT + SUPPORTED_VALUES_SUFFIX);
+            ArrayList<Integer> formats = new ArrayList<Integer>();
+            for (String s : split(str)) {
+                int f = pixelFormatForCameraFormat(s);
+                if (f == ImageFormat.UNKNOWN) continue;
+                formats.add(f);
+            }
+            return formats;
+        }
 
         /**
-         * The array index of optimal focus distance for use with
-         * {@link #getFocusDistances(float[])}.
+         * <p>Sets the dimensions for pictures.</p>
+         *
+         * <p>Applications need to consider the display orientation. See {@link
+         * #setPreviewSize(int,int)} for reference.</p>
+         *
+         * @param width  the width for pictures, in pixels
+         * @param height the height for pictures, in pixels
+         * @see #setPreviewSize(int,int)
+         *
          */
-        public static final int FOCUS_DISTANCE_OPTIMAL_INDEX = 1;
+        public void setPictureSize(int width, int height) {
+            String v = Integer.toString(width) + "x" + Integer.toString(height);
+            set((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PICTURE_SIZE, v);
+        }
 
         /**
-         * The array index of far focus distance for use with
-         * {@link #getFocusDistances(float[])}.
+         * Returns the dimension setting for pictures.
+         *
+         * @return a Size object with the height and width setting
+         *          for pictures
          */
-        public static final int FOCUS_DISTANCE_FAR_INDEX = 2;
+        public Size getPictureSize() {
+            String pair = get((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PICTURE_SIZE);
+            return strToSize(pair);
+        }
 
         /**
-         * The array index of minimum preview fps for use with {@link
-         * #getPreviewFpsRange(int[])} or {@link
-         * #getSupportedPreviewFpsRange()}.
+         * Gets the supported picture sizes.
+         *
+         * @return a list of supported picture sizes. This method will always
+         *         return a list with at least one element.
          */
-        public static final int PREVIEW_FPS_MIN_INDEX = 0;
+        public List<Size> getSupportedPictureSizes() {
+            String str = get((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
 
         /**
-         * The array index of maximum preview fps for use with {@link
-         * #getPreviewFpsRange(int[])} or {@link
-         * #getSupportedPreviewFpsRange()}.
+         * Sets the image format for pictures.
+         *
+         * @param pixel_format the desired picture format
+         *                     (<var>ImageFormat.NV21</var>,
+         *                      <var>ImageFormat.RGB_565</var>, or
+         *                      <var>ImageFormat.JPEG</var>)
+         * @see android.graphics.ImageFormat
          */
-        public static final int PREVIEW_FPS_MAX_INDEX = 1;
+        public void setPictureFormat(int pixel_format) {
+            String s = cameraFormatForPixelFormat(pixel_format);
+            if (s == null) {
+                throw new IllegalArgumentException(
+                        "Invalid pixel_format=" + pixel_format);
+            }
 
-        // Formats for setPreviewFormat and setPictureFormat.
-        private static final String PIXEL_FORMAT_YUV422SP = "yuv422sp";
-        private static final String PIXEL_FORMAT_YUV420SP = "yuv420sp";
-        private static final String PIXEL_FORMAT_YUV420SP_ADRENO = "yuv420sp-adreno";
-        private static final String PIXEL_FORMAT_YUV422I = "yuv422i-yuyv";
-        private static final String PIXEL_FORMAT_YUV420P = "yuv420p";
-        private static final String PIXEL_FORMAT_RGB565 = "rgb565";
-        private static final String PIXEL_FORMAT_JPEG = "jpeg";
-        private static final String PIXEL_FORMAT_BAYER_RGGB = "bayer-rggb";
-        private static final String PIXEL_FORMAT_RAW = "raw";
-        private static final String PIXEL_FORMAT_YV12 = "yv12";
-        private static final String PIXEL_FORMAT_NV12 = "nv12";
+            set(KEY_PICTURE_FORMAT, s);
+        }
 
         /**
-         * Order matters: Keys that are {@link #set(String, String) set} later
-         * will take precedence over keys that are set earlier (if the two keys
-         * conflict with each other).
+         * Returns the image format for pictures.
          *
-         * <p>One example is {@link #setPreviewFpsRange(int, int)} , since it
-         * conflicts with {@link #setPreviewFrameRate(int)} whichever key is set later
-         * is the one that will take precedence.
-         * </p>
+         * @return the picture format
+         * @see android.graphics.ImageFormat
          */
-        private final LinkedHashMap<String, String> mMap;
-
-        private Parameters() {
-            mMap = new LinkedHashMap<String, String>(/*initialCapacity*/64);
+        public int getPictureFormat() {
+            return pixelFormatForCameraFormat(get(KEY_PICTURE_FORMAT));
         }
 
         /**
-         * Overwrite existing parameters with a copy of the ones from {@code other}.
-         *
-         * <b>For use by the legacy shim only.</b>
+         * Gets the supported picture formats.
          *
-         * @hide
+         * @return supported picture formats. This method will always return a
+         *         list with at least one element.
+         * @see android.graphics.ImageFormat
          */
-        public void copyFrom(Parameters other) {
-            if (other == null) {
-                throw new NullPointerException("other must not be null");
+        public List<Integer> getSupportedPictureFormats() {
+            String str = get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX);
+            ArrayList<Integer> formats = new ArrayList<Integer>();
+            for (String s : split(str)) {
+                int f = pixelFormatForCameraFormat(s);
+                if (f == ImageFormat.UNKNOWN) continue;
+                formats.add(f);
             }
-
-            mMap.putAll(other.mMap);
+            return formats;
         }
 
-        private Camera getOuter() {
-            return Camera.this;
+        private String cameraFormatForPixelFormat(int pixel_format) {
+            switch(pixel_format) {
+            case ImageFormat.NV16:      return PIXEL_FORMAT_YUV422SP;
+            case ImageFormat.NV21:      return PIXEL_FORMAT_YUV420SP;
+            case ImageFormat.YUY2:      return PIXEL_FORMAT_YUV422I;
+            case ImageFormat.YV12:      return PIXEL_FORMAT_YUV420P;
+            case ImageFormat.RGB_565:   return PIXEL_FORMAT_RGB565;
+            case ImageFormat.JPEG:      return PIXEL_FORMAT_JPEG;
+            default:                    return null;
+            }
         }
 
+        private int pixelFormatForCameraFormat(String format) {
+            if (format == null)
+                return ImageFormat.UNKNOWN;
 
-        /**
-         * Value equality check.
-         *
-         * @hide
-         */
-        public boolean same(Parameters other) {
-            if (this == other) {
-                return true;
-            }
-            return other != null && Parameters.this.mMap.equals(other.mMap);
+            if (format.equals(PIXEL_FORMAT_YUV422SP))
+                return ImageFormat.NV16;
+
+            if (format.equals(PIXEL_FORMAT_YUV420SP))
+                return ImageFormat.NV21;
+
+            if (format.equals(PIXEL_FORMAT_YUV422I))
+                return ImageFormat.YUY2;
+
+            if (format.equals(PIXEL_FORMAT_YUV420P))
+                return ImageFormat.YV12;
+
+            if (format.equals(PIXEL_FORMAT_RGB565))
+                return ImageFormat.RGB_565;
+
+            if (format.equals(PIXEL_FORMAT_JPEG))
+                return ImageFormat.JPEG;
+
+            return ImageFormat.UNKNOWN;
         }
 
         /**
-         * Writes the current Parameters to the log.
-         * @hide
-         * @deprecated
+         * Sets the clockwise rotation angle in degrees relative to the
+         * orientation of the camera. This affects the pictures returned from
+         * JPEG {@link PictureCallback}. The camera driver may set orientation
+         * in the EXIF header without rotating the picture. Or the driver may
+         * rotate the picture and the EXIF thumbnail. If the Jpeg picture is
+         * rotated, the orientation in the EXIF header will be missing or 1 (row
+         * #0 is top and column #0 is left side).
+         *
+         * <p>
+         * If applications want to rotate the picture to match the orientation
+         * of what users see, apps should use
+         * {@link android.view.OrientationEventListener} and
+         * {@link android.hardware.Camera.CameraInfo}. The value from
+         * OrientationEventListener is relative to the natural orientation of
+         * the device. CameraInfo.orientation is the angle between camera
+         * orientation and natural device orientation. The sum of the two is the
+         * rotation angle for back-facing camera. The difference of the two is
+         * the rotation angle for front-facing camera. Note that the JPEG
+         * pictures of front-facing cameras are not mirrored as in preview
+         * display.
+         *
+         * <p>
+         * For example, suppose the natural orientation of the device is
+         * portrait. The device is rotated 270 degrees clockwise, so the device
+         * orientation is 270. Suppose a back-facing camera sensor is mounted in
+         * landscape and the top side of the camera sensor is aligned with the
+         * right edge of the display in natural orientation. So the camera
+         * orientation is 90. The rotation should be set to 0 (270 + 90).
+         *
+         * <p>The reference code is as follows.
+         *
+         * <pre>
+         * public void onOrientationChanged(int orientation) {
+         *     if (orientation == ORIENTATION_UNKNOWN) return;
+         *     android.hardware.Camera.CameraInfo info =
+         *            new android.hardware.Camera.CameraInfo();
+         *     android.hardware.Camera.getCameraInfo(cameraId, info);
+         *     orientation = (orientation + 45) / 90 * 90;
+         *     int rotation = 0;
+         *     if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
+         *         rotation = (info.orientation - orientation + 360) % 360;
+         *     } else {  // back-facing camera
+         *         rotation = (info.orientation + orientation) % 360;
+         *     }
+         *     mParameters.setRotation(rotation);
+         * }
+         * </pre>
+         *
+         * @param rotation The rotation angle in degrees relative to the
+         *                 orientation of the camera. Rotation can only be 0,
+         *                 90, 180 or 270.
+         * @throws IllegalArgumentException if rotation value is invalid.
+         * @see android.view.OrientationEventListener
+         * @see #getCameraInfo(int, CameraInfo)
          */
-        @Deprecated
-        public void dump() {
-            Log.e(TAG, "dump: size=" + mMap.size());
-            for (String k : mMap.keySet()) {
-                Log.e(TAG, "dump: " + k + "=" + mMap.get(k));
+        public void setRotation(int rotation) {
+            if (rotation == 0 || rotation == 90 || rotation == 180
+                    || rotation == 270) {
+                set(KEY_ROTATION, Integer.toString(rotation));
+            } else {
+                throw new IllegalArgumentException(
+                        "Invalid rotation=" + rotation);
             }
         }
 
         /**
-         * Creates a single string with all the parameters set in
-         * this Parameters object.
-         * <p>The {@link #unflatten(String)} method does the reverse.</p>
+         * Sets GPS latitude coordinate. This will be stored in JPEG EXIF
+         * header.
          *
-         * @return a String with all values from this Parameters object, in
-         *         semi-colon delimited key-value pairs
+         * @param latitude GPS latitude coordinate.
          */
-        public String flatten() {
-            StringBuilder flattened = new StringBuilder(128);
-            for (String k : mMap.keySet()) {
-                flattened.append(k);
-                flattened.append("=");
-                flattened.append(mMap.get(k));
-                flattened.append(";");
-            }
-            // chop off the extra semicolon at the end
-            flattened.deleteCharAt(flattened.length()-1);
-            return flattened.toString();
+        public void setGpsLatitude(double latitude) {
+            set(KEY_GPS_LATITUDE, Double.toString(latitude));
         }
 
         /**
-         * Takes a flattened string of parameters and adds each one to
-         * this Parameters object.
-         * <p>The {@link #flatten()} method does the reverse.</p>
+         * Sets GPS longitude coordinate. This will be stored in JPEG EXIF
+         * header.
          *
-         * @param flattened a String of parameters (key-value paired) that
-         *                  are semi-colon delimited
+         * @param longitude GPS longitude coordinate.
          */
-        public void unflatten(String flattened) {
-            mMap.clear();
-
-            TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(';');
-            splitter.setString(flattened);
-            for (String kv : splitter) {
-                int pos = kv.indexOf('=');
-                if (pos == -1) {
-                    continue;
-                }
-                String k = kv.substring(0, pos);
-                String v = kv.substring(pos + 1);
-                mMap.put(k, v);
-            }
+        public void setGpsLongitude(double longitude) {
+            set(KEY_GPS_LONGITUDE, Double.toString(longitude));
         }
 
-        public void remove(String key) {
-            mMap.remove(key);
+        /**
+         * Sets GPS altitude. This will be stored in JPEG EXIF header.
+         *
+         * @param altitude GPS altitude in meters.
+         */
+        public void setGpsAltitude(double altitude) {
+            set(KEY_GPS_ALTITUDE, Double.toString(altitude));
         }
 
         /**
-         * Sets a String parameter.
+         * Sets GPS timestamp. This will be stored in JPEG EXIF header.
          *
-         * @param key   the key name for the parameter
-         * @param value the String value of the parameter
+         * @param timestamp GPS timestamp (UTC in seconds since January 1,
+         *                  1970).
          */
-        public void set(String key, String value) {
-            if (key.indexOf('=') != -1 || key.indexOf(';') != -1 || key.indexOf(0) != -1) {
-                Log.e(TAG, "Key \"" + key + "\" contains invalid character (= or ; or \\0)");
-                return;
-            }
-            if (value.indexOf('=') != -1 || value.indexOf(';') != -1 || value.indexOf(0) != -1) {
-                Log.e(TAG, "Value \"" + value + "\" contains invalid character (= or ; or \\0)");
-                return;
-            }
-
-            put(key, value);
+        public void setGpsTimestamp(long timestamp) {
+            set(KEY_GPS_TIMESTAMP, Long.toString(timestamp));
         }
 
         /**
-         * Sets an integer parameter.
+         * Sets GPS processing method. The method will be stored in a UTF-8 string up to 31 bytes
+         * long, in the JPEG EXIF header.
          *
-         * @param key   the key name for the parameter
-         * @param value the int value of the parameter
+         * @param processing_method The processing method to get this location.
          */
-        public void set(String key, int value) {
-            put(key, Integer.toString(value));
+        public void setGpsProcessingMethod(String processing_method) {
+            set(KEY_GPS_PROCESSING_METHOD, processing_method);
         }
 
-        private void put(String key, String value) {
-            /*
-             * Remove the key if it already exists.
-             *
-             * This way setting a new value for an already existing key will always move
-             * that key to be ordered the latest in the map.
-             */
-            mMap.remove(key);
-            mMap.put(key, value);
+        /**
+         * Removes GPS latitude, longitude, altitude, and timestamp from the
+         * parameters.
+         */
+        public void removeGpsData() {
+            remove(KEY_QC_GPS_LATITUDE_REF);
+            remove(KEY_GPS_LATITUDE);
+            remove(KEY_QC_GPS_LONGITUDE_REF);
+            remove(KEY_GPS_LONGITUDE);
+            remove(KEY_QC_GPS_ALTITUDE_REF);
+            remove(KEY_GPS_ALTITUDE);
+            remove(KEY_GPS_TIMESTAMP);
+            remove(KEY_GPS_PROCESSING_METHOD);
         }
 
-        private void set(String key, List<Area> areas) {
-            if (areas == null) {
-                set(key, "(0,0,0,0,0)");
-            } else {
-                StringBuilder buffer = new StringBuilder();
-                for (int i = 0; i < areas.size(); i++) {
-                    Area area = areas.get(i);
-                    Rect rect = area.rect;
-                    buffer.append('(');
-                    buffer.append(rect.left);
-                    buffer.append(',');
-                    buffer.append(rect.top);
-                    buffer.append(',');
-                    buffer.append(rect.right);
-                    buffer.append(',');
-                    buffer.append(rect.bottom);
-                    buffer.append(',');
-                    buffer.append(area.weight);
-                    buffer.append(')');
-                    if (i != areas.size() - 1) buffer.append(',');
-                }
-                set(key, buffer.toString());
-            }
+        /**
+         * Gets the current white balance setting.
+         *
+         * @return current white balance. null if white balance setting is not
+         *         supported.
+         * @see #WHITE_BALANCE_AUTO
+         * @see #WHITE_BALANCE_INCANDESCENT
+         * @see #WHITE_BALANCE_FLUORESCENT
+         * @see #WHITE_BALANCE_WARM_FLUORESCENT
+         * @see #WHITE_BALANCE_DAYLIGHT
+         * @see #WHITE_BALANCE_CLOUDY_DAYLIGHT
+         * @see #WHITE_BALANCE_TWILIGHT
+         * @see #WHITE_BALANCE_SHADE
+         *
+         */
+        public String getWhiteBalance() {
+            return get(KEY_WHITE_BALANCE);
         }
 
         /**
-         * Returns the value of a String parameter.
+         * Sets the white balance. Changing the setting will release the
+         * auto-white balance lock. It is recommended not to change white
+         * balance and AWB lock at the same time.
          *
-         * @param key the key name for the parameter
-         * @return the String value of the parameter
+         * @param value new white balance.
+         * @see #getWhiteBalance()
+         * @see #setAutoWhiteBalanceLock(boolean)
          */
-        public String get(String key) {
-            return mMap.get(key);
+        public void setWhiteBalance(String value) {
+            String oldValue = get(KEY_WHITE_BALANCE);
+            if (same(value, oldValue)) return;
+            set(KEY_WHITE_BALANCE, value);
+            set(KEY_AUTO_WHITEBALANCE_LOCK, FALSE);
         }
 
         /**
-         * Returns the value of an integer parameter.
+         * Gets the supported white balance.
          *
-         * @param key the key name for the parameter
-         * @return the int value of the parameter
+         * @return a list of supported white balance. null if white balance
+         *         setting is not supported.
+         * @see #getWhiteBalance()
          */
-        public int getInt(String key) {
-            return Integer.parseInt(mMap.get(key));
+        public List<String> getSupportedWhiteBalance() {
+            String str = get(KEY_WHITE_BALANCE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
         /**
-         * Sets the dimensions for preview pictures. If the preview has already
-         * started, applications should stop the preview first before changing
-         * preview size.
-         *
-         * The sides of width and height are based on camera orientation. That
-         * is, the preview size is the size before it is rotated by display
-         * orientation. So applications need to consider the display orientation
-         * while setting preview size. For example, suppose the camera supports
-         * both 480x320 and 320x480 preview sizes. The application wants a 3:2
-         * preview ratio. If the display orientation is set to 0 or 180, preview
-         * size should be set to 480x320. If the display orientation is set to
-         * 90 or 270, preview size should be set to 320x480. The display
-         * orientation should also be considered while setting picture size and
-         * thumbnail size.
+         * Gets the current color effect setting.
          *
-         * @param width  the width of the pictures, in pixels
-         * @param height the height of the pictures, in pixels
-         * @see #setDisplayOrientation(int)
-         * @see #getCameraInfo(int, CameraInfo)
-         * @see #setPictureSize(int, int)
-         * @see #setJpegThumbnailSize(int, int)
+         * @return current color effect. null if color effect
+         *         setting is not supported.
+         * @see #EFFECT_NONE
+         * @see #EFFECT_MONO
+         * @see #EFFECT_NEGATIVE
+         * @see #EFFECT_SOLARIZE
+         * @see #EFFECT_SEPIA
+         * @see #EFFECT_POSTERIZE
+         * @see #EFFECT_WHITEBOARD
+         * @see #EFFECT_BLACKBOARD
+         * @see #EFFECT_AQUA
          */
-        public void setPreviewSize(int width, int height) {
-            String v = Integer.toString(width) + "x" + Integer.toString(height);
-            set(KEY_PREVIEW_SIZE, v);
+        public String getColorEffect() {
+            return get(KEY_EFFECT);
         }
 
         /**
-         * Returns the dimensions setting for preview pictures.
+         * Sets the current color effect setting.
          *
-         * @return a Size object with the width and height setting
-         *          for the preview picture
+         * @param value new color effect.
+         * @see #getColorEffect()
          */
-        public Size getPreviewSize() {
-            String pair = get(KEY_PREVIEW_SIZE);
-            return strToSize(pair);
+        public void setColorEffect(String value) {
+            set(KEY_EFFECT, value);
         }
 
         /**
-         * Gets the supported preview sizes.
+         * Gets the supported color effects.
          *
-         * @return a list of Size object. This method will always return a list
-         *         with at least one element.
+         * @return a list of supported color effects. null if color effect
+         *         setting is not supported.
+         * @see #getColorEffect()
          */
-        public List<Size> getSupportedPreviewSizes() {
-            String str = get(KEY_PREVIEW_SIZE + SUPPORTED_VALUES_SUFFIX);
-            return splitSize(str);
+        public List<String> getSupportedColorEffects() {
+            String str = get(KEY_EFFECT + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
+
         /**
-         * <p>Gets the supported video frame sizes that can be used by
-         * MediaRecorder.</p>
-         *
-         * <p>If the returned list is not null, the returned list will contain at
-         * least one Size and one of the sizes in the returned list must be
-         * passed to MediaRecorder.setVideoSize() for camcorder application if
-         * camera is used as the video source. In this case, the size of the
-         * preview can be different from the resolution of the recorded video
-         * during video recording.</p>
+         * Gets the current antibanding setting.
          *
-         * @return a list of Size object if camera has separate preview and
-         *         video output; otherwise, null is returned.
-         * @see #getPreferredPreviewSizeForVideo()
+         * @return current antibanding. null if antibanding setting is not
+         *         supported.
+         * @see #ANTIBANDING_AUTO
+         * @see #ANTIBANDING_50HZ
+         * @see #ANTIBANDING_60HZ
+         * @see #ANTIBANDING_OFF
          */
-        public List<Size> getSupportedVideoSizes() {
-            String str = get(KEY_VIDEO_SIZE + SUPPORTED_VALUES_SUFFIX);
-            return splitSize(str);
+        public String getAntibanding() {
+            return get(KEY_ANTIBANDING);
         }
 
         /**
-         * Returns the preferred or recommended preview size (width and height)
-         * in pixels for video recording. Camcorder applications should
-         * set the preview size to a value that is not larger than the
-         * preferred preview size. In other words, the product of the width
-         * and height of the preview size should not be larger than that of
-         * the preferred preview size. In addition, we recommend to choose a
-         * preview size that has the same aspect ratio as the resolution of
-         * video to be recorded.
+         * Sets the antibanding.
          *
-         * @return the preferred preview size (width and height) in pixels for
-         *         video recording if getSupportedVideoSizes() does not return
-         *         null; otherwise, null is returned.
-         * @see #getSupportedVideoSizes()
+         * @param antibanding new antibanding value.
+         * @see #getAntibanding()
          */
-        public Size getPreferredPreviewSizeForVideo() {
-            String pair = get(KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO);
-            return strToSize(pair);
+        public void setAntibanding(String antibanding) {
+            set(KEY_ANTIBANDING, antibanding);
         }
 
         /**
-         * <p>Sets the dimensions for EXIF thumbnail in Jpeg picture. If
-         * applications set both width and height to 0, EXIF will not contain
-         * thumbnail.</p>
-         *
-         * <p>Applications need to consider the display orientation. See {@link
-         * #setPreviewSize(int,int)} for reference.</p>
+         * Gets the supported antibanding values.
          *
-         * @param width  the width of the thumbnail, in pixels
-         * @param height the height of the thumbnail, in pixels
-         * @see #setPreviewSize(int,int)
+         * @return a list of supported antibanding values. null if antibanding
+         *         setting is not supported.
+         * @see #getAntibanding()
          */
-        public void setJpegThumbnailSize(int width, int height) {
-            set(KEY_JPEG_THUMBNAIL_WIDTH, width);
-            set(KEY_JPEG_THUMBNAIL_HEIGHT, height);
+        public List<String> getSupportedAntibanding() {
+            String str = get(KEY_ANTIBANDING + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+    //!++
+    /**
+    * @hide
+    * Gets the current Eis mode setting (on/off)
+    * @ return one of EIS_MODE_xxx string constant.
+    * @see #EIS_MODE_ON
+    * @see #EIS_MODE_OFF
+    */
+        public String getEisMode() {
+            return get(KEY_EIS_MODE);
+        }
+    /**
+    * @hide
+    */
+        public void setEisMode(String eis) {
+            set(KEY_EIS_MODE, eis);
+        }
+    /**
+    * @hide
+    */
+        public List<String> getSupportedEisMode() {
+            String str = get(KEY_EIS_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+    /**
+    * @hide
+    * IF environment light is not strong enough, camera will turn on flash while focusing
+    */
+        public String getAFLampMode() {
+            return get(KEY_AFLAMP_MODE);
+        }
+    /**
+    * @hide
+    */
+        public void setAFLampMode(String aflamp) {
+            set(KEY_AFLAMP_MODE, aflamp);
+        }
+    /**
+    * @hide
+    */
+        public List<String> getSupportedAFLampMode() {
+            String str = get(KEY_AFLAMP_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
+    //!--
 
         /**
-         * Returns the dimensions for EXIF thumbnail in Jpeg picture.
+         * Gets the current scene mode setting.
          *
-         * @return a Size object with the height and width setting for the EXIF
-         *         thumbnails
+         * @return one of SCENE_MODE_XXX string constant. null if scene mode
+         *         setting is not supported.
+         * @see #SCENE_MODE_AUTO
+         * @see #SCENE_MODE_ACTION
+         * @see #SCENE_MODE_PORTRAIT
+         * @see #SCENE_MODE_LANDSCAPE
+         * @see #SCENE_MODE_NIGHT
+         * @see #SCENE_MODE_NIGHT_PORTRAIT
+         * @see #SCENE_MODE_THEATRE
+         * @see #SCENE_MODE_BEACH
+         * @see #SCENE_MODE_SNOW
+         * @see #SCENE_MODE_SUNSET
+         * @see #SCENE_MODE_STEADYPHOTO
+         * @see #SCENE_MODE_FIREWORKS
+         * @see #SCENE_MODE_SPORTS
+         * @see #SCENE_MODE_PARTY
+         * @see #SCENE_MODE_CANDLELIGHT
+         * @see #SCENE_MODE_BARCODE
          */
-        public Size getJpegThumbnailSize() {
-            return new Size(getInt(KEY_JPEG_THUMBNAIL_WIDTH),
-                            getInt(KEY_JPEG_THUMBNAIL_HEIGHT));
+        public String getSceneMode() {
+            return get(KEY_SCENE_MODE);
         }
 
         /**
-         * Gets the supported jpeg thumbnail sizes.
+         * Sets the scene mode. Changing scene mode may override other
+         * parameters (such as flash mode, focus mode, white balance). For
+         * example, suppose originally flash mode is on and supported flash
+         * modes are on/off. In night scene mode, both flash mode and supported
+         * flash mode may be changed to off. After setting scene mode,
+         * applications should call getParameters to know if some parameters are
+         * changed.
          *
-         * @return a list of Size object. This method will always return a list
-         *         with at least two elements. Size 0,0 (no thumbnail) is always
-         *         supported.
+         * @param value scene mode.
+         * @see #getSceneMode()
          */
-        public List<Size> getSupportedJpegThumbnailSizes() {
-            String str = get(KEY_JPEG_THUMBNAIL_SIZE + SUPPORTED_VALUES_SUFFIX);
-            return splitSize(str);
+        public void setSceneMode(String value) {
+            set(KEY_SCENE_MODE, value);
         }
 
         /**
-         * Sets the quality of the EXIF thumbnail in Jpeg picture.
+         * Gets the supported scene modes.
          *
-         * @param quality the JPEG quality of the EXIF thumbnail. The range is 1
-         *                to 100, with 100 being the best.
+         * @return a list of supported scene modes. null if scene mode setting
+         *         is not supported.
+         * @see #getSceneMode()
          */
-        public void setJpegThumbnailQuality(int quality) {
-            set(KEY_JPEG_THUMBNAIL_QUALITY, quality);
+        public List<String> getSupportedSceneModes() {
+            String str = get(KEY_SCENE_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
         /**
-         * Returns the quality setting for the EXIF thumbnail in Jpeg picture.
+         * Gets the current flash mode setting.
          *
-         * @return the JPEG quality setting of the EXIF thumbnail.
+         * @return current flash mode. null if flash mode setting is not
+         *         supported.
+         * @see #FLASH_MODE_OFF
+         * @see #FLASH_MODE_AUTO
+         * @see #FLASH_MODE_ON
+         * @see #FLASH_MODE_RED_EYE
+         * @see #FLASH_MODE_TORCH
          */
-        public int getJpegThumbnailQuality() {
-            return getInt(KEY_JPEG_THUMBNAIL_QUALITY);
+        public String getFlashMode() {
+            return get(KEY_FLASH_MODE);
         }
 
         /**
-         * Sets Jpeg quality of captured picture.
+         * Sets the flash mode.
          *
-         * @param quality the JPEG quality of captured picture. The range is 1
-         *                to 100, with 100 being the best.
+         * @param value flash mode.
+         * @see #getFlashMode()
          */
-        public void setJpegQuality(int quality) {
-            set(KEY_JPEG_QUALITY, quality);
+        public void setFlashMode(String value) {
+            set(KEY_FLASH_MODE, value);
         }
 
         /**
-         * Returns the quality setting for the JPEG picture.
+         * Gets the supported flash modes.
          *
-         * @return the JPEG picture quality setting.
+         * @return a list of supported flash modes. null if flash mode setting
+         *         is not supported.
+         * @see #getFlashMode()
          */
-        public int getJpegQuality() {
-            return getInt(KEY_JPEG_QUALITY);
+        public List<String> getSupportedFlashModes() {
+            String str = get(KEY_FLASH_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
         /**
-         * Sets the rate at which preview frames are received. This is the
-         * target frame rate. The actual frame rate depends on the driver.
+         * Gets the current focus mode setting.
          *
-         * @param fps the frame rate (frames per second)
-         * @deprecated replaced by {@link #setPreviewFpsRange(int,int)}
+         * @return current focus mode. This method will always return a non-null
+         *         value. Applications should call {@link
+         *         #autoFocus(AutoFocusCallback)} to start the focus if focus
+         *         mode is FOCUS_MODE_AUTO or FOCUS_MODE_MACRO.
+         * @see #FOCUS_MODE_AUTO
+         * @see #FOCUS_MODE_INFINITY
+         * @see #FOCUS_MODE_MACRO
+         * @see #FOCUS_MODE_FIXED
+         * @see #FOCUS_MODE_EDOF
+         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
          */
-        @Deprecated
-        public void setPreviewFrameRate(int fps) {
-            set(KEY_PREVIEW_FRAME_RATE, fps);
+        public String getFocusMode() {
+            return get(KEY_FOCUS_MODE);
         }
 
         /**
-         * Returns the setting for the rate at which preview frames are
-         * received. This is the target frame rate. The actual frame rate
-         * depends on the driver.
+         * Sets the focus mode.
          *
-         * @return the frame rate setting (frames per second)
-         * @deprecated replaced by {@link #getPreviewFpsRange(int[])}
+         * @param value focus mode.
+         * @see #getFocusMode()
          */
-        @Deprecated
-        public int getPreviewFrameRate() {
-            return getInt(KEY_PREVIEW_FRAME_RATE);
+        public void setFocusMode(String value) {
+            set(KEY_FOCUS_MODE, value);
         }
 
         /**
-         * Gets the supported preview frame rates.
+         * Gets the supported focus modes.
          *
-         * @return a list of supported preview frame rates. null if preview
-         *         frame rate setting is not supported.
-         * @deprecated replaced by {@link #getSupportedPreviewFpsRange()}
+         * @return a list of supported focus modes. This method will always
+         *         return a list with at least one element.
+         * @see #getFocusMode()
          */
-        @Deprecated
-        public List<Integer> getSupportedPreviewFrameRates() {
-            String str = get(KEY_PREVIEW_FRAME_RATE + SUPPORTED_VALUES_SUFFIX);
-            return splitInt(str);
+        public List<String> getSupportedFocusModes() {
+            String str = get(KEY_FOCUS_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
         /**
-         * Sets the minimum and maximum preview fps. This controls the rate of
-         * preview frames received in {@link PreviewCallback}. The minimum and
-         * maximum preview fps must be one of the elements from {@link
-         * #getSupportedPreviewFpsRange}.
+         * Gets the focal length (in millimeter) of the camera.
          *
-         * @param min the minimum preview fps (scaled by 1000).
-         * @param max the maximum preview fps (scaled by 1000).
-         * @throws RuntimeException if fps range is invalid.
-         * @see #setPreviewCallbackWithBuffer(Camera.PreviewCallback)
-         * @see #getSupportedPreviewFpsRange()
+         * @return the focal length. This method will always return a valid
+         *         value.
          */
-        public void setPreviewFpsRange(int min, int max) {
-            set(KEY_PREVIEW_FPS_RANGE, "" + min + "," + max);
+        public float getFocalLength() {
+            return Float.parseFloat(get(KEY_FOCAL_LENGTH));
         }
 
         /**
-         * Returns the current minimum and maximum preview fps. The values are
-         * one of the elements returned by {@link #getSupportedPreviewFpsRange}.
+         * Gets the horizontal angle of view in degrees.
          *
-         * @return range the minimum and maximum preview fps (scaled by 1000).
-         * @see #PREVIEW_FPS_MIN_INDEX
-         * @see #PREVIEW_FPS_MAX_INDEX
-         * @see #getSupportedPreviewFpsRange()
+         * @return horizontal angle of view. This method will always return a
+         *         valid value.
          */
-        public void getPreviewFpsRange(int[] range) {
-            if (range == null || range.length != 2) {
-                throw new IllegalArgumentException(
-                        "range must be an array with two elements.");
-            }
-            splitInt(get(KEY_PREVIEW_FPS_RANGE), range);
+        public float getHorizontalViewAngle() {
+            return Float.parseFloat(get(KEY_HORIZONTAL_VIEW_ANGLE));
         }
 
         /**
-         * Gets the supported preview fps (frame-per-second) ranges. Each range
-         * contains a minimum fps and maximum fps. If minimum fps equals to
-         * maximum fps, the camera outputs frames in fixed frame rate. If not,
-         * the camera outputs frames in auto frame rate. The actual frame rate
-         * fluctuates between the minimum and the maximum. The values are
-         * multiplied by 1000 and represented in integers. For example, if frame
-         * rate is 26.623 frames per second, the value is 26623.
+         * Gets the vertical angle of view in degrees.
          *
-         * @return a list of supported preview fps ranges. This method returns a
-         *         list with at least one element. Every element is an int array
-         *         of two values - minimum fps and maximum fps. The list is
-         *         sorted from small to large (first by maximum fps and then
-         *         minimum fps).
-         * @see #PREVIEW_FPS_MIN_INDEX
-         * @see #PREVIEW_FPS_MAX_INDEX
+         * @return vertical angle of view. This method will always return a
+         *         valid value.
          */
-        public List<int[]> getSupportedPreviewFpsRange() {
-            String str = get(KEY_PREVIEW_FPS_RANGE + SUPPORTED_VALUES_SUFFIX);
-            return splitRange(str);
+        public float getVerticalViewAngle() {
+            return Float.parseFloat(get(KEY_VERTICAL_VIEW_ANGLE));
         }
 
         /**
-         * Sets the image format for preview pictures.
-         * <p>If this is never called, the default format will be
-         * {@link android.graphics.ImageFormat#NV21}, which
-         * uses the NV21 encoding format.</p>
-         *
-         * <p>Use {@link Parameters#getSupportedPreviewFormats} to get a list of
-         * the available preview formats.
-         *
-         * <p>It is strongly recommended that either
-         * {@link android.graphics.ImageFormat#NV21} or
-         * {@link android.graphics.ImageFormat#YV12} is used, since
-         * they are supported by all camera devices.</p>
-         *
-         * <p>For YV12, the image buffer that is received is not necessarily
-         * tightly packed, as there may be padding at the end of each row of
-         * pixel data, as described in
-         * {@link android.graphics.ImageFormat#YV12}. For camera callback data,
-         * it can be assumed that the stride of the Y and UV data is the
-         * smallest possible that meets the alignment requirements. That is, if
-         * the preview size is <var>width x height</var>, then the following
-         * equations describe the buffer index for the beginning of row
-         * <var>y</var> for the Y plane and row <var>c</var> for the U and V
-         * planes:
-         *
-         * {@code
-         * <pre>
-         * yStride   = (int) ceil(width / 16.0) * 16;
-         * uvStride  = (int) ceil( (yStride / 2) / 16.0) * 16;
-         * ySize     = yStride * height;
-         * uvSize    = uvStride * height / 2;
-         * yRowIndex = yStride * y;
-         * uRowIndex = ySize + uvSize + uvStride * c;
-         * vRowIndex = ySize + uvStride * c;
-         * size      = ySize + uvSize * 2;</pre>
-         * }
-         *
-         * @param pixel_format the desired preview picture format, defined by
-         *   one of the {@link android.graphics.ImageFormat} constants.  (E.g.,
-         *   <var>ImageFormat.NV21</var> (default), or
-         *   <var>ImageFormat.YV12</var>)
+         * Gets the current exposure compensation index.
          *
-         * @see android.graphics.ImageFormat
-         * @see android.hardware.Camera.Parameters#getSupportedPreviewFormats
+         * @return current exposure compensation index. The range is {@link
+         *         #getMinExposureCompensation} to {@link
+         *         #getMaxExposureCompensation}. 0 means exposure is not
+         *         adjusted.
          */
-        public void setPreviewFormat(int pixel_format) {
-            String s = cameraFormatForPixelFormat(pixel_format);
-            if (s == null) {
-                throw new IllegalArgumentException(
-                        "Invalid pixel_format=" + pixel_format);
-            }
-
-            set(KEY_PREVIEW_FORMAT, s);
+        public int getExposureCompensation() {
+            return getInt(KEY_EXPOSURE_COMPENSATION, 0);
         }
 
         /**
-         * Returns the image format for preview frames got from
-         * {@link PreviewCallback}.
+         * Sets the exposure compensation index.
          *
-         * @return the preview format.
-         * @see android.graphics.ImageFormat
-         * @see #setPreviewFormat
+         * @param value exposure compensation index. The valid value range is
+         *        from {@link #getMinExposureCompensation} (inclusive) to {@link
+         *        #getMaxExposureCompensation} (inclusive). 0 means exposure is
+         *        not adjusted. Application should call
+         *        getMinExposureCompensation and getMaxExposureCompensation to
+         *        know if exposure compensation is supported.
          */
-        public int getPreviewFormat() {
-            return pixelFormatForCameraFormat(get(KEY_PREVIEW_FORMAT));
+        public void setExposureCompensation(int value) {
+            set(KEY_EXPOSURE_COMPENSATION, value);
         }
 
         /**
-         * Gets the supported preview formats. {@link android.graphics.ImageFormat#NV21}
-         * is always supported. {@link android.graphics.ImageFormat#YV12}
-         * is always supported since API level 12.
+         * Gets the maximum exposure compensation index.
          *
-         * @return a list of supported preview formats. This method will always
-         *         return a list with at least one element.
-         * @see android.graphics.ImageFormat
-         * @see #setPreviewFormat
+         * @return maximum exposure compensation index (>=0). If both this
+         *         method and {@link #getMinExposureCompensation} return 0,
+         *         exposure compensation is not supported.
          */
-        public List<Integer> getSupportedPreviewFormats() {
-            String str = get(KEY_PREVIEW_FORMAT + SUPPORTED_VALUES_SUFFIX);
-            ArrayList<Integer> formats = new ArrayList<Integer>();
-            for (String s : split(str)) {
-                int f = pixelFormatForCameraFormat(s);
-                if (f == ImageFormat.UNKNOWN) continue;
-                formats.add(f);
-            }
-            return formats;
+        public int getMaxExposureCompensation() {
+            return getInt(KEY_MAX_EXPOSURE_COMPENSATION, 0);
         }
 
         /**
-         * <p>Sets the dimensions for pictures.</p>
-         *
-         * <p>Applications need to consider the display orientation. See {@link
-         * #setPreviewSize(int,int)} for reference.</p>
-         *
-         * @param width  the width for pictures, in pixels
-         * @param height the height for pictures, in pixels
-         * @see #setPreviewSize(int,int)
+         * Gets the minimum exposure compensation index.
          *
+         * @return minimum exposure compensation index (<=0). If both this
+         *         method and {@link #getMaxExposureCompensation} return 0,
+         *         exposure compensation is not supported.
          */
-        public void setPictureSize(int width, int height) {
-            String v = Integer.toString(width) + "x" + Integer.toString(height);
-            set(KEY_PICTURE_SIZE, v);
+        public int getMinExposureCompensation() {
+            return getInt(KEY_MIN_EXPOSURE_COMPENSATION, 0);
         }
 
         /**
-         * Returns the dimension setting for pictures.
+         * Gets the exposure compensation step.
          *
-         * @return a Size object with the height and width setting
-         *          for pictures
+         * @return exposure compensation step. Applications can get EV by
+         *         multiplying the exposure compensation index and step. Ex: if
+         *         exposure compensation index is -6 and step is 0.333333333, EV
+         *         is -2.
          */
-        public Size getPictureSize() {
-            String pair = get(KEY_PICTURE_SIZE);
-            return strToSize(pair);
+        public float getExposureCompensationStep() {
+            return getFloat(KEY_EXPOSURE_COMPENSATION_STEP, 0);
         }
 
         /**
-         * Gets the supported picture sizes.
+         * <p>Sets the auto-exposure lock state. Applications should check
+         * {@link #isAutoExposureLockSupported} before using this method.</p>
          *
-         * @return a list of supported picture sizes. This method will always
-         *         return a list with at least one element.
+         * <p>If set to true, the camera auto-exposure routine will immediately
+         * pause until the lock is set to false. Exposure compensation settings
+         * changes will still take effect while auto-exposure is locked.</p>
+         *
+         * <p>If auto-exposure is already locked, setting this to true again has
+         * no effect (the driver will not recalculate exposure values).</p>
+         *
+         * <p>Stopping preview with {@link #stopPreview()}, or triggering still
+         * image capture with {@link #takePicture(Camera.ShutterCallback,
+         * Camera.PictureCallback, Camera.PictureCallback)}, will not change the
+         * lock.</p>
+         *
+         * <p>Exposure compensation, auto-exposure lock, and auto-white balance
+         * lock can be used to capture an exposure-bracketed burst of images,
+         * for example.</p>
+         *
+         * <p>Auto-exposure state, including the lock state, will not be
+         * maintained after camera {@link #release()} is called.  Locking
+         * auto-exposure after {@link #open()} but before the first call to
+         * {@link #startPreview()} will not allow the auto-exposure routine to
+         * run at all, and may result in severely over- or under-exposed
+         * images.</p>
+         *
+         * @param toggle new state of the auto-exposure lock. True means that
+         *        auto-exposure is locked, false means that the auto-exposure
+         *        routine is free to run normally.
+         *
+         * @see #getAutoExposureLock()
          */
-        public List<Size> getSupportedPictureSizes() {
-            String str = get(KEY_PICTURE_SIZE + SUPPORTED_VALUES_SUFFIX);
-            return splitSize(str);
+        public void setAutoExposureLock(boolean toggle) {
+            set(KEY_AUTO_EXPOSURE_LOCK, toggle ? TRUE : FALSE);
         }
 
         /**
-         * Sets the image format for pictures.
+         * Gets the state of the auto-exposure lock. Applications should check
+         * {@link #isAutoExposureLockSupported} before using this method. See
+         * {@link #setAutoExposureLock} for details about the lock.
+         *
+         * @return State of the auto-exposure lock. Returns true if
+         *         auto-exposure is currently locked, and false otherwise.
+         *
+         * @see #setAutoExposureLock(boolean)
          *
-         * @param pixel_format the desired picture format
-         *                     (<var>ImageFormat.NV21</var>,
-         *                      <var>ImageFormat.RGB_565</var>, or
-         *                      <var>ImageFormat.JPEG</var>)
-         * @see android.graphics.ImageFormat
          */
-        public void setPictureFormat(int pixel_format) {
-            String s = cameraFormatForPixelFormat(pixel_format);
-            if (s == null) {
-                throw new IllegalArgumentException(
-                        "Invalid pixel_format=" + pixel_format);
-            }
-
-            set(KEY_PICTURE_FORMAT, s);
+        public boolean getAutoExposureLock() {
+            String str = get(KEY_AUTO_EXPOSURE_LOCK);
+            return TRUE.equals(str);
         }
 
         /**
-         * Returns the image format for pictures.
+         * Returns true if auto-exposure locking is supported. Applications
+         * should call this before trying to lock auto-exposure. See
+         * {@link #setAutoExposureLock} for details about the lock.
+         *
+         * @return true if auto-exposure lock is supported.
+         * @see #setAutoExposureLock(boolean)
          *
-         * @return the picture format
-         * @see android.graphics.ImageFormat
          */
-        public int getPictureFormat() {
-            return pixelFormatForCameraFormat(get(KEY_PICTURE_FORMAT));
+        public boolean isAutoExposureLockSupported() {
+            String str = get(KEY_AUTO_EXPOSURE_LOCK_SUPPORTED);
+            return TRUE.equals(str);
         }
 
         /**
-         * Gets the supported picture formats.
+         * <p>Sets the auto-white balance lock state. Applications should check
+         * {@link #isAutoWhiteBalanceLockSupported} before using this
+         * method.</p>
          *
-         * @return supported picture formats. This method will always return a
-         *         list with at least one element.
-         * @see android.graphics.ImageFormat
+         * <p>If set to true, the camera auto-white balance routine will
+         * immediately pause until the lock is set to false.</p>
+         *
+         * <p>If auto-white balance is already locked, setting this to true
+         * again has no effect (the driver will not recalculate white balance
+         * values).</p>
+         *
+         * <p>Stopping preview with {@link #stopPreview()}, or triggering still
+         * image capture with {@link #takePicture(Camera.ShutterCallback,
+         * Camera.PictureCallback, Camera.PictureCallback)}, will not change the
+         * the lock.</p>
+         *
+         * <p> Changing the white balance mode with {@link #setWhiteBalance}
+         * will release the auto-white balance lock if it is set.</p>
+         *
+         * <p>Exposure compensation, AE lock, and AWB lock can be used to
+         * capture an exposure-bracketed burst of images, for example.
+         * Auto-white balance state, including the lock state, will not be
+         * maintained after camera {@link #release()} is called.  Locking
+         * auto-white balance after {@link #open()} but before the first call to
+         * {@link #startPreview()} will not allow the auto-white balance routine
+         * to run at all, and may result in severely incorrect color in captured
+         * images.</p>
+         *
+         * @param toggle new state of the auto-white balance lock. True means
+         *        that auto-white balance is locked, false means that the
+         *        auto-white balance routine is free to run normally.
+         *
+         * @see #getAutoWhiteBalanceLock()
+         * @see #setWhiteBalance(String)
          */
-        public List<Integer> getSupportedPictureFormats() {
-            String str = get(KEY_PICTURE_FORMAT + SUPPORTED_VALUES_SUFFIX);
-            ArrayList<Integer> formats = new ArrayList<Integer>();
-            for (String s : split(str)) {
-                int f = pixelFormatForCameraFormat(s);
-                if (f == ImageFormat.UNKNOWN) continue;
-                formats.add(f);
-            }
-            return formats;
-        }
-
-        private String cameraFormatForPixelFormat(int pixel_format) {
-            switch(pixel_format) {
-            case ImageFormat.NV16:      return PIXEL_FORMAT_YUV422SP;
-            case ImageFormat.NV21:      return PIXEL_FORMAT_YUV420SP;
-            case ImageFormat.YUY2:      return PIXEL_FORMAT_YUV422I;
-            case ImageFormat.YV12:      return PIXEL_FORMAT_YUV420P;
-            case ImageFormat.RGB_565:   return PIXEL_FORMAT_RGB565;
-            case ImageFormat.JPEG:      return PIXEL_FORMAT_JPEG;
-            default:                    return null;
-            }
-        }
-
-        private int pixelFormatForCameraFormat(String format) {
-            if (format == null)
-                return ImageFormat.UNKNOWN;
-
-            if (format.equals(PIXEL_FORMAT_YUV422SP))
-                return ImageFormat.NV16;
-
-            if (format.equals(PIXEL_FORMAT_YUV420SP))
-                return ImageFormat.NV21;
-
-            if (format.equals(PIXEL_FORMAT_YUV422I))
-                return ImageFormat.YUY2;
-
-            if (format.equals(PIXEL_FORMAT_YUV420P))
-                return ImageFormat.YV12;
-
-            if (format.equals(PIXEL_FORMAT_RGB565))
-                return ImageFormat.RGB_565;
-
-            if (format.equals(PIXEL_FORMAT_JPEG))
-                return ImageFormat.JPEG;
-
-            return ImageFormat.UNKNOWN;
+        public void setAutoWhiteBalanceLock(boolean toggle) {
+            set(KEY_AUTO_WHITEBALANCE_LOCK, toggle ? TRUE : FALSE);
         }
 
         /**
-         * Sets the clockwise rotation angle in degrees relative to the
-         * orientation of the camera. This affects the pictures returned from
-         * JPEG {@link PictureCallback}. The camera driver may set orientation
-         * in the EXIF header without rotating the picture. Or the driver may
-         * rotate the picture and the EXIF thumbnail. If the Jpeg picture is
-         * rotated, the orientation in the EXIF header will be missing or 1 (row
-         * #0 is top and column #0 is left side).
-         *
-         * <p>
-         * If applications want to rotate the picture to match the orientation
-         * of what users see, apps should use
-         * {@link android.view.OrientationEventListener} and
-         * {@link android.hardware.Camera.CameraInfo}. The value from
-         * OrientationEventListener is relative to the natural orientation of
-         * the device. CameraInfo.orientation is the angle between camera
-         * orientation and natural device orientation. The sum of the two is the
-         * rotation angle for back-facing camera. The difference of the two is
-         * the rotation angle for front-facing camera. Note that the JPEG
-         * pictures of front-facing cameras are not mirrored as in preview
-         * display.
-         *
-         * <p>
-         * For example, suppose the natural orientation of the device is
-         * portrait. The device is rotated 270 degrees clockwise, so the device
-         * orientation is 270. Suppose a back-facing camera sensor is mounted in
-         * landscape and the top side of the camera sensor is aligned with the
-         * right edge of the display in natural orientation. So the camera
-         * orientation is 90. The rotation should be set to 0 (270 + 90).
+         * Gets the state of the auto-white balance lock. Applications should
+         * check {@link #isAutoWhiteBalanceLockSupported} before using this
+         * method. See {@link #setAutoWhiteBalanceLock} for details about the
+         * lock.
          *
-         * <p>The reference code is as follows.
+         * @return State of the auto-white balance lock. Returns true if
+         *         auto-white balance is currently locked, and false
+         *         otherwise.
          *
-         * <pre>
-         * public void onOrientationChanged(int orientation) {
-         *     if (orientation == ORIENTATION_UNKNOWN) return;
-         *     android.hardware.Camera.CameraInfo info =
-         *            new android.hardware.Camera.CameraInfo();
-         *     android.hardware.Camera.getCameraInfo(cameraId, info);
-         *     orientation = (orientation + 45) / 90 * 90;
-         *     int rotation = 0;
-         *     if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
-         *         rotation = (info.orientation - orientation + 360) % 360;
-         *     } else {  // back-facing camera
-         *         rotation = (info.orientation + orientation) % 360;
-         *     }
-         *     mParameters.setRotation(rotation);
-         * }
-         * </pre>
+         * @see #setAutoWhiteBalanceLock(boolean)
          *
-         * @param rotation The rotation angle in degrees relative to the
-         *                 orientation of the camera. Rotation can only be 0,
-         *                 90, 180 or 270.
-         * @throws IllegalArgumentException if rotation value is invalid.
-         * @see android.view.OrientationEventListener
-         * @see #getCameraInfo(int, CameraInfo)
          */
-        public void setRotation(int rotation) {
-            if (rotation == 0 || rotation == 90 || rotation == 180
-                    || rotation == 270) {
-                set(KEY_ROTATION, Integer.toString(rotation));
-            } else {
-                throw new IllegalArgumentException(
-                        "Invalid rotation=" + rotation);
-            }
+        public boolean getAutoWhiteBalanceLock() {
+            String str = get(KEY_AUTO_WHITEBALANCE_LOCK);
+            return TRUE.equals(str);
         }
 
         /**
-         * Sets GPS latitude coordinate. This will be stored in JPEG EXIF
-         * header.
+         * Returns true if auto-white balance locking is supported. Applications
+         * should call this before trying to lock auto-white balance. See
+         * {@link #setAutoWhiteBalanceLock} for details about the lock.
+         *
+         * @return true if auto-white balance lock is supported.
+         * @see #setAutoWhiteBalanceLock(boolean)
          *
-         * @param latitude GPS latitude coordinate.
          */
-        public void setGpsLatitude(double latitude) {
-            set(KEY_GPS_LATITUDE, Double.toString(latitude));
+        public boolean isAutoWhiteBalanceLockSupported() {
+            String str = get(KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED);
+            return TRUE.equals(str);
         }
 
         /**
-         * Sets GPS longitude coordinate. This will be stored in JPEG EXIF
-         * header.
+         * Gets current zoom value. This also works when smooth zoom is in
+         * progress. Applications should check {@link #isZoomSupported} before
+         * using this method.
          *
-         * @param longitude GPS longitude coordinate.
+         * @return the current zoom value. The range is 0 to {@link
+         *         #getMaxZoom}. 0 means the camera is not zoomed.
          */
-        public void setGpsLongitude(double longitude) {
-            set(KEY_GPS_LONGITUDE, Double.toString(longitude));
+        public int getZoom() {
+            return getInt(KEY_ZOOM, 0);
         }
 
         /**
-         * Sets GPS altitude. This will be stored in JPEG EXIF header.
+         * Sets current zoom value. If the camera is zoomed (value > 0), the
+         * actual picture size may be smaller than picture size setting.
+         * Applications can check the actual picture size after picture is
+         * returned from {@link PictureCallback}. The preview size remains the
+         * same in zoom. Applications should check {@link #isZoomSupported}
+         * before using this method.
          *
-         * @param altitude GPS altitude in meters.
+         * @param value zoom value. The valid range is 0 to {@link #getMaxZoom}.
          */
-        public void setGpsAltitude(double altitude) {
-            set(KEY_GPS_ALTITUDE, Double.toString(altitude));
+        public void setZoom(int value) {
+            set(KEY_ZOOM, value);
         }
 
         /**
-         * Sets GPS timestamp. This will be stored in JPEG EXIF header.
+         * Returns true if zoom is supported. Applications should call this
+         * before using other zoom methods.
          *
-         * @param timestamp GPS timestamp (UTC in seconds since January 1,
-         *                  1970).
+         * @return true if zoom is supported.
          */
-        public void setGpsTimestamp(long timestamp) {
-            set(KEY_GPS_TIMESTAMP, Long.toString(timestamp));
+        public boolean isZoomSupported() {
+            String str = get(KEY_ZOOM_SUPPORTED);
+            return TRUE.equals(str);
         }
 
         /**
-         * Sets GPS processing method. The method will be stored in a UTF-8 string up to 31 bytes
-         * long, in the JPEG EXIF header.
+         * Gets the maximum zoom value allowed for snapshot. This is the maximum
+         * value that applications can set to {@link #setZoom(int)}.
+         * Applications should call {@link #isZoomSupported} before using this
+         * method. This value may change in different preview size. Applications
+         * should call this again after setting preview size.
          *
-         * @param processing_method The processing method to get this location.
+         * @return the maximum zoom value supported by the camera.
          */
-        public void setGpsProcessingMethod(String processing_method) {
-            set(KEY_GPS_PROCESSING_METHOD, processing_method);
+        public int getMaxZoom() {
+            return getInt(KEY_MAX_ZOOM, 0);
         }
 
         /**
-         * Removes GPS latitude, longitude, altitude, and timestamp from the
-         * parameters.
+         * Gets the zoom ratios of all zoom values. Applications should check
+         * {@link #isZoomSupported} before using this method.
+         *
+         * @return the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
+         *         returned as 320. The number of elements is {@link
+         *         #getMaxZoom} + 1. The list is sorted from small to large. The
+         *         first element is always 100. The last element is the zoom
+         *         ratio of the maximum zoom value.
          */
-        public void removeGpsData() {
-            remove(KEY_QC_GPS_LATITUDE_REF);
-            remove(KEY_GPS_LATITUDE);
-            remove(KEY_QC_GPS_LONGITUDE_REF);
-            remove(KEY_GPS_LONGITUDE);
-            remove(KEY_QC_GPS_ALTITUDE_REF);
-            remove(KEY_GPS_ALTITUDE);
-            remove(KEY_GPS_TIMESTAMP);
-            remove(KEY_GPS_PROCESSING_METHOD);
+        public List<Integer> getZoomRatios() {
+            return splitInt(get(KEY_ZOOM_RATIOS));
         }
 
         /**
-         * Gets the current white balance setting.
-         *
-         * @return current white balance. null if white balance setting is not
-         *         supported.
-         * @see #WHITE_BALANCE_AUTO
-         * @see #WHITE_BALANCE_INCANDESCENT
-         * @see #WHITE_BALANCE_FLUORESCENT
-         * @see #WHITE_BALANCE_WARM_FLUORESCENT
-         * @see #WHITE_BALANCE_DAYLIGHT
-         * @see #WHITE_BALANCE_CLOUDY_DAYLIGHT
-         * @see #WHITE_BALANCE_TWILIGHT
-         * @see #WHITE_BALANCE_SHADE
+         * Returns true if smooth zoom is supported. Applications should call
+         * this before using other smooth zoom methods.
          *
+         * @return true if smooth zoom is supported.
          */
-        public String getWhiteBalance() {
-            return get(KEY_WHITE_BALANCE);
+        public boolean isSmoothZoomSupported() {
+            String str = get(KEY_SMOOTH_ZOOM_SUPPORTED);
+            return TRUE.equals(str);
         }
 
+        //!++
         /**
-         * Sets the white balance. Changing the setting will release the
-         * auto-white balance lock. It is recommended not to change white
-         * balance and AWB lock at the same time.
-         *
-         * @param value new white balance.
-         * @see #getWhiteBalance()
-         * @see #setAutoWhiteBalanceLock(boolean)
+         * @hide
+         * Sets the camera mode
+         * @param value: see #CAMERA_MODE_NORMAL, #CAMERA_MODE_MTK_PRV, #CAMERA_MODE_MTK_VDO, #CAMERA_MODE_MTK_VT
          */
-        public void setWhiteBalance(String value) {
-            String oldValue = get(KEY_WHITE_BALANCE);
-            if (same(value, oldValue)) return;
-            set(KEY_WHITE_BALANCE, value);
-            set(KEY_AUTO_WHITEBALANCE_LOCK, FALSE);
+        public void setCameraMode(int value) {
+            Log.d(TAG, "setCameraMode=" + value);
+            set(KEY_CAMERA_MODE, value);
         }
 
+        // ISO
         /**
-         * Gets the supported white balance.
-         *
-         * @return a list of supported white balance. null if white balance
-         *         setting is not supported.
-         * @see #getWhiteBalance()
+         * @hide
+         * Gets the ISO speed
+         * @return "auto", "100", "200", "400", "800" or "1600"
          */
-        public List<String> getSupportedWhiteBalance() {
-            String str = get(KEY_WHITE_BALANCE + SUPPORTED_VALUES_SUFFIX);
+        public String getISOSpeed() {
+            return get(KEY_ISOSPEED_MODE);
+        }
+        /**
+         * @hide
+         * Sets the ISO speed
+         * @param value "auto", "100", "200", "400", "800" or "1600"
+         */
+        public void setISOSpeed(String value) {
+            set(KEY_ISOSPEED_MODE, value);
+        }
+        /**
+         * @hide
+         * @return the supported ISO speed
+         * get all supported ISO speed
+         */
+        public List<String> getSupportedISOSpeed() {
+            String str = get(KEY_ISOSPEED_MODE + SUPPORTED_VALUES_SUFFIX);
             return split(str);
         }
-
+        //OT
         /**
-         * Gets the current color effect setting.
+         * @hide get max num of objects
          *
-         * @return current color effect. null if color effect
-         *         setting is not supported.
-         * @see #EFFECT_NONE
-         * @see #EFFECT_MONO
-         * @see #EFFECT_NEGATIVE
-         * @see #EFFECT_SOLARIZE
-         * @see #EFFECT_SEPIA
-         * @see #EFFECT_POSTERIZE
-         * @see #EFFECT_WHITEBOARD
-         * @see #EFFECT_BLACKBOARD
-         * @see #EFFECT_AQUA
+         *
+         */
+        public int getMaxNumDetectedObjects() {
+            return getInt(Parameters.KEY_MAX_NUM_DETECTED_OBJECT, 0);
+        }
+
+        // FDMode
+        /**
+         * @hide
+         * Gets the FD mode
+         * @return "on" or "off"
+         */
+        public String getFDMode() {
+            return get(KEY_FD_MODE);
+        }
+        /**
+         * @hide
+         * Sets the FD mode
+         * @param value "on" or "off"
+         */
+        public void setFDMode(String value) {
+            set(KEY_FD_MODE, value);
+        }
+        /**
+         * @hide
+         */
+        public List<String> getSupportedFDMode() {
+            String str = get(KEY_FD_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        // Edge
+        /**
+         * @hide
+         * @return the edge mode
+         * get the edge mode
+         */
+        public String getEdgeMode() {
+            return get(KEY_EDGE_MODE);
+        }
+        /**
+         * @hide
+         * @param value : the value set for edge mode
+         * set value for edge mode
+         */
+        public void setEdgeMode(String value) {
+            set(KEY_EDGE_MODE, value);
+        }
+        /**
+         * @hide
+         * @return the supported edge mode
+         * get all supported edge mode
+         */
+        public List<String> getSupportedEdgeMode() {
+            String str = get(KEY_EDGE_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        // Hue
+        /**
+         * @hide
+         * @return the hue mode
+         * get the hue mode
+         */
+        public String getHueMode() {
+            return get(KEY_HUE_MODE);
+        }
+        /**
+         * @hide
+         * @param value: the value set for hue mode
+         * set value for hue mode
+         */
+        public void setHueMode(String value) {
+            set(KEY_HUE_MODE, value);
+        }
+        /**
+         * @hide
+         * @return the supported hue mode
+         * get all supported hue mode
+         */
+        public List<String> getSupportedHueMode() {
+            String str = get(KEY_HUE_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        // Saturation
+        /**
+         * @hide
+         * @return the Saturation mode
+         * get the Saturation mode
+         */
+        public String getSaturationMode() {
+            return get(KEY_SATURATION_MODE);
+        }
+        /**
+         * @hide
+         * @param value: the value set to Saturation
+         * set value for Saturation
+         */
+        public void setSaturationMode(String value) {
+            set(KEY_SATURATION_MODE, value);
+        }
+        /**
+         * @hide
+         * @return the supported Saturation mode
+         * get all supported Saturation mode
+         */
+        public List<String> getSupportedSaturationMode() {
+            String str = get(KEY_SATURATION_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        // Brightness
+        /**
+         * @hide
+         * @return the brightness mode
+         * get the brightness mode
+         */
+        public String getBrightnessMode() {
+            return get(KEY_BRIGHTNESS_MODE);
+        }
+        /**
+         * @hide
+         * @param value: the value set to brightness mode
+         * set value for brightness mode
+         */
+        public void setBrightnessMode(String value) {
+            set(KEY_BRIGHTNESS_MODE, value);
+        }
+        /**
+         * @hide
+         */
+        public List<String> getSupportedBrightnessMode() {
+            String str = get(KEY_BRIGHTNESS_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        // Contrast
+        /**
+         * @hide
+         * @return the contrast mode
+         * get the contrast mode
          */
-        public String getColorEffect() {
-            return get(KEY_EFFECT);
+        public String getContrastMode() {
+            return get(KEY_CONTRAST_MODE);
         }
-
         /**
-         * Sets the current color effect setting.
-         *
-         * @param value new color effect.
-         * @see #getColorEffect()
+         * @hide
+         * @param value: the value set to contrast mode
+         * set value for contrast mode
          */
-        public void setColorEffect(String value) {
-            set(KEY_EFFECT, value);
+        public void setContrastMode(String value) {
+            set(KEY_CONTRAST_MODE, value);
         }
-
         /**
-         * Gets the supported color effects.
-         *
-         * @return a list of supported color effects. null if color effect
-         *         setting is not supported.
-         * @see #getColorEffect()
+         * @hide
+         * @return the supported contrast mode
+         * get all supported contrast mode
          */
-        public List<String> getSupportedColorEffects() {
-            String str = get(KEY_EFFECT + SUPPORTED_VALUES_SUFFIX);
+        public List<String> getSupportedContrastMode() {
+            String str = get(KEY_CONTRAST_MODE + SUPPORTED_VALUES_SUFFIX);
             return split(str);
         }
-
-
+        // Capture mode
         /**
-         * Gets the current antibanding setting.
-         *
-         * @return current antibanding. null if antibanding setting is not
-         *         supported.
-         * @see #ANTIBANDING_AUTO
-         * @see #ANTIBANDING_50HZ
-         * @see #ANTIBANDING_60HZ
-         * @see #ANTIBANDING_OFF
+         * @hide
          */
-        public String getAntibanding() {
-            return get(KEY_ANTIBANDING);
+        public String getCaptureMode() {
+            return get(KEY_CAPTURE_MODE);
         }
-
         /**
-         * Sets the antibanding.
-         *
-         * @param antibanding new antibanding value.
-         * @see #getAntibanding()
+         * @hide
+         * @param value: CAPTURE_MODE_NORMAL, CAPTURE_MODE_BEST_SHOT,
+         *        CAPTURE_MODE_EV_BRACKET_SHOT, CAPTURE_MODE_BURST_SHOT,
+         *        CAPTURE_MODE_SMILE_SHOT, CAPTURE_MODE_PANORAMA_SHOT
          */
-        public void setAntibanding(String antibanding) {
-            set(KEY_ANTIBANDING, antibanding);
+        public void setCaptureMode(String value) {
+            set(KEY_CAPTURE_MODE, value);
         }
-
         /**
-         * Gets the supported antibanding values.
-         *
-         * @return a list of supported antibanding values. null if antibanding
-         *         setting is not supported.
-         * @see #getAntibanding()
+         * @hide
+         * @return the supported capture mode
+         * get all supported capture mode
          */
-        public List<String> getSupportedAntibanding() {
-            String str = get(KEY_ANTIBANDING + SUPPORTED_VALUES_SUFFIX);
+        public List<String> getSupportedCaptureMode() {
+            String str = get(KEY_CAPTURE_MODE + SUPPORTED_VALUES_SUFFIX);
             return split(str);
         }
-
         /**
-         * Gets the current scene mode setting.
+         * @hide
+         * @param   value: file path, if file path is /sdcard/DCIM/cap00, the output file
+         * will be cap00, cap01, cap02, ...
+         * set the storage path for capture image store
+         */
+        public void setCapturePath(String value) {
+            if (value == null) {
+                remove(KEY_CAPTURE_PATH);
+            } else {
+                set(KEY_CAPTURE_PATH, value);
+            }
+        }
+        /**
+         * @hide
+         * @param  value: should be 4 / 8 / 16
+         * set the burst shot number
+         */
+        public void setBurstShotNum(int value) {
+            set(KEY_BURST_SHOT_NUM, value);
+        }
+        /**
+         * @hide
          *
-         * @return one of SCENE_MODE_XXX string constant. null if scene mode
-         *         setting is not supported.
-         * @see #SCENE_MODE_AUTO
-         * @see #SCENE_MODE_ACTION
-         * @see #SCENE_MODE_PORTRAIT
-         * @see #SCENE_MODE_LANDSCAPE
-         * @see #SCENE_MODE_NIGHT
-         * @see #SCENE_MODE_NIGHT_PORTRAIT
-         * @see #SCENE_MODE_THEATRE
-         * @see #SCENE_MODE_BEACH
-         * @see #SCENE_MODE_SNOW
-         * @see #SCENE_MODE_SUNSET
-         * @see #SCENE_MODE_STEADYPHOTO
-         * @see #SCENE_MODE_FIREWORKS
-         * @see #SCENE_MODE_SPORTS
-         * @see #SCENE_MODE_PARTY
-         * @see #SCENE_MODE_CANDLELIGHT
-         * @see #SCENE_MODE_BARCODE
+         * Sets the focus engineer mode
+         * mode: FOCUS_ENG_MODE_NONE, FOCUS_ENG_MODE_BRACKET,
+         *       FOCUS_ENG_MODE_FULLSCAN, FOCUS_ENG_MODE_REPEAT
          */
-        public String getSceneMode() {
-            return get(KEY_SCENE_MODE);
+        public void setFocusEngMode(int mode) {
+            set(KEY_FOCUS_ENG_MODE, mode);
         }
 
         /**
-         * Sets the scene mode. Changing scene mode may override other
-         * parameters (such as flash mode, focus mode, white balance). For
-         * example, suppose originally flash mode is on and supported flash
-         * modes are on/off. In night scene mode, both flash mode and supported
-         * flash mode may be changed to off. After setting scene mode,
-         * applications should call getParameters to know if some parameters are
-         * changed.
-         *
-         * @param value scene mode.
-         * @see #getSceneMode()
+         * @hide
+         * @return the step get the best focus
+         * get the step of doing the best focus
          */
-        public void setSceneMode(String value) {
-            set(KEY_SCENE_MODE, value);
+        public int getBestFocusStep() {
+            return getInt(KEY_FOCUS_ENG_BEST_STEP, 0);
         }
 
         /**
-         * Gets the supported scene modes.
-         *
-         * @return a list of supported scene modes. null if scene mode setting
-         *         is not supported.
-         * @see #getSceneMode()
+         * @hide
          */
-        public List<String> getSupportedSceneModes() {
-            String str = get(KEY_SCENE_MODE + SUPPORTED_VALUES_SUFFIX);
-            return split(str);
+        public void setRawDumpFlag(boolean toggle) {
+            Log.d(TAG, "setRawDumpFlag=" + toggle);
+            set(KEY_RAW_DUMP_FLAG, toggle ? TRUE : FALSE);
         }
 
         /**
-         * Gets the current flash mode setting.
-         *
-         * @return current flash mode. null if flash mode setting is not
-         *         supported.
-         * @see #FLASH_MODE_OFF
-         * @see #FLASH_MODE_AUTO
-         * @see #FLASH_MODE_ON
-         * @see #FLASH_MODE_RED_EYE
-         * @see #FLASH_MODE_TORCH
+         * @hide
          */
-        public String getFlashMode() {
-            return get(KEY_FLASH_MODE);
+        public void setPreviewRawDumpResolution(int value) {
+            Log.d(TAG, "setPreviewRawDumpResolution=" + value);
+            set(KEY_PREVIEW_DUMP_RESOLUTION, value);
         }
 
         /**
-         * Sets the flash mode.
+         * @hide
+         * Gets the maximum focus step.
          *
-         * @param value flash mode.
-         * @see #getFlashMode()
+         * @return maximum focus step.
          */
-        public void setFlashMode(String value) {
-            set(KEY_FLASH_MODE, value);
+        public int getMaxFocusStep() {
+            return getInt(KEY_FOCUS_ENG_MAX_STEP , 0);
         }
 
         /**
-         * Gets the supported flash modes.
+         * @hide
+         * Gets the minimum focus step.
          *
-         * @return a list of supported flash modes. null if flash mode setting
-         *         is not supported.
-         * @see #getFlashMode()
+         * @return minimum focus step.
          */
-        public List<String> getSupportedFlashModes() {
-            String str = get(KEY_FLASH_MODE + SUPPORTED_VALUES_SUFFIX);
-            return split(str);
+        public int getMinFocusStep() {
+            return getInt(KEY_FOCUS_ENG_STEP, 0);
         }
 
+
         /**
-         * Gets the current focus mode setting.
+         * @hide
          *
-         * @return current focus mode. This method will always return a non-null
-         *         value. Applications should call {@link
-         *         #autoFocus(AutoFocusCallback)} to start the focus if focus
-         *         mode is FOCUS_MODE_AUTO or FOCUS_MODE_MACRO.
-         * @see #FOCUS_MODE_AUTO
-         * @see #FOCUS_MODE_INFINITY
-         * @see #FOCUS_MODE_MACRO
-         * @see #FOCUS_MODE_FIXED
-         * @see #FOCUS_MODE_EDOF
-         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
+         * Sets the focus step for BRACKET / FULLSCAN mode
          */
-        public String getFocusMode() {
-            return get(KEY_FOCUS_MODE);
+        public void setFocusEngStep(int step) {
+            set(KEY_FOCUS_ENG_STEP, step);
         }
 
         /**
-         * Sets the focus mode.
+         * @hide
          *
-         * @param value focus mode.
-         * @see #getFocusMode()
+         * Sets the Exposure Meter mode for Obejct Tracking
          */
-        public void setFocusMode(String value) {
-            set(KEY_FOCUS_MODE, value);
+        public void setExposureMeterMode(String mode) {
+            set(KEY_EXPOSURE_METER_MODE, mode);
         }
 
         /**
-         * Gets the supported focus modes.
+         * @hide
          *
-         * @return a list of supported focus modes. This method will always
-         *         return a list with at least one element.
-         * @see #getFocusMode()
+         * Gets the Exposure Meter mode for Obejct Tracking
          */
-        public List<String> getSupportedFocusModes() {
-            String str = get(KEY_FOCUS_MODE + SUPPORTED_VALUES_SUFFIX);
-            return split(str);
+        public String getExposureMeterMode() {
+            return get(KEY_EXPOSURE_METER_MODE);
         }
 
         /**
-         * Gets the focal length (in millimeter) of the camera.
+         * @hide
+         * Gets types of sensors.
          *
-         * @return the focal length. This method will always return a valid
-         *         value.
+         * @return sensor type.
          */
-        public float getFocalLength() {
-            return Float.parseFloat(get(KEY_FOCAL_LENGTH));
+        public int getSensorType() {
+            return getInt(KEY_SENSOR_TYPE, 0);
         }
 
         /**
-         * Gets the horizontal angle of view in degrees.
+         * @hide
          *
-         * @return horizontal angle of view. This method will always return a
-         *         valid value.
+         * Set AE enable/disable in engineer mode
          */
-        public float getHorizontalViewAngle() {
-            return Float.parseFloat(get(KEY_HORIZONTAL_VIEW_ANGLE));
+        public void setEngAEEnable(int enable) {
+            set(KEY_ENG_AE_ENABLE, enable);
         }
 
+
         /**
-         * Gets the vertical angle of view in degrees.
+         * @hide
          *
-         * @return vertical angle of view. This method will always return a
-         *         valid value.
+         * Set Flash duty value in engineer mode
          */
-        public float getVerticalViewAngle() {
-            return Float.parseFloat(get(KEY_VERTICAL_VIEW_ANGLE));
+        public void setEngFlashDuty(int duty) {
+            set(KEY_ENG_FLASH_DUTY_VALUE, duty);
         }
 
+
         /**
-         * Gets the current exposure compensation index.
+         * @hide
          *
-         * @return current exposure compensation index. The range is {@link
-         *         #getMinExposureCompensation} to {@link
-         *         #getMaxExposureCompensation}. 0 means exposure is not
-         *         adjusted.
+         * Set ZSD mode in engineer mode
          */
-        public int getExposureCompensation() {
-            return getInt(KEY_EXPOSURE_COMPENSATION, 0);
+        public void setEngZSDEnable(int enable) {
+            set(KEY_ENG_ZSD_ENABLE, enable);
         }
 
         /**
-         * Sets the exposure compensation index.
+         * @hide
+         *
+         * Get preview shutter speed
          *
-         * @param value exposure compensation index. The valid value range is
-         *        from {@link #getMinExposureCompensation} (inclusive) to {@link
-         *        #getMaxExposureCompensation} (inclusive). 0 means exposure is
-         *        not adjusted. Application should call
-         *        getMinExposureCompensation and getMaxExposureCompensation to
-         *        know if exposure compensation is supported.
          */
-        public void setExposureCompensation(int value) {
-            set(KEY_EXPOSURE_COMPENSATION, value);
+        public int getEngPreviewShutterSpeed() {
+            return getInt(KEY_ENG_PREVIEW_SHUTTER_SPEED, 0);
         }
 
         /**
-         * Gets the maximum exposure compensation index.
+         * @hide
+         *
+         * Get preview sensor gain
          *
-         * @return maximum exposure compensation index (>=0). If both this
-         *         method and {@link #getMinExposureCompensation} return 0,
-         *         exposure compensation is not supported.
          */
-        public int getMaxExposureCompensation() {
-            return getInt(KEY_MAX_EXPOSURE_COMPENSATION, 0);
+        public int getEngPreviewSensorGain() {
+            return getInt(KEY_ENG_PREVIEW_SENSOR_GAIN, 0);
         }
 
         /**
-         * Gets the minimum exposure compensation index.
+         * @hide
+         *
+         * Get preview isp gain
          *
-         * @return minimum exposure compensation index (<=0). If both this
-         *         method and {@link #getMaxExposureCompensation} return 0,
-         *         exposure compensation is not supported.
          */
-        public int getMinExposureCompensation() {
-            return getInt(KEY_MIN_EXPOSURE_COMPENSATION, 0);
+        public int getEngPreviewISPGain() {
+            return getInt(KEY_ENG_PREVIEW_ISP_GAIN, 0);
         }
 
         /**
-         * Gets the exposure compensation step.
+         * @hide
+         *
+         * Get preview AE PLine index
          *
-         * @return exposure compensation step. Applications can get EV by
-         *         multiplying the exposure compensation index and step. Ex: if
-         *         exposure compensation index is -6 and step is 0.333333333, EV
-         *         is -2.
          */
-        public float getExposureCompensationStep() {
-            return getFloat(KEY_EXPOSURE_COMPENSATION_STEP, 0);
+        public int getEngPreviewAEIndex() {
+            return getInt(KEY_ENG_PREVIEW_AE_INDEX, 0);
         }
 
         /**
-         * <p>Sets the auto-exposure lock state. Applications should check
-         * {@link #isAutoExposureLockSupported} before using this method.</p>
-         *
-         * <p>If set to true, the camera auto-exposure routine will immediately
-         * pause until the lock is set to false. Exposure compensation settings
-         * changes will still take effect while auto-exposure is locked.</p>
+         * @hide
          *
-         * <p>If auto-exposure is already locked, setting this to true again has
-         * no effect (the driver will not recalculate exposure values).</p>
+         * Get capture sensor gain in preview
          *
-         * <p>Stopping preview with {@link #stopPreview()}, or triggering still
-         * image capture with {@link #takePicture(Camera.ShutterCallback,
-         * Camera.PictureCallback, Camera.PictureCallback)}, will not change the
-         * lock.</p>
+         */
+        public int getEngCaptureSensorGain() {
+            return getInt(KEY_ENG_CAPTURE_SENSOR_GAIN, 0);
+        }
+
+        /**
+         * @hide
          *
-         * <p>Exposure compensation, auto-exposure lock, and auto-white balance
-         * lock can be used to capture an exposure-bracketed burst of images,
-         * for example.</p>
+         * Get capture isp gain in preview
          *
-         * <p>Auto-exposure state, including the lock state, will not be
-         * maintained after camera {@link #release()} is called.  Locking
-         * auto-exposure after {@link #open()} but before the first call to
-         * {@link #startPreview()} will not allow the auto-exposure routine to
-         * run at all, and may result in severely over- or under-exposed
-         * images.</p>
+         */
+        public int getEngCaptureISPGain() {
+            return getInt(KEY_ENG_CAPTURE_ISP_GAIN, 0);
+        }
+
+        /**
+         * @hide
          *
-         * @param toggle new state of the auto-exposure lock. True means that
-         *        auto-exposure is locked, false means that the auto-exposure
-         *        routine is free to run normally.
+         * Get capture shutter speed in preview
          *
-         * @see #getAutoExposureLock()
          */
-        public void setAutoExposureLock(boolean toggle) {
-            set(KEY_AUTO_EXPOSURE_LOCK, toggle ? TRUE : FALSE);
+        public int getEngCaptureShutterSpeed() {
+            return getInt(KEY_ENG_CAPTURE_SHUTTER_SPEED, 0);
         }
 
         /**
-         * Gets the state of the auto-exposure lock. Applications should check
-         * {@link #isAutoExposureLockSupported} before using this method. See
-         * {@link #setAutoExposureLock} for details about the lock.
-         *
-         * @return State of the auto-exposure lock. Returns true if
-         *         auto-exposure is currently locked, and false otherwise.
+         * @hide
          *
-         * @see #setAutoExposureLock(boolean)
+         * Get capture iso after capture
          *
          */
-        public boolean getAutoExposureLock() {
-            String str = get(KEY_AUTO_EXPOSURE_LOCK);
-            return TRUE.equals(str);
+        public int getEngCaptureISO() {
+            return getInt(KEY_ENG_CAPTURE_ISO, 0);
         }
 
         /**
-         * Returns true if auto-exposure locking is supported. Applications
-         * should call this before trying to lock auto-exposure. See
-         * {@link #setAutoExposureLock} for details about the lock.
+         * @hide
          *
-         * @return true if auto-exposure lock is supported.
-         * @see #setAutoExposureLock(boolean)
+         * Get flash duty minimax value
          *
          */
-        public boolean isAutoExposureLockSupported() {
-            String str = get(KEY_AUTO_EXPOSURE_LOCK_SUPPORTED);
-            return TRUE.equals(str);
+        public int getEngFlashDutyMin() {
+            return getInt(KEY_ENG_FLASH_DUTY_MIN, 0);
         }
 
         /**
-         * <p>Sets the auto-white balance lock state. Applications should check
-         * {@link #isAutoWhiteBalanceLockSupported} before using this
-         * method.</p>
-         *
-         * <p>If set to true, the camera auto-white balance routine will
-         * immediately pause until the lock is set to false.</p>
+         * @hide
          *
-         * <p>If auto-white balance is already locked, setting this to true
-         * again has no effect (the driver will not recalculate white balance
-         * values).</p>
+         * Get flash duty maximum value
          *
-         * <p>Stopping preview with {@link #stopPreview()}, or triggering still
-         * image capture with {@link #takePicture(Camera.ShutterCallback,
-         * Camera.PictureCallback, Camera.PictureCallback)}, will not change the
-         * the lock.</p>
+         */
+        public int getEngFlashDutyMax() {
+            return getInt(KEY_ENG_FLASH_DUTY_MAX, 0);
+        }
+
+        /**
+         * @hide
          *
-         * <p> Changing the white balance mode with {@link #setWhiteBalance}
-         * will release the auto-white balance lock if it is set.</p>
+         * Get preview FPS
          *
-         * <p>Exposure compensation, AE lock, and AWB lock can be used to
-         * capture an exposure-bracketed burst of images, for example.
-         * Auto-white balance state, including the lock state, will not be
-         * maintained after camera {@link #release()} is called.  Locking
-         * auto-white balance after {@link #open()} but before the first call to
-         * {@link #startPreview()} will not allow the auto-white balance routine
-         * to run at all, and may result in severely incorrect color in captured
-         * images.</p>
+         */
+        public int getEngPreviewFPS() {
+            return getInt(KEY_ENG_PREVIEW_FPS, 0);
+        }
+
+        /**
+         * @hide
          *
-         * @param toggle new state of the auto-white balance lock. True means
-         *        that auto-white balance is locked, false means that the
-         *        auto-white balance routine is free to run normally.
+         * Get flash duty maximum value
          *
-         * @see #getAutoWhiteBalanceLock()
-         * @see #setWhiteBalance(String)
          */
-        public void setAutoWhiteBalanceLock(boolean toggle) {
-            set(KEY_AUTO_WHITEBALANCE_LOCK, toggle ? TRUE : FALSE);
+        public String getEngEngMSG() {
+            return get(KEY_ENG_MSG);
         }
 
         /**
-         * Gets the state of the auto-white balance lock. Applications should
-         * check {@link #isAutoWhiteBalanceLockSupported} before using this
-         * method. See {@link #setAutoWhiteBalanceLock} for details about the
-         * lock.
-         *
-         * @return State of the auto-white balance lock. Returns true if
-         *         auto-white balance is currently locked, and false
-         *         otherwise.
+         * @hide
          *
-         * @see #setAutoWhiteBalanceLock(boolean)
+         * Set frame interval in focus full scan in engineer mode
+         */
+        public void setEngFocusFullScanFrameInterval(int n) {
+            set(KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL, n);
+        }
+
+        /**
+         * @hide
          *
+         * Get max frame interval in focus full scan in engineer mode
          */
-        public boolean getAutoWhiteBalanceLock() {
-            String str = get(KEY_AUTO_WHITEBALANCE_LOCK);
-            return TRUE.equals(str);
+        public int getEngFocusFullScanFrameIntervalMax() {
+            return getInt(KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX, 0);
         }
 
         /**
-         * Returns true if auto-white balance locking is supported. Applications
-         * should call this before trying to lock auto-white balance. See
-         * {@link #setAutoWhiteBalanceLock} for details about the lock.
+         * @hide
          *
-         * @return true if auto-white balance lock is supported.
-         * @see #setAutoWhiteBalanceLock(boolean)
+         * Get min frame interval in focus full scan in engineer mode
+         */
+        public int getEngFocusFullScanFrameIntervalMin() {
+            return getInt(KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN, 0);
+        }
+
+        /**
+         * @hide
          *
+         * Get preview frame interval in us in engineer mode
          */
-        public boolean isAutoWhiteBalanceLockSupported() {
-            String str = get(KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED);
-            return TRUE.equals(str);
+        public int getEngPreviewFrameIntervalInUS() {
+            return getInt(KEY_ENG_PREVIEW_FRAME_INTERVAL_IN_US, 0);
         }
 
         /**
-         * Gets current zoom value. This also works when smooth zoom is in
-         * progress. Applications should check {@link #isZoomSupported} before
-         * using this method.
+         * @hide
          *
-         * @return the current zoom value. The range is 0 to {@link
-         *         #getMaxZoom}. 0 means the camera is not zoomed.
+         * Set parameter 1 in engineer mode
          */
-        public int getZoom() {
-            return getInt(KEY_ZOOM, 0);
+        public void setEngParameter1(String value) {
+            set(KEY_ENG_PARAMETER1, value);
         }
 
         /**
-         * Sets current zoom value. If the camera is zoomed (value > 0), the
-         * actual picture size may be smaller than picture size setting.
-         * Applications can check the actual picture size after picture is
-         * returned from {@link PictureCallback}. The preview size remains the
-         * same in zoom. Applications should check {@link #isZoomSupported}
-         * before using this method.
+         * @hide
          *
-         * @param value zoom value. The valid range is 0 to {@link #getMaxZoom}.
+         * Set parameter 2 in engineer mode
          */
-        public void setZoom(int value) {
-            set(KEY_ZOOM, value);
+        public void setEngParameter2(String value) {
+            set(KEY_ENG_PARAMETER2, value);
         }
 
         /**
-         * Returns true if zoom is supported. Applications should call this
-         * before using other zoom methods.
+         * @hide
          *
-         * @return true if zoom is supported.
+         * Set parameter 3 in engineer mode
          */
-        public boolean isZoomSupported() {
-            String str = get(KEY_ZOOM_SUPPORTED);
-            return TRUE.equals(str);
+        public void setEngParameter3(String value) {
+            set(KEY_ENG_PARAMETER3, value);
         }
 
         /**
-         * Gets the maximum zoom value allowed for snapshot. This is the maximum
-         * value that applications can set to {@link #setZoom(int)}.
-         * Applications should call {@link #isZoomSupported} before using this
-         * method. This value may change in different preview size. Applications
-         * should call this again after setting preview size.
+         * @hide
          *
-         * @return the maximum zoom value supported by the camera.
+         * Save shading table or not in engineer mode
          */
-        public int getMaxZoom() {
-            return getInt(KEY_MAX_ZOOM, 0);
+        public void setEngSaveShadingTable(int save) {
+            set(KEY_ENG_SAVE_SHADING_TABLE, save);
         }
 
         /**
-         * Gets the zoom ratios of all zoom values. Applications should check
-         * {@link #isZoomSupported} before using this method.
+         * @hide
          *
-         * @return the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
-         *         returned as 320. The number of elements is {@link
-         *         #getMaxZoom} + 1. The list is sorted from small to large. The
-         *         first element is always 100. The last element is the zoom
-         *         ratio of the maximum zoom value.
+         * Specify shading table in engineer mode
          */
-        public List<Integer> getZoomRatios() {
-            return splitInt(get(KEY_ZOOM_RATIOS));
+        public void setEngShadingTable(int shading_table) {
+            set(KEY_ENG_SHADING_TABLE, shading_table);
+        }
+
+         /**
+         * @hide
+         *
+         * Get in engineer mode
+         */
+        public int getEngEVCalOffset() {
+            return getInt(KEY_ENG_EV_CALBRATION_OFFSET_VALUE, 0);
         }
 
         /**
-         * Returns true if smooth zoom is supported. Applications should call
-         * this before using other smooth zoom methods.
+         * @hide
          *
-         * @return true if smooth zoom is supported.
+         * Sets the MATV preview delay time (ms)
          */
-        public boolean isSmoothZoomSupported() {
-            String str = get(KEY_SMOOTH_ZOOM_SUPPORTED);
-            return TRUE.equals(str);
+        public void setMATVDelay(int ms) {
+            set(KEY_MATV_PREVIEW_DELAY, ms);
+        }
+
+        // Add for Stereo3D Start
+        /**
+         * @hide
+         */
+        public String getStereo3DType() {
+            return get((mStereo3DMode ? KEY_STEREO3D_PRE : "") + KEY_STEREO3D_TYPE);
+        }
+        /**
+         * @hide
+         * @param value: stereo3d_mode:true or false
+         */
+        public void setStereo3DMode(boolean enable) {
+            mStereo3DMode = enable;
+        }
+        // Add for Stereo3D End
+        /**
+         * @hide
+         */
+        public void setContinuousSpeedMode(String value) {
+            set(KEY_CONTINUOUS_SPEED_MODE, value);
+        }
+        //!--
+        /**
+         * @hide
+         * @return the ZSD mode
+         * get the ZSD mode
+         */
+        public String getZSDMode() {
+            return get(KEY_ZSD_MODE);
+        }
+        /**
+         * @hide
+         * Sets ZSD mode on/off
+         * @param value "on" or "off"
+         */
+        public void setZSDMode(String value) {
+            set(KEY_ZSD_MODE, value);
+        }
+        /**
+         * @hide
+         * @return the supported ZSD mode
+         * get all supported ZSD mode
+         */
+        public List<String> getSupportedZSDMode() {
+            String str = get(KEY_ZSD_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
         }
 
         /**
@@ -4308,6 +6475,28 @@ public class Camera {
             return TRUE.equals(str);
         }
 
+        /**
+         * <p>Returns true if pdaf is supported.</p>
+         *
+         * @hide
+         * @return true if pdaf is supported.
+         */
+        public boolean isPdafSupported() {
+            String str = get(KEY_PDAF_SUPPORTED);
+            return TRUE.equals(str);
+        }
+
+    /**
+         * <p>Whether the recording sound can be disabled.</p>
+         *
+         * @hide
+         */
+        public void enableRecordingSound(String value) {
+            if (value.equals("1") || value.equals("0")) {
+                set(KEY_MUTE_RECORDING_SOUND, value);
+            }
+        }
+
         /**
          * <p>Enables and disables video stabilization. Use
          * {@link #isVideoStabilizationSupported} to determine if calling this
@@ -4357,6 +6546,108 @@ public class Camera {
             String str = get(KEY_VIDEO_STABILIZATION_SUPPORTED);
             return TRUE.equals(str);
         }
+    /**
+         * <p>Get pip max frame rate when zsd on.</p>
+         *
+         * @hide
+         */
+        public List<Integer> getPIPFrameRateZSDOn() {
+            String str = get(KEY_MAX_FRAME_RATE_ZSD_ON);
+            return splitInt(str);
+        }
+       /**
+         * <p>Get pip max frame rate when zsd off.</p>
+         *
+         * @hide
+         */
+        public List<Integer> getPIPFrameRateZSDOff() {
+            String str = get(KEY_MAX_FRAME_RATE_ZSD_OFF);
+            return splitInt(str);
+        }
+       /**
+         * Get the dynamic frame rate. return true or false
+         * @hide
+         */
+        public boolean getDynamicFrameRate() {
+            String str = get(KEY_DYNAMIC_FRAME_RATE);
+            return TRUE.equals(str);
+        }
+       /**
+         * set the dynamic frame rate.
+         * @hide
+         */
+        public void setDynamicFrameRate(boolean toggle) {
+            set(KEY_DYNAMIC_FRAME_RATE, toggle ? TRUE : FALSE);
+        }
+        /**
+         * Returns true if dynamic frame rate is supported
+         * @hide
+         */
+        public boolean isDynamicFrameRateSupported() {
+            String str = get(KEY_DYNAMIC_FRAME_RATE_SUPPORTED);
+            return TRUE.equals(str);
+        }
+       /**
+         * <p>set image reforcus jps's fine name.</p>
+         *
+         * @hide
+         */
+        public void setRefocusJpsFileName(String fineName) {
+            set(KEY_REFOCUS_JPS_FILE_NAME, fineName);
+        }
+
+        /**
+         * set image reforcus switch.</p>
+         *
+         * @hide
+         */
+        public void setRefocusMode(boolean toggle) {
+            set(KEY_STEREO_REFOCUS_MODE, toggle ? ON : OFF);
+        }
+
+        /**
+         * get image reforcus switch.</p>
+         *
+         * @hide
+         */
+        public String getRefocusMode() {
+            return get(KEY_STEREO_REFOCUS_MODE);
+        }
+
+        /**
+         * set Depth AF switch.</p>
+         *
+         * @hide
+         */
+        public void setDepthAFMode(boolean toggle) {
+            set(KEY_STEREO_DEPTHAF_MODE, toggle ? ON : OFF);
+        }
+        /**
+         * get Depth AF switch.</p>
+         *@hide
+         *
+         */
+        public String getDepthAFMode() {
+            return get(KEY_STEREO_DEPTHAF_MODE);
+        }
+
+        /**
+         * set Distance Info.</p>
+         *@hide
+         *
+         */
+        public void setDistanceMode(boolean toggle) {
+            set(KEY_STEREO_DISTANCE_MODE, toggle ? ON : OFF);
+        }
+
+        /**
+         * get Distance Info.</p>
+         *@hide
+         * @hide
+         */
+        public String getDistanceMode() {
+            return get(KEY_STEREO_DISTANCE_MODE);
+        }
 
         // Splits a comma delimited string to an ArrayList of String.
         // Return null if the passing string is null or the size is 0.
@@ -5549,9 +7840,11 @@ public class Camera {
          *
          * @return null
          */
+	 /*
          public void setCameraMode(int cameraMode) {
            set(KEY_QC_CAMERA_MODE, cameraMode);
          }
+	 */
 
          private static final int MANUAL_FOCUS_POS_TYPE_INDEX = 0;
          private static final int MANUAL_FOCUS_POS_TYPE_DAC = 1;
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
index 42b10c4f..39bb3782 100644
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -263,6 +263,11 @@ LOCAL_SHARED_LIBRARIES += \
     libhwui \
     libdl
 
+ifeq ($(MTK_HARDWARE),true)
+LOCAL_C_INCLUDES += $(MTK_PATH_SOURCE)/hardware/mtkcam/ext/include
+LOCAL_SHARED_LIBRARIES += libmtkcamera_client
+endif
+
 # we need to access the private Bionic header
 # <bionic_tls.h> in com_google_android_gles_jni_GLImpl.cpp
 LOCAL_C_INCLUDES += bionic/libc/private
diff --git a/core/jni/android_hardware_Camera.cpp b/core/jni/android_hardware_Camera.cpp
index 4cf317ef..c102d851 100644
--- a/core/jni/android_hardware_Camera.cpp
+++ b/core/jni/android_hardware_Camera.cpp
@@ -34,6 +34,14 @@
 #include <camera/Camera.h>
 #include <binder/IMemory.h>
 
+#ifdef MTK_HARDWARE
+// Add MTK header
+#include <camera/MtkCamera.h>
+#include <camera/IMetadataCallbacks.h>
+#include <android_runtime/android_hardware_camera2_CameraMetadata.h>
+class MetadataCallbacksImp;
+#endif
+
 using namespace android;
 
 enum {
@@ -97,6 +105,9 @@ public:
     void release();
 
 private:
+#ifdef MTK_HARDWARE
+protected: // MtkJNICameraContext need inheritance these info from JNICameraContext, so here need declare as protected member.
+#endif
     void copyAndPost(JNIEnv* env, const sp<IMemory>& dataPtr, int msgType);
     void clearCallbackBuffers_l(JNIEnv *env, Vector<jbyteArray> *buffers);
     void clearCallbackBuffers_l(JNIEnv *env);
@@ -131,6 +142,114 @@ private:
                                          // reduce unnecessary calls to set the callback.
 };
 
+#ifdef MTK_HARDWARE
+// MtkJNICameraContext is used for MTK camera feature.
+class MtkJNICameraContext : public JNICameraContext
+{
+public:
+                    ~MtkJNICameraContext();
+                    MtkJNICameraContext(JNIEnv* env, jobject weak_this, jclass clazz, const sp<Camera>& camera);
+    virtual void    postData(int32_t msgType, const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+    //
+    void initMetadataCallback();
+    sp<MetadataCallbacksImp> getMetadataCallback() { Mutex::Autolock _l(mLock); return mMetadataCallback; }
+
+protected:
+    void            copyAndPostExtData(JNIEnv* env, const sp<IMemory>& dataPtr, int msgType);
+    //
+    sp<MetadataCallbacksImp> mMetadataCallback;
+};
+
+class MetadataCallbacksImp : public BnMetadataCallbacks
+{
+public:
+    MetadataCallbacksImp(MtkJNICameraContext* context):hasSetCallback(false), m_context(context) {};
+    /*IMetadataCallbacks interface*/
+    void onMetadataReceived(CameraMetadata& result,
+                               CameraMetadata& characteristic);
+    /*called by java to get metadata*/
+    void getMetadata(JNIEnv *env, jobject thiz, jobject resultMetadataObj, jobject staticMetadataObj);
+
+    Vector<CameraMetadata> resultVector;
+    Vector<CameraMetadata> characteristicVector;
+    bool hasSetCallback;
+    wp<JNICameraContext> m_context;
+    Mutex mVectorLock;
+    Mutex mGetMetaLock;
+};
+
+MtkJNICameraContext::MtkJNICameraContext(JNIEnv* env, jobject weak_this, jclass clazz, const sp<Camera>& camera)
+    : JNICameraContext(env, weak_this, clazz, camera)
+{
+    mMetadataCallback = new MetadataCallbacksImp(this);
+    ALOGD("(tid:%d)[MtkJNICameraContext] this:%p camera->getStrongCount(%d) \n", ::gettid(), this, camera->getStrongCount());
+}
+
+MtkJNICameraContext::~MtkJNICameraContext()
+{
+    ALOGD("(tid:%d)[~MtkJNICameraContext] this:%p \n", ::gettid(), this);
+}
+
+void MtkJNICameraContext::postData(int32_t msgType, const sp<IMemory>& dataPtr,
+                                camera_frame_metadata_t *metadata)
+{
+    int32_t dataMsgType = msgType & ~CAMERA_MSG_PREVIEW_METADATA;
+    if  ( (int32_t)MTK_CAMERA_MSG_EXT_DATA == dataMsgType ) {
+        // VM pointer will be NULL if object is released
+        Mutex::Autolock _l(mLock);
+        JNIEnv *env = AndroidRuntime::getJNIEnv();
+        if (mCameraJObjectWeak == NULL) {
+            ALOGW("callback on dead camera object");
+            return;
+        }
+        copyAndPostExtData(env, dataPtr, dataMsgType);
+        // post frame metadata to Java
+        if (metadata && (msgType & CAMERA_MSG_PREVIEW_METADATA)) {
+            postMetadata(env, CAMERA_MSG_PREVIEW_METADATA, metadata);
+        }
+    }
+    else {
+        JNICameraContext::postData(msgType, dataPtr, metadata);
+    }
+}
+
+
+void MtkJNICameraContext::copyAndPostExtData(JNIEnv* env, const sp<IMemory>& dataPtr, int msgType)
+{
+    jbyteArray obj = NULL;
+    uint32_t extMsgType = 0;
+
+    // allocate Java byte array and copy data
+    //
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( MtkExtDataHelper.init(dataPtr) )
+    {
+        const jbyte* data = reinterpret_cast<const jbyte*>(MtkExtDataHelper.getExtParamBase());
+        const size_t size = MtkExtDataHelper.getExtParamSize();
+        const MtkCamMsgExtDataHelper::DataHeader extDataHeader = MtkExtDataHelper.getExtDataHeader();
+        extMsgType = extDataHeader.extMsgType;
+
+        ALOGV("[copyAndPostExtData] Allocating callback buffer");
+        obj = env->NewByteArray(size);
+        if (obj == NULL) {
+            ALOGE("[copyAndPostExtData] Couldn't allocate byte array");
+            env->ExceptionClear();
+        } else {
+            env->SetByteArrayRegion(obj, 0, size, data);
+        }
+
+        MtkExtDataHelper.uninit();
+    }
+
+    // post image data to Java
+    env->CallStaticVoidMethod(mCameraJClass, fields.post_event,
+            mCameraJObjectWeak, msgType, extMsgType, 0, obj);
+    if (obj) {
+        env->DeleteLocalRef(obj);
+    }
+}
+#endif
+
 bool JNICameraContext::isRawImageCallbackBufferAvailable() const
 {
     return !mRawImageCallbackBuffers.isEmpty();
@@ -154,6 +273,118 @@ sp<Camera> get_native_camera(JNIEnv *env, jobject thiz, JNICameraContext** pCont
     return camera;
 }
 
+#ifdef MTK_HARDWARE
+//Add MetadataCallbacks
+sp<MetadataCallbacksImp> get_native_MetadataCallback(JNIEnv *env, jobject thiz, JNICameraContext** pContext)
+{
+    sp<MetadataCallbacksImp> c;
+    Mutex::Autolock _l(sLock);
+    JNICameraContext* context = reinterpret_cast<JNICameraContext*>(env->GetLongField(thiz, fields.context));
+    if (context != NULL) {
+        c = reinterpret_cast<MtkJNICameraContext*>(context)->getMetadataCallback();
+    }
+
+    if (pContext != NULL) *pContext = context;
+    return c;
+}
+
+void MetadataCallbacksImp::onMetadataReceived(CameraMetadata& result,
+                                              CameraMetadata& characteristic)
+{
+    ALOGV("MetadataCallbacksImp::onMetadataReceived");
+
+    Mutex::Autolock _l(mGetMetaLock);
+    sp<JNICameraContext> context = m_context.promote();
+    if (context == NULL) return;
+
+    {
+        Mutex::Autolock _l(mVectorLock);
+        resultVector.add(result);
+        characteristicVector.add(characteristic);
+    }
+
+    context->notify(MTK_CAMERA_MSG_EXT_NOTIFY, MTK_CAMERA_MSG_EXT_NOTIFY_METADATA_DONE, 0);
+    context = NULL;
+
+}
+
+void setMetadataCallback(JNIEnv *env, jobject thiz, sp<IMetadataCallbacks>& cb)
+{
+    ALOGD("setMetadataCallback");
+
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) {
+        ALOGE("android_hardware_Camera_setMetadataCallback::setMetadataCallback fail");
+        return;
+    }
+
+    camera->setMetadataCallback(cb);
+}
+
+static void android_hardware_Camera_enableRaw16Callback(JNIEnv *env, jobject thiz, jboolean enable)
+{
+    JNICameraContext* context;
+    sp<Camera> camera = get_native_camera(env, thiz, &context);
+    if (camera == 0) return;
+
+    sp<MetadataCallbacksImp> c = get_native_MetadataCallback(env, thiz, NULL);
+    if(!c->hasSetCallback) {
+        sp<IMetadataCallbacks> IMetadataCallback = get_native_MetadataCallback(env, thiz, NULL);
+        setMetadataCallback(env, thiz, IMetadataCallback);
+        c->hasSetCallback = true;
+    }
+
+    if (enable) {
+        camera->sendCommand(CAMERA_CMD_ENABLE_RAW16_CALLBACK, 1, 0);
+    }
+    else {
+        camera->sendCommand(CAMERA_CMD_ENABLE_RAW16_CALLBACK, 0, 0);
+    }
+}
+
+static void android_hardware_Camera_getMetadata(JNIEnv *env, jobject thiz, jobject resultMetadataObj, jobject staticMetadataObj)
+{
+    ALOGV("android_hardware_Camera_getMetadata::getMetadata");
+    JNICameraContext* context;
+    sp<Camera> camera = get_native_camera(env, thiz, &context);
+    if (camera == 0) return;
+
+    MtkJNICameraContext* Mtkcontext = (MtkJNICameraContext*)context;
+    Mtkcontext->getMetadataCallback()->getMetadata(env, thiz, resultMetadataObj, staticMetadataObj);
+}
+
+void MetadataCallbacksImp::getMetadata(JNIEnv *env, jobject thiz, jobject resultMetadataObj, jobject staticMetadataObj)
+{
+    ALOGV("MtkJNICameraContext::getMetadata::getMetadata");
+
+    CameraMetadata resultMetadata;
+    CameraMetadata characteristicMetadata;
+    {
+        Mutex::Autolock _l(mVectorLock);
+        if (resultVector.empty() || characteristicVector.empty()) {
+            ALOGE("MtkJNICameraContext::getMetadata::getMetadata resultVector || characteristicVector empty");
+            return;
+        }
+        resultMetadata = resultVector.itemAt(0);
+        characteristicMetadata = characteristicVector.itemAt(0);
+        //
+        resultVector.removeAt(0);
+        characteristicVector.removeAt(0);
+    }
+    //
+    if (CameraMetadata_setNativeMetadata(env, resultMetadataObj, &resultMetadata) != OK) {
+         jniThrowException(env, "java/lang/AssertionError",
+                "MtkJNICameraContext::getMetadata No native metadata defined for destRseultMetadata");
+         return;
+    }
+    if (CameraMetadata_setNativeMetadata(env, staticMetadataObj, &characteristicMetadata) != OK) {
+         jniThrowException(env, "java/lang/AssertionError",
+                "MtkJNICameraContext::getMetadata No native metadata defined for destcharacteristicMetadata");
+         return;
+    }
+}
+#endif
+
 JNICameraContext::JNICameraContext(JNIEnv* env, jobject weak_this, jclass clazz, const sp<Camera>& camera)
 {
     mCameraJObjectWeak = env->NewGlobalRef(weak_this);
@@ -661,7 +892,11 @@ static jint android_hardware_Camera_native_setup(JNIEnv *env, jobject thiz,
 
     // We use a weak reference so the Camera object can be garbage collected.
     // The reference is only used as a proxy for callbacks.
+#ifdef MTK_HARDWARE
+    sp<JNICameraContext> context = new MtkJNICameraContext(env, weak_this, clazz, camera);
+#else
     sp<JNICameraContext> context = new JNICameraContext(env, weak_this, clazz, camera);
+#endif
     context->incStrong((void*)android_hardware_Camera_native_setup);
     camera->setListener(context);
 
@@ -693,8 +928,19 @@ static void android_hardware_Camera_release(JNIEnv *env, jobject thiz)
         context->release();
         ALOGV("native_release: context=%p camera=%p", context, camera.get());
 
+#ifdef MTK_HARDWARE
+        //!++
+        ALOGD("(tid:%d)[native_release] + context=%p camera=%p \n", ::gettid(), context, camera.get()); //Add debug log
+        //!--
+#endif
+
         // clear callbacks
         if (camera != NULL) {
+#ifdef MTK_HARDWARE
+            //!++
+            ALOGD("[native_release] context->getStrongCount(%d) camera->getStrongCount(%d) \n", context->getStrongCount(), camera->getStrongCount()); //Add debug log
+            //!--
+#endif
             camera->setPreviewCallbackFlags(CAMERA_FRAME_CALLBACK_FLAG_NOOP);
             camera->disconnect();
         }
@@ -702,6 +948,11 @@ static void android_hardware_Camera_release(JNIEnv *env, jobject thiz)
         // remove context to prevent further Java access
         context->decStrong((void*)android_hardware_Camera_native_setup);
     }
+#ifdef MTK_HARDWARE
+    //!++
+    ALOGD("(tid:%d)[release camera] - X context=%p \n", ::gettid(), context); //Add debug log
+    //!--
+#endif
 }
 
 static void android_hardware_Camera_setPreviewSurface(JNIEnv *env, jobject thiz, jobject jSurface)
@@ -1077,6 +1328,242 @@ static void android_hardware_Camera_sendVendorCommand(JNIEnv *env, jobject thiz,
     }
 }
 
+#ifdef MTK_HARDWARE
+// Add MTK JNI
+static jstring android_hardware_Camera_getProperty(JNIEnv *env, jobject thiz, jstring keyJ, jstring defJ)
+{
+    String8 s8key;
+    String8 s8val;
+    jstring rvJ = NULL;
+
+    if  (keyJ != NULL) {
+        const jchar* key = env->GetStringCritical(keyJ, 0);
+        s8key = String8(reinterpret_cast<const char16_t*>(key), env->GetStringLength(keyJ));
+        env->ReleaseStringCritical(keyJ, key);
+    }
+    else {
+        jniThrowNullPointerException(env, "key must not be null.");
+        return rvJ;
+    }
+
+    status_t status = Camera::getProperty(s8key, s8val);
+    if  ( OK == status && (s8val.length() > 0) ) {
+        rvJ = env->NewStringUTF(s8val.string());
+    } else if (defJ != NULL) {
+        rvJ = defJ;
+    } else {
+        rvJ = env->NewStringUTF("");
+    }
+
+    return rvJ;
+}
+
+static void android_hardware_Camera_setProperty(JNIEnv *env, jobject thiz, jstring keyJ, jstring valJ)
+{
+    String8 s8key;
+    String8 s8val;
+
+    if  (keyJ != NULL) {
+        const jchar* key = env->GetStringCritical(keyJ, 0);
+        s8key = String8(reinterpret_cast<const char16_t*>(key), env->GetStringLength(keyJ));
+        env->ReleaseStringCritical(keyJ, key);
+    }
+    else {
+        jniThrowNullPointerException(env, "key must not be null.");
+        return;
+    }
+
+    if (valJ != NULL) {
+        const jchar* val = env->GetStringCritical(valJ, 0);
+        s8val = String8(reinterpret_cast<const char16_t*>(val), env->GetStringLength(valJ));
+        env->ReleaseStringCritical(valJ, val);
+    }
+
+    status_t status = Camera::setProperty(s8key, s8val);
+    if  ( OK != status ) {
+        jniThrowException(env, "java/lang/RuntimeException",
+                          "failed to setProperty");
+    }
+}
+
+static void android_hardware_Camera_doPanorama(JNIEnv *env, jobject thiz, jint value)
+{
+    ALOGV("doPanorama");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_DO_PANORAMA, value, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "doPanorama failed");
+    }
+}
+
+static void android_hardware_Camera_cancelPanorama(JNIEnv *env, jobject thiz)
+{
+    ALOGV("cancelPanorama");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_CANCEL_PANORAMA, 0, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "cancelPanorama failed");
+    }
+}
+
+static void android_hardware_Camera_startSDPreview(JNIEnv *env, jobject thiz)
+{
+    ALOGV("startSDPreview");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_START_SD_PREVIEW, 0, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "startSDPreview failed");
+    }
+}
+
+static void android_hardware_Camera_cancelSDPreview(JNIEnv *env, jobject thiz)
+{
+    ALOGV("cancelSDPreview");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_CANCEL_SD_PREVIEW, 0, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "cancelSDPreview failed");
+    }
+}
+
+static void android_hardware_Camera_startGDPreview(JNIEnv *env, jobject thiz)
+{
+    ALOGV("startGDPreview");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_START_GD_PREVIEW, 0, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "startGDPreview failed");
+    }
+}
+
+static void android_hardware_Camera_cancelGDPreview(JNIEnv *env, jobject thiz)
+{
+    ALOGV("cancelGDPreview");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_CANCEL_GD_PREVIEW, 0, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "cancelGDPreview failed");
+    }
+}
+
+static void android_hardware_Camera_setMainFace(JNIEnv *env, jobject thiz, jint xvalue, jint yvalue)
+{
+    ALOGV("setMainFace");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_SET_MAIN_FACE_COORDINATE, xvalue, yvalue) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "setMainFace failed");
+    }
+}
+
+static void android_hardware_Camera_cancelMainFace(JNIEnv *env, jobject thiz)
+{
+    ALOGV("cancelMainFace");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_CANCEL_MAIN_FACE, 0, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "cancelMainFace failed");
+    }
+}
+
+static void android_hardware_Camera_startOT(JNIEnv *env, jobject thiz, jint xvalue, jint yvalue)
+{
+    ALOGV("startOT");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_START_OT, xvalue, yvalue) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "startOT failed");
+    }
+}
+
+static void android_hardware_Camera_stopOT(JNIEnv *env, jobject thiz)
+{
+    ALOGV("stopOT");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_STOP_OT, 0, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "stopOT failed");
+    }
+}
+
+static void android_hardware_Camera_stopAUTORAMA(JNIEnv *env, jobject thiz, jint value)
+{
+    ALOGV("stopAUTORAMA");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_STOP_AUTORAMA, value, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "stopAUTORAMA failed");
+    }
+}
+
+static void android_hardware_Camera_startAUTORAMA(JNIEnv *env, jobject thiz, jint value)
+{
+    ALOGV("startAUTORAMA");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_START_AUTORAMA, value, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "startAUTORAMA failed");
+    }
+}
+
+static void android_hardware_Camera_cancelContinuousShot(JNIEnv *env, jobject thiz)
+{
+    ALOGV("cancel ContinuousShot");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_CANCEL_CSHOT, 0, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "cancel ContinuousShot failed");
+    }
+}
+
+static void android_hardware_Camera_setContinuousShotSpeed(JNIEnv *env, jobject thiz, jint value)
+{
+    ALOGV("setContinuousShotSpeed");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_SET_CSHOT_SPEED, value, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "setContinuousShotSpeed failed");
+    }
+}
+
+static void android_hardware_Camera_stop3DSHOT(JNIEnv *env, jobject thiz, jint value)
+{
+    ALOGV("stop3dshot");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_STOP_3DSHOT, value, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "stop3dshot failed");
+    }
+}
+
+static void android_hardware_Camera_start3DSHOT(JNIEnv *env, jobject thiz, jint value)
+{
+    ALOGV("start3dshot");
+    sp<Camera> camera = get_native_camera(env, thiz, NULL);
+    if (camera == 0) return;
+
+    if (camera->sendCommand(CAMERA_CMD_START_3DSHOT, value, 0) != NO_ERROR) {
+        jniThrowException(env, "java/lang/RuntimeException", "start3dshot failed");
+    }
+}
+#endif
+
+
 //-------------------------------------------------
 
 static JNINativeMethod camMethods[] = {
@@ -1179,6 +1666,71 @@ static JNINativeMethod camMethods[] = {
   { "_sendVendorCommand",
     "(III)V",
     (void *)android_hardware_Camera_sendVendorCommand },
+
+#ifdef MTK_HARDWARE
+  //Add MTK JNI
+  { "native_getProperty",
+    "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
+    (void*) android_hardware_Camera_getProperty },
+  { "native_setProperty",
+    "(Ljava/lang/String;Ljava/lang/String;)V",
+    (void*) android_hardware_Camera_setProperty },
+  { "doPanorama",
+    "(I)V",
+    (void *)android_hardware_Camera_doPanorama },
+  { "cancelPanorama",
+    "()V",
+    (void *)android_hardware_Camera_cancelPanorama },
+  { "startSDPreview",
+    "()V",
+    (void *)android_hardware_Camera_startSDPreview },
+  { "cancelSDPreview",
+    "()V",
+    (void *)android_hardware_Camera_cancelSDPreview },
+  { "startGDPreview",
+    "()V",
+    (void *)android_hardware_Camera_startGDPreview },
+  { "cancelGDPreview",
+    "()V",
+    (void *)android_hardware_Camera_cancelGDPreview },
+  { "setMainFace",
+    "(II)V",
+   (void *)android_hardware_Camera_setMainFace },
+  { "cancelMainFace",
+    "()V",
+   (void *)android_hardware_Camera_cancelMainFace },
+  { "startOT",
+    "(II)V",
+   (void *)android_hardware_Camera_startOT },
+  { "stopOT",
+    "()V",
+   (void *)android_hardware_Camera_stopOT },
+  { "stopAUTORAMA",
+    "(I)V",
+    (void *)android_hardware_Camera_stopAUTORAMA },
+  { "startAUTORAMA",
+    "(I)V",
+    (void *)android_hardware_Camera_startAUTORAMA },
+  { "cancelContinuousShot",
+    "()V",
+    (void *)android_hardware_Camera_cancelContinuousShot },
+  { "setContinuousShotSpeed",
+    "(I)V",
+    (void *)android_hardware_Camera_setContinuousShotSpeed },
+  { "stop3DSHOT",
+    "(I)V",
+    (void *)android_hardware_Camera_stop3DSHOT },
+  { "start3DSHOT",
+    "(I)V",
+    (void *)android_hardware_Camera_start3DSHOT },
+  { "getMetadata",
+    "(Landroid/hardware/camera2/impl/CameraMetadataNative;Landroid/hardware/camera2/impl/CameraMetadataNative;)V",
+    (void *)android_hardware_Camera_getMetadata },
+  { "enableRaw16Callback",
+    "(Z)V",
+    (void *)android_hardware_Camera_enableRaw16Callback },
+#endif
+
 };
 
 struct field {
diff --git a/core/jni/android_hardware_camera2_CameraMetadata.cpp b/core/jni/android_hardware_camera2_CameraMetadata.cpp
index fb226891..1d20c728 100644
--- a/core/jni/android_hardware_camera2_CameraMetadata.cpp
+++ b/core/jni/android_hardware_camera2_CameraMetadata.cpp
@@ -100,6 +100,29 @@ status_t CameraMetadata_getNativeMetadata(JNIEnv* env, jobject thiz,
     return OK;
 }
 
+#ifdef MTK_HARDWARE
+status_t CameraMetadata_setNativeMetadata(JNIEnv* env, jobject thiz,
+        /*in*/CameraMetadata* metadata) {
+    if (!thiz) {
+        ALOGE("%s: Invalid java metadata object.", __FUNCTION__);
+        return BAD_VALUE;
+    }
+
+    if (!metadata) {
+        ALOGE("%s: Invalid output metadata object.", __FUNCTION__);
+        return BAD_VALUE;
+    }
+    CameraMetadata* nativePtr = reinterpret_cast<CameraMetadata*>(env->GetLongField(thiz,
+            fields.metadata_ptr));
+    if (nativePtr == NULL) {
+        ALOGE("%s: Invalid native pointer in java metadata object.", __FUNCTION__);
+        return BAD_VALUE;
+    }
+    nativePtr->acquire(*metadata);
+    return OK;
+}
+#endif
+
 } /*namespace android*/
 
 namespace {
diff --git a/include/android_runtime/android_hardware_camera2_CameraMetadata.h b/include/android_runtime/android_hardware_camera2_CameraMetadata.h
index 3c76ca5d..75dda335 100644
--- a/include/android_runtime/android_hardware_camera2_CameraMetadata.h
+++ b/include/android_runtime/android_hardware_camera2_CameraMetadata.h
@@ -29,6 +29,11 @@ namespace android {
 status_t CameraMetadata_getNativeMetadata(JNIEnv* env, jobject thiz,
                /*out*/CameraMetadata* metadata);
 
+#ifdef MTK_HARDWARE
+status_t CameraMetadata_setNativeMetadata(JNIEnv* env, jobject thiz,
+               /*in*/CameraMetadata* metadata);
+#endif
+
 } /*namespace android*/
 
 #endif /*ANDROID_HARDWARE_CAMERA2_CAMERAMETADATA_JNI_H*/
-- 
2.30.2

