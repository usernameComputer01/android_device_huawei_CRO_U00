From 71b9575a8eb3a65284f46fb2a307c49ea3958882 Mon Sep 17 00:00:00 2001
From: root <root@localhost.local>
Date: Wed, 15 Feb 2023 06:20:02 +0300
Subject: [PATCH] MTK AudioAPI-Common

Change-Id: I919e94dd435b911d53b7c0105ef2e0751a9392bd
---
 include/media/AudioSystem.h                   |   9 +
 include/media/IAudioFlinger.h                 |  12 +
 include/media/IAudioPolicyService.h           |   5 +
 media/libmedia/AudioSystem.cpp                | 115 ++++++
 media/libmedia/IAudioFlinger.cpp              | 193 +++++++++
 media/libmedia/IAudioPolicyService.cpp        |  29 ++
 services/audioflinger/AudioFlinger.cpp        | 170 ++++++++
 services/audioflinger/AudioFlinger.h          |  11 +
 services/audiopolicy/Android.mk               |  96 +++++
 services/audiopolicy/AudioPolicyInterface.h   |   9 +
 .../include/AudioPolicyVendorControl.h        |  37 ++
 .../interface/AudioPolicyManagerObserver.h    |  10 +
 services/audiopolicy/enginedefault/Android.mk |  24 ++
 .../audiopolicy/enginedefault/src/Engine.cpp  |   8 +
 .../managerdefault/AudioPolicyManager.cpp     | 381 ++++++++++++++++++
 .../managerdefault/AudioPolicyManager.h       |  44 ++
 .../service/AudioPolicyClientImpl.cpp         |  11 +
 .../service/AudioPolicyInterfaceImpl.cpp      |  16 +
 .../service/AudioPolicyService.cpp            |  48 +++
 .../audiopolicy/service/AudioPolicyService.h  |  45 +++
 20 files changed, 1273 insertions(+)
 create mode 100644 services/audiopolicy/common/managerdefinitions/include/AudioPolicyVendorControl.h

diff --git a/include/media/AudioSystem.h b/include/media/AudioSystem.h
index 3f4a610..b3f8887 100644
--- a/include/media/AudioSystem.h
+++ b/include/media/AudioSystem.h
@@ -453,6 +453,15 @@ private:
     static audio_channel_mask_t gPrevInChannelMask;
 
     static sp<IAudioPolicyService> gAudioPolicyService;
+#ifdef MTK_AUDIO
+public:
+    static status_t GetEMParameter(void *ptr,size_t len);
+    static status_t SetEMParameter(void *ptr,size_t len);
+    static status_t SetAudioCommand(int par1,int par2);
+    static status_t GetAudioCommand(int par1, int *par2);
+    static status_t SetAudioData(int par1,size_t len, void *ptr);
+    static status_t GetAudioData(int par1,size_t len,void *ptr);
+#endif
 };
 
 };  // namespace android
diff --git a/include/media/IAudioFlinger.h b/include/media/IAudioFlinger.h
index 5051aff..e0b5a67 100644
--- a/include/media/IAudioFlinger.h
+++ b/include/media/IAudioFlinger.h
@@ -246,6 +246,18 @@ public:
 
     /* Indicate JAVA services are ready (scheduling, power management ...) */
     virtual status_t systemReady() = 0;
+#ifdef MTK_AUDIO
+//<MTK_AUDIO_ADD
+    // Interfaces mtk added
+    // add , get EM parameter
+    virtual status_t GetEMParameter(void *ptr, size_t len) = 0;
+    virtual status_t SetEMParameter(void *ptr, size_t len) = 0;
+    virtual status_t SetAudioCommand(int parameters1, int parameter2) = 0;
+    virtual status_t GetAudioCommand(int parameters1) = 0;
+    virtual status_t SetAudioData(int par1,size_t len,void *ptr)=0;
+    virtual status_t GetAudioData(int par1,size_t len,void *ptr)=0;
+//MTK_AUDIO_ADD>
+#endif
 };
 
 
diff --git a/include/media/IAudioPolicyService.h b/include/media/IAudioPolicyService.h
index 9441861..1a05871 100644
--- a/include/media/IAudioPolicyService.h
+++ b/include/media/IAudioPolicyService.h
@@ -123,6 +123,11 @@ public:
     // bit rate, duration, video and streaming or offload property is enabled
     virtual bool isOffloadSupported(const audio_offload_info_t& info) = 0;
 
+#ifdef MTK_AUDIO
+//<MTK_AUDIO_ADD
+    virtual status_t SetPolicyManagerParameters(int par1,int par2 ,int par3,int par4) = 0;
+//MTK_AUDIO_ADD>
+#endif
     /* List available audio ports and their attributes */
     virtual status_t listAudioPorts(audio_port_role_t role,
                                     audio_port_type_t type,
diff --git a/media/libmedia/AudioSystem.cpp b/media/libmedia/AudioSystem.cpp
index 2e9fca9..ce9930b 100644
--- a/media/libmedia/AudioSystem.cpp
+++ b/media/libmedia/AudioSystem.cpp
@@ -26,6 +26,14 @@
 
 #include <system/audio.h>
 
+#ifdef MTK_AOSP_ENHANCEMENT
+#include <cutils/log.h>
+#endif
+#ifdef MTK_AUDIO
+#include <media/AudioParameter.h>
+#include <AudioPolicyParameters.h>
+#include <AudioMTKHardwareCommand.h>
+#endif
 // ----------------------------------------------------------------------------
 
 namespace android {
@@ -1276,4 +1284,111 @@ void AudioSystem::AudioPolicyServiceClient::binderDied(const wp<IBinder>& who __
     ALOGW("AudioPolicyService server died!");
 }
 
+#ifdef MTK_AUDIO
+//add , for EM mode
+status_t AudioSystem::GetEMParameter(void *ptr,size_t len)
+{
+#ifdef MTK_AUDIO
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0) return PERMISSION_DENIED;
+    return af->GetEMParameter(ptr,len);
+#endif
+    return OK;
+}
+
+status_t AudioSystem::SetEMParameter(void *ptr,size_t len)
+{
+#ifdef MTK_AUDIO
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0) return PERMISSION_DENIED;
+    return af->SetEMParameter(ptr,len);
+#endif
+}
+
+status_t AudioSystem::SetAudioCommand(int par1,int par2)
+{
+#ifdef MTK_AUDIO
+    status_t af_status;
+    ALOGD("AudioSystem::SetAudioCommand");
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0)
+    {
+        ALOGE("AudioSystem::SetAudioCommand Error!! PERMISSION_DENIED");
+        return PERMISSION_DENIED;
+    }
+    af_status = af->SetAudioCommand(par1,par2);
+
+    if (par1 == SET_LOAD_VOLUME_SETTING)
+    {
+        const sp<IAudioPolicyService>& aps = AudioSystem::get_audio_policy_service();
+        if(aps != 0)
+        {
+            aps->SetPolicyManagerParameters (POLICY_LOAD_VOLUME,0,0,0);
+        }
+    }
+
+    return af_status;
+
+#endif
+    return OK;
+}
+
+status_t AudioSystem::GetAudioCommand(int par1,int* par2)
+{
+#ifdef MTK_AUDIO
+    ALOGD("AudioSystem::GetAudioCommand");
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0)
+    {
+        ALOGE("AudioSystem::GetAudioCommand Error!! PERMISSION_DENIED");
+        return PERMISSION_DENIED;
+    }
+    *par2 =  af->GetAudioCommand(par1);
+#endif
+    return NO_ERROR;
+}
+
+status_t AudioSystem::SetAudioData(int par1,size_t byte_len,void *ptr)
+{
+#ifdef MTK_AUDIO
+    status_t af_status;
+    ALOGD("SetAudioData");
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0)
+    {
+        ALOGE("AudioSystem::SetAAudioData Error!! PERMISSION_DENIED");
+        return PERMISSION_DENIED;
+    }
+    af_status = af->SetAudioData(par1,byte_len,ptr);
+
+    if (par1 == SET_AUDIO_VER1_DATA)
+    {
+        const sp<IAudioPolicyService>& aps = AudioSystem::get_audio_policy_service();
+        if(aps != 0)
+        {
+            aps->SetPolicyManagerParameters (POLICY_LOAD_VOLUME,0,0,0);
+        }
+    }
+
+    return af_status;
+#endif
+    return OK;
+}
+
+status_t AudioSystem::GetAudioData(int par1,size_t byte_len,void *ptr)
+{
+#ifdef MTK_AUDIO
+    ALOGD("GetAudioData");
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0)
+    {
+        ALOGE("AudioSystem::GetAAudioData Error!! PERMISSION_DENIED");
+        return PERMISSION_DENIED;
+    }
+    return af->GetAudioData(par1,byte_len,ptr);
+#endif
+    return OK;
+}
+#endif // MTK_AUDIO
+
 } // namespace android
diff --git a/media/libmedia/IAudioFlinger.cpp b/media/libmedia/IAudioFlinger.cpp
index 0bf503a..889d4db 100644
--- a/media/libmedia/IAudioFlinger.cpp
+++ b/media/libmedia/IAudioFlinger.cpp
@@ -28,6 +28,10 @@
 
 namespace android {
 
+#ifdef MTK_AUDIO
+#define SET_AUDIO_DATA_MAX_LEN 16384
+#endif
+
 enum {
     CREATE_TRACK = IBinder::FIRST_CALL_TRANSACTION,
     OPEN_RECORD,
@@ -82,6 +86,15 @@ enum {
     SET_AUDIO_PORT_CONFIG,
     GET_AUDIO_HW_SYNC,
     SYSTEM_READY
+#ifdef MTK_AUDIO
+,
+    GET_EM_PARAMETER  = 0x7FFF0000,  //Don't call by CTS for security
+    SET_EM_PARAMETER,
+    SET_AUDIO_COMMAND,
+    GET_AUDIO_COMMAND,
+    SET_AUDIO_DATA,
+    GET_AUDIO_DATA,
+#endif
 };
 
 #define MAX_ITEMS_PER_LIST 1024
@@ -910,6 +923,91 @@ public:
         data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
         return remote()->transact(SYSTEM_READY, data, &reply, IBinder::FLAG_ONEWAY);
     }
+#ifdef MTK_AUDIO
+    virtual status_t GetEMParameter(void *ptr, size_t len)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(len);
+        data.write(ptr,len);
+        remote()->transact(GET_EM_PARAMETER, data, &reply);
+        reply.read(ptr, len);
+        return OK;
+    }
+    virtual status_t SetEMParameter(void *ptr, size_t len)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(len);
+        data.write(ptr,len);
+        remote()->transact(SET_EM_PARAMETER, data, &reply);
+        reply.read(ptr, len);
+        return OK;
+    }
+    virtual status_t SetAudioCommand(int var1,int var2)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(var1);
+        data.writeInt32(var2);
+        remote()->transact(SET_AUDIO_COMMAND, data, &reply);
+        return  reply.readInt32();
+    }
+    virtual status_t GetAudioCommand(int var1)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(var1);
+        remote()->transact(GET_AUDIO_COMMAND, data, &reply);
+        return  reply.readInt32();
+    }
+
+    virtual status_t SetAudioData(int par1, size_t len, void *ptr)
+    {
+        Parcel data, reply;
+        if (ptr == NULL || len > SET_AUDIO_DATA_MAX_LEN) {
+            return BAD_VALUE;
+        }
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(par1);
+        data.writeInt32(len);
+        if (len > 0) {
+            data.write(ptr, len);
+        }
+        status_t lStatus = remote()->transact(SET_AUDIO_DATA, data, &reply);
+        if (lStatus != NO_ERROR) {
+            ALOGE("SetAudioData error: %s", strerror(-lStatus));
+        } else {
+            if (len > 0) {
+                reply.read(ptr, len);
+            }
+        }
+        return reply.readInt32();
+    }
+
+    virtual status_t GetAudioData(int par1, size_t len, void *ptr)
+    {
+        Parcel data, reply;
+        if (ptr == NULL || len > SET_AUDIO_DATA_MAX_LEN) {
+            return BAD_VALUE;
+        }
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(par1);
+        data.writeInt32(len);
+        if (len > 0) {
+            data.write(ptr, len);
+        }
+        status_t lStatus = remote()->transact(GET_AUDIO_DATA, data, &reply);
+        if (lStatus != NO_ERROR) {
+            ALOGE("GetAudioData error: %s", strerror(-lStatus));
+        } else {
+            if (len > 0) {
+                reply.read(ptr, len);
+            }
+        }
+        return reply.readInt32();
+    }
+#endif
 };
 
 IMPLEMENT_META_INTERFACE(AudioFlinger, "android.media.IAudioFlinger");
@@ -1418,6 +1516,101 @@ status_t BnAudioFlinger::onTransact(
             systemReady();
             return NO_ERROR;
         } break;
+
+#ifdef MTK_AUDIO
+        // add by chipeng for EM mode Setting
+        case GET_EM_PARAMETER:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t size = data.readInt32();
+            void *params = malloc(size);
+            data.read(params, size);
+            status_t err = GetEMParameter(params,size);
+            if (err == NO_ERROR){
+                reply->write( params,size);
+            }
+            free(params);
+            return NO_ERROR;
+        }break;
+        case SET_EM_PARAMETER:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t size = data.readInt32();
+            void *params = malloc(size);
+            data.read(params, size);
+            status_t err = SetEMParameter(params,size);
+            if (err == NO_ERROR){
+                reply->write(params,size);
+            }
+            free(params);
+            return NO_ERROR;
+        }break;
+        case SET_AUDIO_COMMAND:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int32_t command1 = data.readInt32();
+            int32_t command2 = data.readInt32();
+            reply->writeInt32(SetAudioCommand(command1,command2));
+            return NO_ERROR;
+        }break;
+        case GET_AUDIO_COMMAND:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int32_t command1 = data.readInt32();
+            reply->writeInt32(GetAudioCommand(command1));
+            return NO_ERROR;
+        }break;
+        case SET_AUDIO_DATA: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t command = data.readInt32();
+            size_t buf_size = data.readInt32();
+            if (buf_size > SET_AUDIO_DATA_MAX_LEN) {
+                reply->writeInt32(BAD_VALUE);
+                return BAD_VALUE;
+            }
+            void *params = NULL;
+            if (buf_size > 0) {
+                params = malloc(buf_size);
+                if (params == NULL) {
+                    reply->writeInt32(BAD_VALUE);
+                    return BAD_VALUE;
+                }
+                data.read(params, buf_size);
+            }
+            status_t status = SetAudioData(command, buf_size, params);
+            if (params != NULL) {
+                reply->write(params, buf_size);
+                free(params);
+            }
+            reply->writeInt32(status);
+            return NO_ERROR;
+        } break;
+        case GET_AUDIO_DATA: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t command = data.readInt32();
+            size_t buf_size = data.readInt32();
+            if (buf_size > SET_AUDIO_DATA_MAX_LEN) {
+                reply->writeInt32(BAD_VALUE);
+                return BAD_VALUE;
+            }
+            void *params = NULL;
+            if (buf_size > 0) {
+                params = malloc(buf_size);
+                if (params == NULL) {
+                    reply->writeInt32(BAD_VALUE);
+                    return BAD_VALUE;
+                }
+                data.read(params, buf_size);
+            }
+            status_t status = GetAudioData(command, buf_size, params);
+            if (params != NULL) {
+                reply->write(params, buf_size);
+                free(params);
+            }
+            reply->writeInt32(status);
+            return NO_ERROR;
+        } break;
+#endif
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/media/libmedia/IAudioPolicyService.cpp b/media/libmedia/IAudioPolicyService.cpp
index 7a80bad..9aee530 100644
--- a/media/libmedia/IAudioPolicyService.cpp
+++ b/media/libmedia/IAudioPolicyService.cpp
@@ -73,6 +73,9 @@ enum {
     REGISTER_POLICY_MIXES,
     START_AUDIO_SOURCE,
     STOP_AUDIO_SOURCE,
+#ifdef MTK_AUDIO
+    SET_POLICYMANAGER_PARAMETERS,
+#endif
     SET_AUDIO_PORT_CALLBACK_ENABLED,
     LIST_AUDIO_SESSIONS,
 };
@@ -505,6 +508,21 @@ public:
         *count = retCount;
         return status;
     }
+//<MTK_AUDIO_ADD
+#ifdef MTK_AUDIO
+    virtual status_t SetPolicyManagerParameters(int par1,int par2 ,int par3,int par4)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioPolicyService::getInterfaceDescriptor());
+        data.writeInt32(par1);
+        data.writeInt32(par2);
+        data.writeInt32(par3);
+        data.writeInt32(par4);
+        remote()->transact(SET_POLICYMANAGER_PARAMETERS, data, &reply);
+        return static_cast <status_t> (reply.readInt32());
+    }
+#endif
+//MTK_AUDIO_ADD>
 
     virtual bool isOffloadSupported(const audio_offload_info_t& info)
     {
@@ -1138,6 +1156,17 @@ status_t BnAudioPolicyService::onTransact(
             return status;
         }
 
+#ifdef MTK_AUDIO
+        case SET_POLICYMANAGER_PARAMETERS: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            int par1 =data.readInt32();
+            int par2 =data.readInt32();
+            int par3 =data.readInt32();
+            int par4 =data.readInt32();
+            reply->writeInt32(SetPolicyManagerParameters(par1,par2,par3,par4));
+            return NO_ERROR;
+        } break;
+#endif
         case IS_OFFLOAD_SUPPORTED: {
             CHECK_INTERFACE(IAudioPolicyService, data, reply);
             audio_offload_info_t info = {};
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 9d435e9..2b531b7 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -58,7 +58,11 @@
 #include <cutils/properties.h>
 
 #include <system/audio.h>
+#ifdef MTK_AUDIO
+#include <hardware/audio_mtk.h>
+#else
 #include <hardware/audio.h>
+#endif
 
 #include "AudioMixer.h"
 #include "AudioFlinger.h"
@@ -128,7 +132,173 @@ size_t AudioFlinger::mTeeSinkTrackFrames = kTeeSinkTrackFramesDefault;
 static const nsecs_t kMinGlobalEffectEnabletimeNs = seconds(7200);
 
 // ----------------------------------------------------------------------------
+//<MTK_AUDIO_ADD
+// add by chipeng , support EM mode setting
+#ifdef MTK_AUDIO
+status_t AudioFlinger::SetEMParameter(void *ptr, size_t len)
+{
+    ALOGV("SetEMParameter ");
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    audio_hw_device_mtk_t *dev = (audio_hw_device_mtk_t*) mPrimaryHardwareDev->hwDevice();
+
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    if (NULL == dev->SetEMParameter)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->SetEMParameter(dev,ptr,len);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
+
+// add by chipeng , support EM mode setting
+status_t AudioFlinger::GetEMParameter(void *ptr, size_t len)
+{
+    ALOGV("GetEMParameter ");
+    // ioHandle == 0 means the parameters are global to the audio hardware interface
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    audio_hw_device_mtk_t *dev = static_cast<audio_hw_device_mtk_t*>(mPrimaryHardwareDev->hwDevice());
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    if (NULL == dev->GetEMParameter)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->GetEMParameter(dev,ptr,len);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
 
+status_t AudioFlinger::SetAudioData(int par1,size_t len,void *ptr)
+{
+    ALOGV("SetAudioData par1 = %d,len = %d ",par1,len);
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    audio_hw_device_mtk_t *dev = static_cast<audio_hw_device_mtk_t*>(mPrimaryHardwareDev->hwDevice());
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    if (NULL == dev->SetAudioData)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->SetAudioData(dev,par1,len,ptr);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::GetAudioData(int par1,size_t len,void *ptr)
+{
+    ALOGV("GetAudioData par1 = %d,len = %d ",par1,len);
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    audio_hw_device_mtk_t *dev = static_cast<audio_hw_device_mtk_t*>(mPrimaryHardwareDev->hwDevice());
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    if (NULL == dev->GetAudioData)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->GetAudioData(dev,par1,len,ptr);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::SetAudioCommand(int parameters1,int parameters2)
+{
+    ALOGV("SetAudioCommand par1 = %d,par2 = %d ",parameters1,parameters2);
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    audio_hw_device_mtk_t *dev = static_cast<audio_hw_device_mtk_t*>(mPrimaryHardwareDev->hwDevice());
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    if (NULL == dev->SetAudioCommand)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->SetAudioCommand(dev,parameters1,parameters2);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::GetAudioCommand(int parameters1)
+{
+    ALOGV("GetAudioCommand par1 = %d",parameters1);
+    int value =0;
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    audio_hw_device_mtk_t *dev = static_cast<audio_hw_device_mtk_t*>(mPrimaryHardwareDev->hwDevice());
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    if (NULL == dev->GetAudioCommand)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    value =dev->GetAudioCommand(dev,parameters1);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return value;
+}
+#endif
 const char *formatToString(audio_format_t format) {
     switch (format & AUDIO_FORMAT_MAIN_MASK) {
     case AUDIO_FORMAT_PCM:
diff --git a/services/audioflinger/AudioFlinger.h b/services/audioflinger/AudioFlinger.h
index 3e9a088..d958a39 100644
--- a/services/audioflinger/AudioFlinger.h
+++ b/services/audioflinger/AudioFlinger.h
@@ -104,6 +104,17 @@ class AudioFlinger :
 public:
     static const char* getServiceName() ANDROID_API { return "media.audio_flinger"; }
 
+#ifdef MTK_AUDIO
+//<MTK_AUDIO_ADD
+    virtual status_t GetEMParameter(void *ptr, size_t len);
+    virtual status_t SetEMParameter(void *ptr, size_t len);
+    virtual status_t SetAudioData(int par1,size_t len,void *ptr);
+    virtual status_t GetAudioData(int par1,size_t len,void *ptr);
+    virtual status_t SetAudioCommand(int parameters1,int parameters2);
+    virtual status_t GetAudioCommand(int parameters1);
+//MTK_AUDIO_ADD>
+#endif
+
     virtual     status_t    dump(int fd, const Vector<String16>& args);
 
     // IAudioFlinger interface, in binder opcode order
diff --git a/services/audiopolicy/Android.mk b/services/audiopolicy/Android.mk
index 69fc0e8..4b5a8e0 100644
--- a/services/audiopolicy/Android.mk
+++ b/services/audiopolicy/Android.mk
@@ -52,6 +52,38 @@ LOCAL_MODULE:= libaudiopolicyservice
 
 LOCAL_CFLAGS += -fvisibility=hidden
 
+ifeq ($(MTK_AUDIO),yes)
+LOCAL_CFLAGS += -DMTK_AUDIO
+
+ifeq ($(strip $(MTK_BSP_PACKAGE)),yes)
+    LOCAL_CFLAGS += -DMTK_BSP_PACKAGE
+endif
+
+ifeq ($(strip $(TARGET_BUILD_VARIANT)),eng)
+  LOCAL_CFLAGS += -DCONFIG_MT_ENG_BUILD
+endif
+
+LOCAL_SHARED_LIBRARIES += \
+    libmedia
+
+LOCAL_C_INCLUDES += \
+    $(TOPDIR)/frameworks/av/include \
+    $(MTK_PATH_PLATFORM)/hardware/audio/include \
+    $(MTK_PATH_SOURCE)/hardware/audio/common/include \
+    $(MTK_PATH_SOURCE)/hardware/audio/common/V3/include \
+    $(MTK_PATH_SOURCE)/external/nvram/libnvram \
+    $(MTK_PATH_SOURCE)/external/AudioCompensationFilter \
+    $(MTK_PATH_SOURCE)/external/AudioComponentEngine \
+    $(MTK_PATH_SOURCE)/external/HeadphoneCompensationFilter \
+    $(MTK_PATH_SOURCE)/external/audiocustparam \
+    $(MTK_PATH_SOURCE)/frameworks/av/include/media \
+    $(MTK_PATH_SOURCE)/frameworks/av/include \
+    $(TOP)/frameworks/av/include/media \
+    $(MTK_PATH_CUSTOM)/custom \
+    $(MTK_PATH_CUSTOM)/custom/audio \
+    $(MTK_PATH_CUSTOM)/hal/audioflinger/audio
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
 
@@ -93,6 +125,38 @@ LOCAL_STATIC_LIBRARIES := \
     libmedia_helper \
     libaudiopolicycomponents
 
+ifeq ($(MTK_AUDIO),yes)
+LOCAL_CFLAGS += -DMTK_AUDIO
+
+ifeq ($(strip $(MTK_BSP_PACKAGE)),yes)
+    LOCAL_CFLAGS += -DMTK_BSP_PACKAGE
+endif
+
+ifeq ($(strip $(TARGET_BUILD_VARIANT)),eng)
+  LOCAL_CFLAGS += -DCONFIG_MT_ENG_BUILD
+endif
+
+LOCAL_SHARED_LIBRARIES += \
+    libmedia
+
+LOCAL_C_INCLUDES += \
+    $(TOPDIR)/frameworks/av/include \
+    $(MTK_PATH_PLATFORM)/hardware/audio/include \
+    $(MTK_PATH_SOURCE)/hardware/audio/common/include \
+    $(MTK_PATH_SOURCE)/hardware/audio/common/V3/include \
+    $(MTK_PATH_SOURCE)/external/nvram/libnvram \
+    $(MTK_PATH_SOURCE)/external/AudioCompensationFilter \
+    $(MTK_PATH_SOURCE)/external/AudioComponentEngine \
+    $(MTK_PATH_SOURCE)/external/HeadphoneCompensationFilter \
+    $(MTK_PATH_SOURCE)/external/audiocustparam \
+    $(MTK_PATH_SOURCE)/frameworks/av/include/media \
+    $(MTK_PATH_SOURCE)/frameworks/av/include \
+    $(TOP)/frameworks/av/include/media \
+    $(MTK_PATH_CUSTOM)/custom \
+    $(MTK_PATH_CUSTOM)/custom/audio \
+    $(MTK_PATH_CUSTOM)/hal/audioflinger/audio
+endif
+
 LOCAL_MODULE:= libaudiopolicymanagerdefault
 
 include $(BUILD_SHARED_LIBRARY)
@@ -116,6 +180,38 @@ LOCAL_C_INCLUDES += \
 
 LOCAL_MODULE:= libaudiopolicymanager
 
+ifeq ($(MTK_AUDIO),yes)
+LOCAL_CFLAGS += -DMTK_AUDIO
+
+ifeq ($(strip $(MTK_BSP_PACKAGE)),yes)
+    LOCAL_CFLAGS += -DMTK_BSP_PACKAGE
+endif
+
+ifeq ($(strip $(TARGET_BUILD_VARIANT)),eng)
+  LOCAL_CFLAGS += -DCONFIG_MT_ENG_BUILD
+endif
+
+LOCAL_SHARED_LIBRARIES += \
+    libmedia
+
+LOCAL_C_INCLUDES += \
+    $(TOPDIR)/frameworks/av/include \
+    $(MTK_PATH_PLATFORM)/hardware/audio/include \
+    $(MTK_PATH_SOURCE)/hardware/audio/common/include \
+    $(MTK_PATH_SOURCE)/hardware/audio/common/V3/include \
+    $(MTK_PATH_SOURCE)/external/nvram/libnvram \
+    $(MTK_PATH_SOURCE)/external/AudioCompensationFilter \
+    $(MTK_PATH_SOURCE)/external/AudioComponentEngine \
+    $(MTK_PATH_SOURCE)/external/HeadphoneCompensationFilter \
+    $(MTK_PATH_SOURCE)/external/audiocustparam \
+    $(MTK_PATH_SOURCE)/frameworks/av/include/media \
+    $(MTK_PATH_SOURCE)/frameworks/av/include \
+    $(TOP)/frameworks/av/include/media \
+    $(MTK_PATH_CUSTOM)/custom \
+    $(MTK_PATH_CUSTOM)/custom/audio \
+    $(MTK_PATH_CUSTOM)/hal/audioflinger/audio
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
 endif
diff --git a/services/audiopolicy/AudioPolicyInterface.h b/services/audiopolicy/AudioPolicyInterface.h
index 93e6266..c5565a7 100644
--- a/services/audiopolicy/AudioPolicyInterface.h
+++ b/services/audiopolicy/AudioPolicyInterface.h
@@ -227,6 +227,11 @@ public:
                                       const audio_attributes_t *attributes,
                                       audio_io_handle_t *handle) = 0;
     virtual status_t stopAudioSource(audio_io_handle_t handle) = 0;
+
+#ifdef MTK_HARDWARE
+    virtual status_t SetPolicyManagerParameters(int par1, int par2 , int par3 , int par4) = 0;
+#endif
+
 };
 
 
@@ -334,6 +339,10 @@ public:
 
     virtual void onOutputSessionEffectsUpdate(sp<AudioSessionInfo>& streamInfo, bool added) = 0;
 
+#ifdef MTK_HARDWARE
+    /* MTK for get custom audio volume setting */
+    virtual status_t getCustomAudioVolume(void* pCustomVol) = 0;
+#endif
 };
 
 extern "C" AudioPolicyInterface* createAudioPolicyManager(AudioPolicyClientInterface *clientInterface);
diff --git a/services/audiopolicy/common/managerdefinitions/include/AudioPolicyVendorControl.h b/services/audiopolicy/common/managerdefinitions/include/AudioPolicyVendorControl.h
new file mode 100644
index 0000000..08466aa
--- /dev/null
+++ b/services/audiopolicy/common/managerdefinitions/include/AudioPolicyVendorControl.h
@@ -0,0 +1,37 @@
+
+#pragma once
+
+
+#include <utils/threads.h>
+
+namespace android {
+/* Vendor provide to add new feature in audio policy
+*/
+    class AudioPolicyVendorControl
+    {
+    public:
+        AudioPolicyVendorControl():mVoiceCurveReplaceDTMFCurve(false),mUseCustomVolume(false),mA2DPForeceIgnore(false),mFMTxEnable(false),
+                                    mCrossMountLocalPlayback(false),mCrossMountMicLocalPlayback(false),mNeedResetInput(false),mStart2CrossMount(false){};
+        bool getA2DPForeceIgnoreStatus() const {return mA2DPForeceIgnore;}
+        void setA2DPForeceIgnoreStatus(bool ignore) {mA2DPForeceIgnore = ignore;}
+
+        bool getFMTxStatus() const {return mFMTxEnable;}
+        void setFMTxStatus(bool enable) {mFMTxEnable = enable;}
+
+        bool getVoiceReplaceDTMFStatus() const {return mVoiceCurveReplaceDTMFCurve;}
+        void setVoiceReplaceDTMFStatus(bool enable) {mVoiceCurveReplaceDTMFCurve = enable;}
+
+        bool getCustomVolumeStatus() const {return mUseCustomVolume;}
+        void setCustomVolumeStatus(bool enable) {mUseCustomVolume = enable;}
+    private:
+        bool mVoiceCurveReplaceDTMFCurve;
+        bool mUseCustomVolume;
+        bool mA2DPForeceIgnore;
+        bool mFMTxEnable;
+        bool mCrossMountLocalPlayback; //For MTK_CROSSMOUNT
+        bool mCrossMountMicLocalPlayback;//For MTK_CROSSMOUNT
+        bool mNeedResetInput;//For MTK_CROSSMOUNT
+        bool mStart2CrossMount;//For MTK_CROSSMOUNT
+        //uint32_t mSampleRate_Policy;
+    };
+}
diff --git a/services/audiopolicy/engine/interface/AudioPolicyManagerObserver.h b/services/audiopolicy/engine/interface/AudioPolicyManagerObserver.h
index 6d43df2..1a58944 100755
--- a/services/audiopolicy/engine/interface/AudioPolicyManagerObserver.h
+++ b/services/audiopolicy/engine/interface/AudioPolicyManagerObserver.h
@@ -26,6 +26,11 @@
 #include <AudioPolicyMix.h>
 #include <SoundTriggerSession.h>
 #include <StreamDescriptor.h>
+#ifdef MTK_AUDIO
+//<MTK_AUDIO_ADD
+#include <AudioPolicyVendorControl.h>
+//MTK_AUDIO_ADD>
+#endif
 
 namespace android {
 
@@ -55,6 +60,11 @@ public:
 
     virtual const sp<DeviceDescriptor> &getDefaultOutputDevice() const = 0;
 
+#ifdef MTK_AUDIO
+    //<MTK_AUDIO_ADD
+    virtual AudioPolicyVendorControl &getAudioPolicyVendorControl() = 0;
+    //MTK_AUDIO_ADD>
+#endif
 protected:
     virtual ~AudioPolicyManagerObserver() {}
 };
diff --git a/services/audiopolicy/enginedefault/Android.mk b/services/audiopolicy/enginedefault/Android.mk
index f6ffa2a..186cb19 100755
--- a/services/audiopolicy/enginedefault/Android.mk
+++ b/services/audiopolicy/enginedefault/Android.mk
@@ -48,4 +48,28 @@ LOCAL_SHARED_LIBRARIES += \
     libutils \
     libaudioutils \
 
+ifeq ($(MTK_AUDIO),yes)
+LOCAL_CFLAGS += -DMTK_AUDIO
+
+ifeq ($(strip $(TARGET_BUILD_VARIANT)),eng)
+  LOCAL_CFLAGS += -DCONFIG_MT_ENG_BUILD
+endif
+
+LOCAL_C_INCLUDES += \
+    $(TOPDIR)/frameworks/av/include \
+    $(MTK_PATH_PLATFORM)/hardware/audio/include \
+    $(MTK_PATH_SOURCE)/hardware/audio/common/include \
+    $(MTK_PATH_SOURCE)/external/nvram/libnvram \
+    $(MTK_PATH_SOURCE)/external/AudioCompensationFilter \
+    $(MTK_PATH_SOURCE)/external/AudioComponentEngine \
+    $(MTK_PATH_SOURCE)/external/HeadphoneCompensationFilter \
+    $(MTK_PATH_SOURCE)/external/audiocustparam \
+    $(MTK_PATH_SOURCE)/frameworks/av/include/media \
+    $(MTK_PATH_SOURCE)/frameworks/av/include \
+    $(TOP)/frameworks/av/include/media \
+    $(MTK_PATH_CUSTOM)/custom \
+    $(MTK_PATH_CUSTOM)/custom/audio \
+    $(MTK_PATH_CUSTOM)/hal/audioflinger/audio
+endif
+
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/audiopolicy/enginedefault/src/Engine.cpp b/services/audiopolicy/enginedefault/src/Engine.cpp
index 627e1d3..a786f2d 100755
--- a/services/audiopolicy/enginedefault/src/Engine.cpp
+++ b/services/audiopolicy/enginedefault/src/Engine.cpp
@@ -139,12 +139,20 @@ status_t Engine::setPhoneState(audio_mode_t state)
             streams.setVolumeCurvePoint(AUDIO_STREAM_DTMF, static_cast<Volume::device_category>(j),
                                          Gains::sVolumeProfiles[AUDIO_STREAM_VOICE_CALL][j]);
         }
+#ifdef MTK_AUDIO
+        AudioPolicyVendorControl &mAudioPolicyVendorControl = mApmObserver->getAudioPolicyVendorControl();
+        mAudioPolicyVendorControl.setVoiceReplaceDTMFStatus(true);
+#endif
     } else if (is_state_in_call(oldState) && !is_state_in_call(state)) {
         ALOGV("  Exiting call in setPhoneState()");
         for (int j = 0; j < Volume::DEVICE_CATEGORY_CNT; j++) {
             streams.setVolumeCurvePoint(AUDIO_STREAM_DTMF, static_cast<Volume::device_category>(j),
                                          Gains::sVolumeProfiles[AUDIO_STREAM_DTMF][j]);
         }
+#ifdef MTK_AUDIO
+        AudioPolicyVendorControl &mAudioPolicyVendorControl = mApmObserver->getAudioPolicyVendorControl();
+        mAudioPolicyVendorControl.setVoiceReplaceDTMFStatus(false);
+#endif
     }
     return NO_ERROR;
 }
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
index 13499ae..e244e12 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
@@ -41,6 +41,18 @@
 #include <ConfigParsingUtils.h>
 #include <policy.h>
 
+#ifdef MTK_AUDIO
+
+#include "AudioPolicyParameters.h"
+
+static int gMTKPolicyLoglevel = 0;
+#define MTK_ALOGVV(...) if (gMTKPolicyLoglevel > 1) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
+#define MTK_ALOGV(...) if (gMTKPolicyLoglevel > 0) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
+#else
+#define MTK_ALOGVV(...) do { } while(0)
+#define MTK_ALOGV(...) do { } while(0)
+
+#endif
 namespace android {
 
 // ----------------------------------------------------------------------------
@@ -2847,6 +2859,17 @@ AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterfa
                 if (mPrimaryOutput == 0 &&
                         outProfile->mFlags & AUDIO_OUTPUT_FLAG_PRIMARY) {
                     mPrimaryOutput = outputDesc;
+#ifdef MTK_AUDIO
+                    mAudioCustVolumeTable.bRev = CUSTOM_VOLUME_REV_1;
+                    mAudioCustVolumeTable.bReady = 0;
+                    mpClientInterface->getCustomAudioVolume(&mAudioCustVolumeTable);
+                    if (mAudioCustVolumeTable.bReady!=0) {
+                        ALOGD("mUseCustomVolume true");
+                        mAudioPolicyVendorControl.setCustomVolumeStatus(true);
+                    } else {
+                        ALOGD("mUseCustomVolume false");
+                    }
+#endif
                 }
                 addOutput(output, outputDesc);
                 setOutputDevice(outputDesc,
@@ -4568,7 +4591,18 @@ float AudioPolicyManager::computeVolume(audio_stream_type_t stream,
                                             int index,
                                             audio_devices_t device)
 {
+#ifdef MTK_AUDIO
+    float volumeDb;
+    if (mAudioPolicyVendorControl.getCustomVolumeStatus()) {
+        volumeDb = Volume::AmplToDb(computeCustomVolume(stream, index, device));
+    } else {
+        ALOGW("%s,not Customer Volume, Using Android Volume Curve",__FUNCTION__);
+        volumeDb = mEngine->volIndexToDb(Volume::getDeviceCategory(device), stream, index);
+    }
+    ALOGD("%s streamtype [%d],index [%d],device [0x%x], volumeDb [%f]",__FUNCTION__,stream,index,device,volumeDb);
+#else
     float volumeDb = mEngine->volIndexToDb(Volume::getDeviceCategory(device), stream, index);
+#endif
 
     // if a headset is connected, apply the following rules to ring tones and notifications
     // to avoid sound level bursts in user's ears:
@@ -4647,7 +4681,15 @@ status_t AudioPolicyManager::checkAndSetVolume(audio_stream_type_t stream,
         float voiceVolume;
         // Force voice volume to max for bluetooth SCO as volume is managed by the headset
         if (stream == AUDIO_STREAM_VOICE_CALL) {
+#ifdef MTK_AUDIO
+            if (mAudioPolicyVendorControl.getCustomVolumeStatus()) {
+                voiceVolume = computeCustomVolume(stream, index, device);
+            } else {
+                voiceVolume = (float)index/(float)mStreams.valueFor(stream).getVolumeIndexMax();
+            }
+#else
             voiceVolume = (float)index/(float)mStreams.valueFor(stream).getVolumeIndexMax();
+#endif
         } else {
             voiceVolume = 1.0;
         }
@@ -4943,4 +4985,343 @@ bool AudioPolicyManager::isStateInCall(int state)
     return is_state_in_call(state);
 }
 
+#ifdef MTK_AUDIO
+
+int AudioPolicyManager::PolicyPropertyCheck(void)
+{
+    int result=0;
+    char value[PROPERTY_VALUE_MAX];
+    property_get("af.Policy.SampleRate_policy", value, "0");
+    result = atoi(value);
+    return result;
+}
+
+status_t AudioPolicyManager::SetPolicyManagerParameters(int par1,int par2 ,int par3,int par4)
+{
+    audio_devices_t primaryOutDevices = mPrimaryOutput->device();
+    audio_devices_t curDevice =Volume::getDeviceForVolume(mPrimaryOutput->device());
+    ALOGD("SetPolicyManagerParameters par1 = %d par2 = %d par3 = %d par4 = %d curDevice = 0x%x",par1,par2,par3,par4,curDevice);
+    status_t volStatus;
+    switch(par1) {
+        case POLICY_SET_FM_TX_ENABLE:{
+            ALOGD("Set POLICY_SET_FM_TX_ENABLE [%d] => [%d]",mAudioPolicyVendorControl.getFMTxStatus(), par2);
+            if (par2) {
+                mAudioPolicyVendorControl.setFMTxStatus(true);
+            } else {
+                mAudioPolicyVendorControl.setFMTxStatus(false);
+            }
+            setForceUse(AUDIO_POLICY_FORCE_USE_CNT,AUDIO_POLICY_FORCE_NONE);
+            break;
+        }
+        case POLICY_SET_FM_RX_FORCE_DISABLE_TX:{
+            ALOGD("Set POLICY_SET_FM_RX_FORCE_DISABLE_TX [%d] => [%d]",mAudioPolicyVendorControl.getFMTxStatus(), par2);
+            if (par2) {
+                mAudioPolicyVendorControl.setFMTxStatus(false);
+            } else {
+                mAudioPolicyVendorControl.setFMTxStatus(true);
+            }
+            setForceUse(AUDIO_POLICY_FORCE_USE_CNT,AUDIO_POLICY_FORCE_NONE);
+            break;
+        }
+        case POLICY_SET_FM_PRESTOP:{
+#ifndef MTK_BSP_PACKAGE
+#ifdef SUPPORT_ANDROID_FM_PLAYER//TK only, Don't enable it for BSP
+             if (par2) {
+                ALOGD("mute for FM app");
+                setStreamMute(AUDIO_STREAM_MUSIC, true, mPrimaryOutput);
+            } else {
+                ALOGD("unmute for FM app");
+                setStreamMute(AUDIO_STREAM_MUSIC, false, mPrimaryOutput);
+            }
+#endif
+#endif
+            break;
+        }
+        case POLICY_SET_A2DP_FORCE_IGNORE:{
+            ALOGD("Set bA2DPForeceIgnore [%d] => [%d]",mAudioPolicyVendorControl.getA2DPForeceIgnoreStatus(),par2);
+            if (par2) {
+                mAudioPolicyVendorControl.setA2DPForeceIgnoreStatus(true);
+            } else {
+                mAudioPolicyVendorControl.setA2DPForeceIgnoreStatus(false);
+            }
+            setForceUse(AUDIO_POLICY_FORCE_USE_CNT,AUDIO_POLICY_FORCE_NONE);
+            break;
+        }
+        case POLICY_LOAD_VOLUME:{
+            LoadCustomVolume();
+            for(int i =0; i<AUDIO_STREAM_CNT;i++) {
+                if (i == AUDIO_STREAM_PATCH) {
+                    continue;
+                }
+                volStatus =checkAndSetVolume((audio_stream_type_t)i, mStreams.valueFor((audio_stream_type_t)i).getVolumeIndex(primaryOutDevices),mPrimaryOutput,primaryOutDevices,50,true);
+            }
+            break;
+         }
+        default:
+            break;
+    }
+
+    return NO_ERROR;
+}
+
+float AudioPolicyManager::linearToLog(int volume)
+{
+    return volume ? exp(float(fCUSTOM_VOLUME_MAPPING_STEP - volume) * fBConvert) : 0;
+}
+
+int AudioPolicyManager::mapVol(float &vol, float unitstep)
+{
+    int index = (vol+0.5)/unitstep;
+    vol -= (index*unitstep);
+    return index;
+}
+
+int AudioPolicyManager::mapping_Voice_vol(float &vol, float unitstep)
+{
+    #define ROUNDING_NUM (1)
+
+    if (vol < unitstep) {
+        return 1;
+    }
+    if (vol < (unitstep*2 + ROUNDING_NUM)) {
+        vol -= unitstep;
+        return 2;
+    } else if (vol < (unitstep*3 + ROUNDING_NUM)) {
+        vol -= unitstep*2;
+        return 3;
+    } else if (vol < (unitstep*4 + ROUNDING_NUM)) {
+        vol -= unitstep*3;
+        return 4;
+    } else if (vol < (unitstep*5 + ROUNDING_NUM)) {
+        vol -= unitstep*4;
+        return 5;
+    } else if (vol < (unitstep*6 + ROUNDING_NUM)) {
+        vol -= unitstep*5;
+        return 6;
+    } else if (vol < (unitstep*7 + ROUNDING_NUM)) {
+        vol -= unitstep*6;
+        return 7;
+    } else {
+        ALOGW("vole = %f unitstep = %f",vol,unitstep);
+        return 0;
+    }
+}
+
+
+
+
+int AudioPolicyManager::getStreamMaxLevels(int stream)
+{
+    return (int) mAudioCustVolumeTable.audiovolume_level[stream];
+}
+
+// this function will map vol 0~100 , base on customvolume map to 0~255 , and do linear calculation to set mastervolume
+float AudioPolicyManager::mapVoltoCustomVol(unsigned char array[], int volmin, int volmax,float &vol , int stream)
+{
+    MTK_ALOGV("+MapVoltoCustomVol vol = %f stream = %d volmin = %d volmax = %d",vol,stream,volmin,volmax);
+
+    if (stream == AUDIO_STREAM_VOICE_CALL) {
+        return mapVoiceVoltoCustomVol(array,volmin,volmax,vol);
+    } else if (stream >= AUDIO_STREAM_CNT || stream < AUDIO_STREAM_MIN) {
+        ALOGE("%s %d Error : stream = %d",__FUNCTION__,__LINE__,stream);
+        stream = AUDIO_STREAM_MUSIC;
+    }
+
+    float volume =0.0;
+    const StreamDescriptor& streamDesc = mStreams.valueFor((audio_stream_type_t)stream);//mStreams[stream];
+    if (vol == 0) {
+        volume = vol;
+        return 0;
+    } else {    // map volume value to custom volume
+        int dMaxLevels = getStreamMaxLevels(stream);
+        int streamDescmIndexMax = streamDesc.getVolumeIndexMax();
+        if (dMaxLevels <= 0) {
+            ALOGE("%s %d Error : dMaxLevels = %d",__FUNCTION__,__LINE__,dMaxLevels);
+            dMaxLevels = 1;
+        }
+        if (streamDescmIndexMax <= 0) {
+            ALOGE("%s %d Error : streamDescmIndexMax = %d",__FUNCTION__,__LINE__,streamDescmIndexMax);
+            streamDescmIndexMax = 1;
+        }
+
+        float unitstep = fCUSTOM_VOLUME_MAPPING_STEP/dMaxLevels;
+        if (vol < fCUSTOM_VOLUME_MAPPING_STEP/streamDescmIndexMax) {
+            volume = array[0];
+            vol = volume;
+            return volume;
+        }
+        int Index = mapVol(vol, unitstep);
+        float Remind = (1.0 - (float)vol/unitstep);
+        if (Index != 0) {
+            volume = ((array[Index]  - (array[Index] - array[Index-1]) * Remind)+0.5);
+        } else {
+            volume = 0;
+        }
+        MTK_ALOGVV("%s vol [%f] unitstep [%f] Index [%d] Remind [%f] volume [%f]",__FUNCTION__,vol,unitstep,Index,Remind,volume);
+    }
+    // -----clamp for volume
+    if ( volume > 253.0) {
+        volume = fCUSTOM_VOLUME_MAPPING_STEP;
+    } else if ( volume <= array[0]) {
+        volume = array[0];
+    }
+    vol = volume;
+    MTK_ALOGVV("%s volume [%f] vol [%f]",__FUNCTION__,volume,vol);
+    return volume;
+}
+
+// this function will map vol 0~100 , base on customvolume map to 0~255 , and do linear calculation to set mastervolume
+float AudioPolicyManager::mapVoiceVoltoCustomVol(unsigned char array[], int volmin __unused, int volmax __unused, float &vol)
+{
+    vol = (int)vol;
+    float volume = 0.0;
+//  StreamDescriptor &streamDesc = mStreams.valueFor((audio_stream_type_t)AUDIO_STREAM_VOICE_CALL);//mStreams[AUDIO_STREAM_VOICE_CALL];
+    if (vol == 0) {
+        volume = array[0];
+    } else {
+        int dMaxIndex = getStreamMaxLevels(AUDIO_STREAM_VOICE_CALL)-1;
+        if (dMaxIndex < 0) {
+            ALOGE("%s %d Error : dMaxIndex = %d",__FUNCTION__,__LINE__,dMaxIndex);
+            dMaxIndex = 1;
+        }
+        if (vol >= fCUSTOM_VOLUME_MAPPING_STEP) {
+            volume = array[dMaxIndex];
+            MTK_ALOGVV("%s volumecheck stream = %d index = %d volume = %f",__FUNCTION__,AUDIO_STREAM_VOICE_CALL,dMaxIndex,volume);
+        } else {
+            double unitstep = fCUSTOM_VOLUME_MAPPING_STEP /dMaxIndex;
+            int Index = mapping_Voice_vol(vol, unitstep);
+            // boundary for array
+            if (Index >= dMaxIndex) {
+                Index = dMaxIndex;
+            }
+            float Remind = (1.0 - (float)vol/unitstep) ;
+            if (Index != 0) {
+                volume = (array[Index]  - (array[Index] - array[Index- 1]) * Remind)+0.5;
+            } else {
+                volume =0;
+            }
+            MTK_ALOGVV("%s volumecheck stream = %d index = %d volume = %f",__FUNCTION__,AUDIO_STREAM_VOICE_CALL,Index,volume);
+            MTK_ALOGVV("%s dMaxIndex [%d] vol [%f] unitstep [%f] Index [%d] Remind [%f] volume [%f]",__FUNCTION__,dMaxIndex,vol,unitstep,Index,Remind,volume);
+        }
+    }
+
+     if ( volume > CUSTOM_VOICE_VOLUME_MAX) {
+         volume = CUSTOM_VOICE_VOLUME_MAX;
+     }
+     else if ( volume <= array[0]) {
+         volume = array[0];
+     }
+
+     vol = volume;
+     float degradeDb = (CUSTOM_VOICE_VOLUME_MAX-vol)/CUSTOM_VOICE_ONEDB_STEP;
+     MTK_ALOGVV("%s volume [%f] degradeDb [%f]",__FUNCTION__,volume,degradeDb);
+     vol = fCUSTOM_VOLUME_MAPPING_STEP - (degradeDb*4);
+     MTK_ALOGVV("%s volume [%f] vol [%f]",__FUNCTION__,volume,vol);
+     return volume;
+}
+
+float AudioPolicyManager::computeCustomVolume(int stream, int index, audio_devices_t device)
+{
+    // check if force use exist , get output device for certain mode
+    Volume::device_category deviceCategory = Volume::getDeviceCategory(device);
+    // compute custom volume
+    float volume =0.0;
+    int volmax=0 , volmin =0,volumeindex =0;
+    int custom_vol_device_mode,audiovolume_steamtype;
+    int dMaxStepIndex = 0;
+
+    MTK_ALOGVV("%s volumecheck stream = %d index = %d device = %d",__FUNCTION__,stream,index,device);
+
+    if (mAudioPolicyVendorControl.getVoiceReplaceDTMFStatus() && stream == AUDIO_STREAM_DTMF) {
+        //normalize new index from 0~15(audio) to 0~6(voice)
+        int tempindex = index;
+        const StreamDescriptor &DTMFstreamDesc = mStreams.valueFor((audio_stream_type_t)AUDIO_STREAM_DTMF);//mStreams[stream];
+        const StreamDescriptor &VoicestreamDesc = mStreams.valueFor((audio_stream_type_t)AUDIO_STREAM_VOICE_CALL);//mStreams[AUDIO_STREAM_VOICE_CALL];
+        float DTMFvolInt = (fCUSTOM_VOLUME_MAPPING_STEP * (index - DTMFstreamDesc.getVolumeIndexMin())) / (DTMFstreamDesc.getVolumeIndexMax() - DTMFstreamDesc.getVolumeIndexMin());
+        index = (DTMFvolInt*(VoicestreamDesc.getVolumeIndexMax() - VoicestreamDesc.getVolumeIndexMin())/ (fCUSTOM_VOLUME_MAPPING_STEP)) + VoicestreamDesc.getVolumeIndexMin();
+        MTK_ALOGVV("volumecheck refine DTMF index [%d] to Voice index [%d]",tempindex,index);
+        stream = AUDIO_STREAM_VOICE_CALL;
+    }
+
+    const StreamDescriptor &streamDesc = mStreams.valueFor((audio_stream_type_t)stream);//mStreams[stream];
+    float volInt = (fCUSTOM_VOLUME_MAPPING_STEP * (index - streamDesc.getVolumeIndexMin())) / (streamDesc.getVolumeIndexMax() - streamDesc.getVolumeIndexMin());
+
+    if (deviceCategory == Volume::DEVICE_CATEGORY_SPEAKER) {
+        custom_vol_device_mode = CUSTOM_VOLUME_SPEAKER_MODE;
+    } else if (deviceCategory == Volume::DEVICE_CATEGORY_HEADSET) {
+        custom_vol_device_mode = CUSTOM_VOLUME_HEADSET_MODE;
+    } else if (deviceCategory == Volume::DEVICE_CATEGORY_EARPIECE) {
+        custom_vol_device_mode = CUSTOM_VOLUME_NORMAL_MODE;
+    } else {
+        custom_vol_device_mode = CUSTOM_VOLUME_HEADSET_SPEAKER_MODE;
+    }
+
+    if ((stream == AUDIO_STREAM_VOICE_CALL) && (mEngine->getPhoneState() == AUDIO_MODE_IN_COMMUNICATION)) {
+        audiovolume_steamtype = (int) CUSTOM_VOL_TYPE_SIP;
+    } else if (stream >= AUDIO_STREAM_VOICE_CALL && stream < AUDIO_STREAM_CNT ) {
+        audiovolume_steamtype = stream;
+    } else {
+        audiovolume_steamtype = (int) CUSTOM_VOL_TYPE_MUSIC;
+        ALOGE("%s %d Error : audiovolume_steamtype = %d",__FUNCTION__,__LINE__,audiovolume_steamtype);
+    }
+
+    dMaxStepIndex = getStreamMaxLevels(stream)-1;
+
+    if (dMaxStepIndex > CUSTOM_AUDIO_MAX_VOLUME_STEP - 1) {
+        ALOGE("%s %d Error : dMaxStepIndex = %d",__FUNCTION__,__LINE__,dMaxStepIndex);
+        dMaxStepIndex = CUSTOM_AUDIO_MAX_VOLUME_STEP - 1;
+    } else if (dMaxStepIndex < 0) {
+        ALOGE("%s %d Error : dMaxStepIndex = %d",__FUNCTION__,__LINE__,dMaxStepIndex);
+        dMaxStepIndex = 0;
+    }
+
+    volmax =mAudioCustVolumeTable.audiovolume_steamtype[audiovolume_steamtype][custom_vol_device_mode][dMaxStepIndex];
+    volmin = mAudioCustVolumeTable.audiovolume_steamtype[audiovolume_steamtype][custom_vol_device_mode][0];
+    MTK_ALOGVV("%s audiovolume_steamtype %d custom_vol_device_mode %d stream %d",__FUNCTION__,audiovolume_steamtype,custom_vol_device_mode,stream);
+    MTK_ALOGVV("%s getStreamMaxLevels(stream) %d volmax %d volmin %d volInt %f index %d",__FUNCTION__,getStreamMaxLevels(stream),volmax,volmin,volInt,index);
+    volume = mapVoltoCustomVol(mAudioCustVolumeTable.audiovolume_steamtype[audiovolume_steamtype][custom_vol_device_mode],volmin,volmax,volInt,stream);
+
+    volume = linearToLog(volInt);
+    ALOGV("stream = %d after computeCustomVolume , volInt = %f volume = %f volmin = %d volmax = %d",stream,volInt,volume, volmin, volmax);
+    return volume;
+}
+
+void AudioPolicyManager::LoadCustomVolume()
+{
+    //ALOGD("LoadCustomVolume Audio_Ver1_Custom_Volume");
+
+    //android::GetVolumeVer1ParamFromNV (&Audio_Ver1_Custom_Volume);
+    mAudioCustVolumeTable.bRev = CUSTOM_VOLUME_REV_1;
+    mAudioCustVolumeTable.bReady = 0;
+
+    MTK_ALOGVV("B4 Update");
+    for (int i=0;i<CUSTOM_NUM_OF_VOL_TYPE;i++) {
+        MTK_ALOGVV("StreamType %d",i);
+        for (int j=0;j<CUSTOM_NUM_OF_VOL_MODE;j++) {
+            MTK_ALOGVV("DeviceType %d",j);
+            for (int k=0;k<CUSTOM_AUDIO_MAX_VOLUME_STEP;k++) {
+                MTK_ALOGVV("[IDX]:[Value] %d,%d",k,mAudioCustVolumeTable.audiovolume_steamtype[i][j][k]);
+            }
+        }
+    }
+    mpClientInterface->getCustomAudioVolume(&mAudioCustVolumeTable);
+    if (mAudioCustVolumeTable.bReady!=0) {
+        ALOGD("mUseCustomVolume true");
+        mAudioPolicyVendorControl.setCustomVolumeStatus(true);
+    } else {
+        ALOGD("mUseCustomVolume false");
+    }
+    MTK_ALOGVV("After Update");
+    for (int i=0;i<CUSTOM_NUM_OF_VOL_TYPE;i++) {
+        MTK_ALOGVV("StreamType %d",i);
+        for (int j=0;j<CUSTOM_NUM_OF_VOL_MODE;j++) {
+            MTK_ALOGVV("DeviceType %d",j);
+            for (int k=0;k<CUSTOM_AUDIO_MAX_VOLUME_STEP;k++) {
+                MTK_ALOGVV("[IDX]:[Value] %d,%d",k,mAudioCustVolumeTable.audiovolume_steamtype[i][j][k]);
+            }
+        }
+    }
+}
+
+#endif
 }; // namespace android
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.h b/services/audiopolicy/managerdefault/AudioPolicyManager.h
index c40a435..03f9b9f 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.h
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.h
@@ -44,6 +44,18 @@
 #include <StreamDescriptor.h>
 #include <SessionRoute.h>
 
+#ifdef MTK_AUDIO
+//<MTK_AUDIO_ADD
+#include <AudioPolicyVendorControl.h>
+#include <utils/threads.h>
+#include <hardware/AudioCustomVolume.h>
+
+//#ifdef MTK_NEW_VOL_CONTROL
+#include "AudioGainTableParam.h"
+//#endif
+//MTK_AUDIO_ADD>
+#endif
+
 namespace android {
 
 // ----------------------------------------------------------------------------
@@ -195,6 +207,12 @@ public:
 
         virtual bool isOffloadSupported(const audio_offload_info_t& offloadInfo);
 
+#ifdef MTK_AUDIO
+//<MTK_AUDIO_ADD
+        virtual status_t SetPolicyManagerParameters(int par1,int par2 ,int par3,int par4) ;
+        int  PolicyPropertyCheck(void);
+//MTK_AUDIO_ADD>
+#endif
         virtual status_t listAudioPorts(audio_port_role_t role,
                                         audio_port_type_t type,
                                         unsigned int *num_ports,
@@ -275,6 +293,13 @@ protected:
         {
             return mDefaultOutputDevice;
         }
+#ifdef MTK_AUDIO
+        //MTK
+        virtual AudioPolicyVendorControl &getAudioPolicyVendorControl()
+        {
+            return mAudioPolicyVendorControl;
+        }
+#endif
 protected:
         void addOutput(audio_io_handle_t output, sp<SwAudioOutputDescriptor> outputDesc);
         void removeOutput(audio_io_handle_t output);
@@ -571,6 +596,13 @@ protected:
 
         // Audio Policy Engine Interface.
         AudioPolicyManagerInterface *mEngine;
+#ifdef MTK_AUDIO
+//<MTK_AUDIO_ADD
+        uint32_t mSampleRate_Policy;
+        AudioPolicyVendorControl mAudioPolicyVendorControl;
+        void LoadCustomVolume(void);
+//MTK_AUDIO_ADD>
+#endif
 protected:
         // updates device caching and output for streams that can influence the
         //    routing of notifications
@@ -614,6 +646,18 @@ protected:
                                                           audio_policy_dev_state_t state,
                                                           const char *device_address,
                                                           const char *device_name);
+#ifdef MTK_AUDIO
+//<MTK_AUDIO_ADD
+        float linearToLog(int volume);
+        int mapVol(float &vol, float unitstep);
+        int mapping_Voice_vol(float &vol, float unitstep);
+        float computeCustomVolume(int stream, int index, audio_devices_t device);
+        int getStreamMaxLevels(int  stream);
+        float mapVoiceVoltoCustomVol(unsigned char array[], int volmin, int volmax, float &vol);
+        float mapVoltoCustomVol(unsigned char array[], int volmin, int volmax,float &vol , int stream);
+        AUDIO_CUSTOM_VOLUME_STRUCT mAudioCustVolumeTable;
+//MTK_AUDIO_ADD>
+#endif
 };
 
 };
diff --git a/services/audiopolicy/service/AudioPolicyClientImpl.cpp b/services/audiopolicy/service/AudioPolicyClientImpl.cpp
index 82720f4..7b78f84 100644
--- a/services/audiopolicy/service/AudioPolicyClientImpl.cpp
+++ b/services/audiopolicy/service/AudioPolicyClientImpl.cpp
@@ -230,4 +230,15 @@ audio_unique_id_t AudioPolicyService::AudioPolicyClient::newAudioUniqueId()
     return AudioSystem::newAudioUniqueId();
 }
 
+#ifdef MTK_HARDWARE
+status_t AudioPolicyService::AudioPolicyClient::getCustomAudioVolume(void* pCustomVol)
+{
+#ifdef MTK_AUDIO
+    return mAudioPolicyService->getCustomAudioVolume(pCustomVol);
+#else
+    return INVALID_OPERATION;
+#endif
+}
+#endif
+
 }; // namespace android
diff --git a/services/audiopolicy/service/AudioPolicyInterfaceImpl.cpp b/services/audiopolicy/service/AudioPolicyInterfaceImpl.cpp
index 7957af3..a5d6138 100644
--- a/services/audiopolicy/service/AudioPolicyInterfaceImpl.cpp
+++ b/services/audiopolicy/service/AudioPolicyInterfaceImpl.cpp
@@ -768,5 +768,21 @@ status_t AudioPolicyService::listAudioSessions(audio_stream_type_t streams,
     return NO_ERROR;
 }
 
+#ifdef MTK_HARDWARE
+//<MTK_AUDIO_ADD
+status_t AudioPolicyService::SetPolicyManagerParameters(int par1, int par2, int par3, int par4)
+{
+#ifdef MTK_AUDIO
+    Mutex::Autolock _l(mLock);
+    if (mAudioPolicyManager == NULL) {
+        return NO_INIT;
+    }
+    return mAudioPolicyManager->SetPolicyManagerParameters(par1, par2, par3, par4);
+#else
+    return 0;
+#endif
 
+}
+//MTK_AUDIO_ADD>
+#endif
 }; // namespace android
diff --git a/services/audiopolicy/service/AudioPolicyService.cpp b/services/audiopolicy/service/AudioPolicyService.cpp
index 79370f4..27897f7 100644
--- a/services/audiopolicy/service/AudioPolicyService.cpp
+++ b/services/audiopolicy/service/AudioPolicyService.cpp
@@ -55,7 +55,42 @@ static const nsecs_t kAudioCommandTimeoutNs = seconds(3); // 3 seconds
 namespace {
     extern struct audio_policy_service_ops aps_ops;
 };
+#ifdef MTK_HARDWARE
+//<MTK_AUDIO_ADD
+status_t AudioPolicyService::getCustomAudioVolume(void* pCustomVol)
+{
+#ifdef MTK_AUDIO
+    return mAudioCommandThread->getCustomAudioVolumeCommand(pCustomVol);
+#else
+    return INVALID_OPERATION;
+#endif
+}
 
+status_t     AudioPolicyService::AudioCommandThread::getCustomAudioVolumeCommand(void* pCustomVol)
+{
+#ifdef MTK_AUDIO
+    status_t status = NO_ERROR;
+    sp<AudioCommand> command = new AudioCommand();
+    command->mCommand = GET_CUSTOM_AUDIO_VOLUME;
+
+    GetCustomAudioVolumeData *data = new GetCustomAudioVolumeData();
+    memcpy(&(data->mVolConfig),pCustomVol,sizeof(AUDIO_CUSTOM_VOLUME_STRUCT));
+//    data->mVolConfig = *pCustomVol;
+    command->mParam = data;
+    command->mWaitStatus = true;
+    ALOGD("AudioCommandThread() adding set getCustomAudioVolume");
+    status = sendCommand(command);
+    if (status == NO_ERROR) {
+        memcpy(pCustomVol,&(data->mVolConfig),sizeof(AUDIO_CUSTOM_VOLUME_STRUCT));
+    }
+    return status;
+#else
+    return INVALID_OPERATION;
+#endif
+}
+
+//MTK_AUDIO_ADD>
+#endif
 // ----------------------------------------------------------------------------
 
 AudioPolicyService::AudioPolicyService()
@@ -602,6 +637,19 @@ bool AudioPolicyService::AudioCommandThread::threadLoop()
                     svc->doOnDynamicPolicyMixStateUpdate(data->mRegId, data->mState);
                     mLock.lock();
                     } break;
+#ifdef MTK_AUDIO
+                case GET_CUSTOM_AUDIO_VOLUME: {
+                    GetCustomAudioVolumeData *data = (GetCustomAudioVolumeData *)command->mParam.get();
+                    ALOGV("AudioCommandThread() processing GET_CUSTOM_AUDIO_VOLUME");
+                    sp<IAudioFlinger> af = AudioSystem::get_audio_flinger();
+                    if (af == 0) {
+                        command->mStatus = PERMISSION_DENIED;
+                    } else {
+                        command->mStatus = af->GetAudioData(GET_AUDIO_POLICY_VOL_FROM_VER1_DATA,sizeof(AUDIO_CUSTOM_VOLUME_STRUCT),&(data->mVolConfig));
+                    }
+                    ALOGV("-AudioCommandThread %d",command->mCommand);
+                    } break;
+#endif
                 case EFFECT_SESSION_UPDATE: {
                     EffectSessionUpdateData *data =
                             (EffectSessionUpdateData *)command->mParam.get();
diff --git a/services/audiopolicy/service/AudioPolicyService.h b/services/audiopolicy/service/AudioPolicyService.h
index b7f55ae..3de64d5 100644
--- a/services/audiopolicy/service/AudioPolicyService.h
+++ b/services/audiopolicy/service/AudioPolicyService.h
@@ -135,6 +135,12 @@ public:
     virtual bool isStreamActive(audio_stream_type_t stream, uint32_t inPastMs = 0) const;
     virtual bool isStreamActiveRemotely(audio_stream_type_t stream, uint32_t inPastMs = 0) const;
     virtual bool isSourceActive(audio_source_t source) const;
+#ifdef MTK_HARDWARE
+    //<MTK_AUDIO_ADD
+    virtual status_t SetPolicyManagerParameters(int par1, int par2, int par3, int par4);
+   virtual status_t getCustomAudioVolume(void* pCustomVol);
+    //MTK_AUDIO_ADD>
+#endif
 
     virtual status_t queryDefaultPreProcessing(int audioSession,
                                               effect_descriptor_t *descriptors,
@@ -268,6 +274,11 @@ private:
             SET_AUDIOPORT_CONFIG,
             DYN_POLICY_MIX_STATE_UPDATE,
             EFFECT_SESSION_UPDATE,
+#ifdef MTK_HARDWARE
+//<MTK_AUDIO_ADD
+            GET_CUSTOM_AUDIO_VOLUME,
+//MTK_AUDIO_ADD>
+#endif
         };
 
         AudioCommandThread (String8 name, const wp<AudioPolicyService>& service);
@@ -311,6 +322,15 @@ private:
                     void        dynamicPolicyMixStateUpdateCommand(String8 regId, int32_t state);
                     void        insertCommand_l(AudioCommand *command, int delayMs = 0);
                     void        effectSessionUpdateCommand(sp<AudioSessionInfo>& info, bool added);
+#ifdef MTK_HARDWARE
+//<MTK_AUDIO_ADD
+                    status_t    getCustomAudioVolumeCommand(void* pCustomVol);
+                    void        stopOutputSamplerateCommand(audio_io_handle_t output,
+                                                  audio_stream_type_t stream,
+                                                  audio_session_t session,
+                                                  int samplerate);
+//MTK_AUDIO_ADD>
+#endif
 
     private:
         class AudioCommandData;
@@ -413,6 +433,27 @@ private:
             bool mAdded;
         };
 
+#ifdef MTK_HARDWARE
+//<MTK_AUDIO_ADD
+        class GetCustomAudioVolumeData : public AudioCommandData {
+        public:
+            AUDIO_CUSTOM_VOLUME_STRUCT mVolConfig;
+        };
+        class GetGainTableData : public AudioCommandData {
+        public:
+            GainTableParam mGainTable;
+        };
+        class StopOutputDataSamplerate : public AudioCommandData {
+        public:
+            audio_io_handle_t mIO;
+            audio_stream_type_t mStream;
+            audio_session_t mSession;
+            int mSamplerate;
+        };
+        Mutex   mFunLock; //ALPS00255939
+//MTK_AUDIO_ADD>
+#endif
+
         Mutex   mLock;
         Condition mWaitWorkCV;
         Vector < sp<AudioCommand> > mAudioCommands; // list of pending commands
@@ -525,6 +566,10 @@ private:
         virtual void onOutputSessionEffectsUpdate(sp<AudioSessionInfo>& info, bool added);
 
 
+#ifdef MTK_HARDWARE
+        /* MTK for get custom audio volume setting */
+        virtual status_t getCustomAudioVolume(void* pCustomVol);
+#endif
      private:
         AudioPolicyService *mAudioPolicyService;
     };
-- 
2.30.2

