From b7536f86aa0116e6ebc701b7f0b5248950052853 Mon Sep 17 00:00:00 2001
From: root <root@localhost.local>
Date: Sun, 22 Jan 2023 02:59:18 +0300
Subject: [PATCH] MTK Camera

Change-Id: I26db1d1c0988251ea76fa0fa12d737c90063a979
---
 camera/Android.mk                             |   6 +
 camera/ICamera.cpp                            |  26 +
 camera/ICameraService.cpp                     |  55 ++
 camera/IMetadataCallbacks.cpp                 |  95 ++++
 camera/mediatek/Camera.cpp                    |  73 +++
 include/camera/Camera.h                       |  12 +
 include/camera/ICamera.h                      |  13 +
 include/camera/ICameraService.h               |  13 +
 include/camera/IMetadataCallbacks.h           |  58 +++
 media/mediaserver/Android.mk                  |  83 +++
 media/mediaserver/main_mediaserver.cpp        |  67 +++
 media/mediaserver/register.cpp                |  40 ++
 services/camera/libcameraservice/Android.mk   |  21 +
 .../camera/libcameraservice/CameraService.cpp | 131 +++++
 .../camera/libcameraservice/CameraService.h   |  12 +
 .../libcameraservice/api1/CameraClient.cpp    | 253 +++++++++
 .../libcameraservice/api1/CameraClient.h      |  41 ++
 .../device1/CameraHardwareInterface.h         |  58 +++
 .../mediatek/CameraService.cpp                |  63 +++
 .../mediatek/api1/CameraClient.cpp            | 483 ++++++++++++++++++
 20 files changed, 1603 insertions(+)
 create mode 100644 camera/IMetadataCallbacks.cpp
 create mode 100755 camera/mediatek/Camera.cpp
 create mode 100644 include/camera/IMetadataCallbacks.h
 create mode 100644 services/camera/libcameraservice/mediatek/CameraService.cpp
 create mode 100644 services/camera/libcameraservice/mediatek/api1/CameraClient.cpp

diff --git a/camera/Android.mk b/camera/Android.mk
index 36f6da1..678d4ee 100644
--- a/camera/Android.mk
+++ b/camera/Android.mk
@@ -58,6 +58,12 @@ else
 LOCAL_WHOLE_STATIC_LIBRARIES += libcamera_parameters
 endif
 
+ifeq ($(MTK_HARDWARE),true)
+LOCAL_SRC_FILES += \
+    IMetadataCallbacks.cpp \
+    mediatek/Camera.cpp
+endif
+
 LOCAL_MODULE:= libcamera_client
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/camera/ICamera.cpp b/camera/ICamera.cpp
index 9943be6..0b50a3c 100644
--- a/camera/ICamera.cpp
+++ b/camera/ICamera.cpp
@@ -49,6 +49,9 @@ enum {
     RECORDING_ENABLED,
     RELEASE_RECORDING_FRAME,
     STORE_META_DATA_IN_BUFFERS,
+#ifdef MTK_AOSP_ENHANCEMENT
+    SET_METADATA_CALLBACK,
+#endif
 };
 
 class BpCamera: public BpInterface<ICamera>
@@ -215,6 +218,19 @@ public:
         return ret;
     }
 
+#ifdef MTK_AOSP_ENHANCEMENT
+    status_t setMetadataCallback(sp<IMetadataCallbacks>& cb)
+    {
+        ALOGV("setMetadataCallbacks");
+        Parcel data, reply;
+        data.writeInterfaceToken(ICamera::getInterfaceDescriptor());
+        data.writeStrongBinder(IInterface::asBinder(cb));
+        remote()->transact(SET_METADATA_CALLBACK, data, &reply);
+        status_t ret = reply.readInt32();
+        return ret;
+    }
+#endif
+
     // set preview/capture parameters - key/value pairs
     status_t setParameters(const String8& params)
     {
@@ -377,6 +393,16 @@ status_t BnCamera::onTransact(
             reply->writeInt32(takePicture(msgType));
             return NO_ERROR;
         } break;
+#ifdef MTK_AOSP_ENHANCEMENT
+        case SET_METADATA_CALLBACK: {
+            ALOGV("SET_METADATA_CALLBACK");
+            CHECK_INTERFACE(ICamera, data, reply);
+            sp<IMetadataCallbacks> cb = interface_cast<IMetadataCallbacks>(data.readStrongBinder());
+            setMetadataCallback(cb);
+            return NO_ERROR;
+        } break;
+
+#endif
         case SET_PARAMETERS: {
             ALOGV("SET_PARAMETERS");
             CHECK_INTERFACE(ICamera, data, reply);
diff --git a/camera/ICameraService.cpp b/camera/ICameraService.cpp
index b359f57..696d6b5 100644
--- a/camera/ICameraService.cpp
+++ b/camera/ICameraService.cpp
@@ -285,6 +285,34 @@ public:
         return reply.readInt32();
     }
 
+#ifdef MTK_AOSP_ENHANCEMENT
+//!++
+#if 1   // defined(MTK_CAMERA_BSP_SUPPORT)
+
+    virtual status_t getProperty(String8 const& key, String8& value) const
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ICameraService::getInterfaceDescriptor());
+        data.writeString8(key);
+        remote()->transact(BnCameraService::GET_PROPERTY, data, &reply);
+        value = reply.readString8();
+        return reply.readInt32();
+    }
+
+    virtual status_t setProperty(String8 const& key, String8 const& value)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ICameraService::getInterfaceDescriptor());
+        data.writeString8(key);
+        data.writeString8(value);
+        remote()->transact(BnCameraService::SET_PROPERTY, data, &reply);
+        return reply.readInt32();
+    }
+
+#endif
+//!--
+#endif
+
     virtual status_t getLegacyParameters(int cameraId, String16* parameters) {
         if (parameters == NULL) {
             ALOGE("%s: parameters must not be null", __FUNCTION__);
@@ -445,6 +473,33 @@ status_t BnCameraService::onTransact(
             reply->writeInt32(removeListener(listener));
             return NO_ERROR;
         } break;
+
+#ifdef MTK_AOSP_ENHANCEMENT
+//!++
+#if 1   // defined(MTK_CAMERA_BSP_SUPPORT)
+        case GET_PROPERTY: {
+            CHECK_INTERFACE(ICameraService, data, reply);
+            String8 const key = data.readString8();
+            String8 value;
+            status_t const status = getProperty(key, value);
+            reply->writeString8(value);
+            reply->writeInt32(status);
+            ALOGD("[GET_PROPERTY] - pid=%d, uid=%d (%s)=(%s) \n", IPCThreadState::self()->getCallingPid(), IPCThreadState::self()->getCallingUid(), key.string(), value.string());
+            return OK;
+        } break;
+        case SET_PROPERTY: {
+            CHECK_INTERFACE(ICameraService, data, reply);
+            String8 const key = data.readString8();
+            String8 const value = data.readString8();
+            status_t const status = setProperty(key, value);
+            reply->writeInt32(status);
+            ALOGD("[SET_PROPERTY] - pid=%d, uid=%d (%s)=(%s) \n", IPCThreadState::self()->getCallingPid(), IPCThreadState::self()->getCallingUid(), key.string(), value.string());
+            return OK;
+        } break;
+#endif
+//!--
+#endif
+
         case GET_LEGACY_PARAMETERS: {
             CHECK_INTERFACE(ICameraService, data, reply);
             int cameraId = data.readInt32();
diff --git a/camera/IMetadataCallbacks.cpp b/camera/IMetadataCallbacks.cpp
new file mode 100644
index 0000000..1a38e97
--- /dev/null
+++ b/camera/IMetadataCallbacks.cpp
@@ -0,0 +1,95 @@
+/*
+**
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "IMetadataCallbacks"
+#include <utils/Log.h>
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <binder/Parcel.h>
+#include <gui/IGraphicBufferProducer.h>
+#include <gui/Surface.h>
+#include <utils/Mutex.h>
+
+#include <camera/IMetadataCallbacks.h>
+#include <camera/CameraMetadata.h>
+
+namespace android {
+
+enum {
+    METADATA_RECEIVED = IBinder::FIRST_CALL_TRANSACTION,
+
+};
+
+class BpMetadataCallbacks: public BpInterface<IMetadataCallbacks>
+{
+public:
+    BpMetadataCallbacks(const sp<IBinder>& impl)
+        : BpInterface<IMetadataCallbacks>(impl)
+    {
+    }
+
+    void onMetadataReceived(CameraMetadata& result,
+            CameraMetadata& charateristic) {
+        ALOGV("onMetadataReceived");
+        Parcel data, reply;
+        data.writeInterfaceToken(IMetadataCallbacks::getInterfaceDescriptor());
+        data.writeInt32(1); // to mark presence of metadata object
+        result.writeToParcel(&data);
+        data.writeInt32(1); // to mark presence of CaptureResult object
+        charateristic.writeToParcel(&data);
+        remote()->transact(METADATA_RECEIVED, data, &reply, IBinder::FLAG_ONEWAY);
+        data.writeNoException();
+    }
+};
+
+IMPLEMENT_META_INTERFACE(MetadataCallbacks, "android.hardware.IMetadataCallbacks");
+
+// ----------------------------------------------------------------------
+
+status_t BnMetadataCallbacks::onTransact(
+    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
+{
+    switch(code) {
+        case METADATA_RECEIVED: {
+            ALOGV("onMetadataReceived");
+            CHECK_INTERFACE(IMetadataCallbacks, data, reply);
+            CameraMetadata result;
+            if (data.readInt32() != 0) {
+                result.readFromParcel(const_cast<Parcel*>(&data));
+            } else {
+                ALOGW("No result metadata object is present in result");
+            }
+            CameraMetadata charateristic;
+            if (data.readInt32() != 0) {
+                charateristic.readFromParcel(const_cast<Parcel*>(&data));
+            } else {
+                ALOGW("No charateristic object is present in result");
+            }
+            onMetadataReceived(result, charateristic);
+            data.readExceptionCode();
+            return NO_ERROR;
+        } break;
+        default:
+            return BBinder::onTransact(code, data, reply, flags);
+    }
+}
+
+// ----------------------------------------------------------------------------
+
+}; // namespace android
diff --git a/camera/mediatek/Camera.cpp b/camera/mediatek/Camera.cpp
new file mode 100755
index 0000000..45acfee
--- /dev/null
+++ b/camera/mediatek/Camera.cpp
@@ -0,0 +1,73 @@
+/*
+**
+** Copyright (C) 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "Camera"
+#include <utils/Log.h>
+#include <utils/String16.h>
+
+#include <camera/Camera.h>
+#include <camera/ICameraService.h>
+#include <camera/ICamera.h>
+#include <camera/IMetadataCallbacks.h>
+
+namespace android {
+
+status_t Camera::setMetadataCallback(sp<IMetadataCallbacks>& cb)
+{
+    ALOGV("Camera::setMetadataCallback");
+    sp <ICamera> c = mCamera;
+    if (c == 0) {
+        ALOGE("Camera::setMetadataCallback mCamera=NULL");
+        return NO_INIT;
+    }
+    if (cb == NULL) {
+        ALOGE("Camera::setMetadataCallback cb=NULL");
+        return NO_INIT;
+    }
+    status_t res = OK;
+    res = c->setMetadataCallback(cb);
+
+    return res;
+}
+
+//!++
+#if 1   // defined(MTK_CAMERA_BSP_SUPPORT)
+
+status_t
+Camera::
+getProperty(String8 const& key, String8& value)
+{
+    const sp<ICameraService>& cs = getCameraService();
+    if (cs == 0) return UNKNOWN_ERROR;
+    return cs->getProperty(key, value);
+}
+
+
+status_t
+Camera::
+setProperty(String8 const& key, String8 const& value)
+{
+    const sp<ICameraService>& cs = getCameraService();
+    if (cs == 0) return UNKNOWN_ERROR;
+    return cs->setProperty(key, value);
+}
+
+#endif
+//!--
+
+}; // namespace android
diff --git a/include/camera/Camera.h b/include/camera/Camera.h
index 2b60842..49574bb 100644
--- a/include/camera/Camera.h
+++ b/include/camera/Camera.h
@@ -32,6 +32,9 @@ namespace android {
 class Surface;
 class String8;
 class String16;
+#ifdef MTK_AOSP_ENHANCEMENT
+class IMetadataCallbacks;
+#endif
 
 // ref-counted object for callbacks
 class CameraListener: virtual public RefBase
@@ -171,6 +174,15 @@ protected:
     sp<ICameraRecordingProxyListener>  mRecordingProxyListener;
 
     friend class        CameraBase;
+
+public:
+#ifdef MTK_AOSP_ENHANCEMENT
+#if 1   // defined(MTK_CAMERA_BSP_SUPPORT)
+        static  status_t    getProperty(String8 const& key, String8& value);
+        static  status_t    setProperty(String8 const& key, String8 const& value);
+#endif
+                status_t    setMetadataCallback(sp<IMetadataCallbacks>& cb);
+#endif
 };
 
 }; // namespace android
diff --git a/include/camera/ICamera.h b/include/camera/ICamera.h
index b025735..b758f02 100644
--- a/include/camera/ICamera.h
+++ b/include/camera/ICamera.h
@@ -24,11 +24,18 @@
 #include <utils/String8.h>
 #include <camera/Camera.h>
 
+#ifdef MTK_AOSP_ENHANCEMENT
+#include <camera/IMetadataCallbacks.h>
+#endif
+
 namespace android {
 
 class ICameraClient;
 class IGraphicBufferProducer;
 class Surface;
+#ifdef MTK_AOSP_ENHANCEMENT
+class IMetadataCallbacks;
+#endif
 
 class ICamera: public IInterface
 {
@@ -90,6 +97,9 @@ public:
 
     // cancel auto focus
     virtual status_t        cancelAutoFocus() = 0;
+#ifdef MTK_AOSP_ENHANCEMENT
+    virtual status_t        setMetadataCallback(sp<IMetadataCallbacks>& cb) = 0;
+#endif
 
     /*
      * take a picture.
@@ -118,6 +128,9 @@ public:
 class BnCamera: public BnInterface<ICamera>
 {
 public:
+#ifdef MTK_AOSP_ENHANCEMENT
+    virtual status_t    setMetadataCallback(sp<IMetadataCallbacks>& cb) { return -1; };
+#endif
     virtual status_t    onTransact( uint32_t code,
                                     const Parcel& data,
                                     Parcel* reply,
diff --git a/include/camera/ICameraService.h b/include/camera/ICameraService.h
index 1b68b5f..27fc820 100644
--- a/include/camera/ICameraService.h
+++ b/include/camera/ICameraService.h
@@ -52,6 +52,12 @@ public:
         CONNECT_LEGACY,
         SET_TORCH_MODE,
         NOTIFY_SYSTEM_EVENT,
+#ifdef MTK_AOSP_ENHANCEMENT
+#if 1   // defined(MTK_CAMERA_BSP_SUPPORT)
+        GET_PROPERTY,
+        SET_PROPERTY,
+#endif
+#endif
     };
 
     enum {
@@ -132,6 +138,13 @@ public:
             /*out*/
             sp<ICameraDeviceUser>& device) = 0;
 
+#ifdef MTK_AOSP_ENHANCEMENT
+#if 1   // defined(MTK_CAMERA_BSP_SUPPORT)
+    virtual status_t getProperty(String8 const& key, String8& value) const = 0;
+    virtual status_t setProperty(String8 const& key, String8 const& value) = 0;
+#endif
+#endif
+
     virtual status_t getLegacyParameters(
             int cameraId,
             /*out*/
diff --git a/include/camera/IMetadataCallbacks.h b/include/camera/IMetadataCallbacks.h
new file mode 100644
index 0000000..0ad0917
--- /dev/null
+++ b/include/camera/IMetadataCallbacks.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_HARDWARE_IMETADATACALLBACKS_H
+#define ANDROID_HARDWARE_IMETADATACALLBACKS_H
+
+#include <utils/RefBase.h>
+#include <binder/IInterface.h>
+#include <binder/Parcel.h>
+#include <binder/IMemory.h>
+#include <utils/String8.h>
+#include <camera/Camera.h>
+
+namespace android {
+
+class CameraMetadata;
+
+class IMetadataCallbacks:
+    public IInterface
+{
+    /*
+     * Keep up-to-date with IMetadataCallbacks.aidl in frameworks/base
+     */
+public:
+    DECLARE_META_INTERFACE(MetadataCallbacks);
+
+    // One Way
+    virtual void onMetadataReceived(CameraMetadata& result,
+                               CameraMetadata& characteristic) = 0;
+};
+
+// ----------------------------------------------------------------------------
+
+class BnMetadataCallbacks: public BnInterface<IMetadataCallbacks>
+{
+public:
+    virtual status_t    onTransact( uint32_t code,
+                                    const Parcel& data,
+                                    Parcel* reply,
+                                    uint32_t flags = 0);
+};
+
+}; // namespace android
+
+#endif
diff --git a/media/mediaserver/Android.mk b/media/mediaserver/Android.mk
index ac25582..0e978e0 100644
--- a/media/mediaserver/Android.mk
+++ b/media/mediaserver/Android.mk
@@ -3,6 +3,35 @@ LOCAL_PATH:= $(call my-dir)
 ifneq ($(BOARD_USE_CUSTOM_MEDIASERVEREXTENSIONS),true)
 include $(CLEAR_VARS)
 LOCAL_SRC_FILES := register.cpp
+
+ifeq ($(MTK_HARDWARE),true)
+################################################################################
+# mmsdk related, TODO: should add feature option
+################################################################################
+ifeq ($(MTK_CAM_MMSDK_SUPPORT),$(filter $(MTK_CAM_MMSDK_SUPPORT),yes no))
+-include $(TOP)/$(MTK_PATH_SOURCE)/hardware/mtkcam/mtkcam.mk
+LOCAL_C_INCLUDES += \
+    $(TOP)/$(MTK_PATH_SOURCE)/frameworks/av/services/mmsdk/libmmsdkservice \
+    $(TOP)/$(MTK_PATH_SOURCE)/hardware/mtkcam/ext/include \
+    $(TOP)/$(MTK_PATH_SOURCE)/frameworks/av/services/mmsdk/include/ \
+    $(TOP)/$(MTK_PATH_SOURCE)/frameworks-ext/av/include/ \
+    $(TOP)/$(MTKCAM_C_INCLUDES) \
+    $(TOP)/$(MTKCAM_C_INCLUDES)/.. \
+    $(TOP)/$(MTK_PATH_SOURCE)/hardware/gralloc_extra/include \
+    $(TOP)/$(MTK_PATH_SOURCE)/hardware/mmsdk/include
+
+ifeq ($(IS_LEGACY), 0)
+LOCAL_C_INCLUDES += $(TOP)/$(MTK_PATH_SOURCE)/hardware/mtkcam/middleware/common/include
+LOCAL_C_INCLUDES += $(TOP)/$(MTK_PATH_SOURCE)/hardware/mtkcam/utils/include
+else
+LOCAL_C_INCLUDES += $(TOP)/$(MTK_PATH_SOURCE)/hardware/mtkcam/legacy/include/mtkcam/utils
+endif
+
+LOCAL_CFLAGS += -DMTK_CAM_MMSDK_SUPPORT
+endif
+LOCAL_C_INCLUDES += system/media/camera/include
+endif
+
 LOCAL_MODULE := libregistermsext
 LOCAL_MODULE_TAGS := optional
 include $(BUILD_STATIC_LIBRARY)
@@ -10,6 +39,8 @@ endif
 
 include $(CLEAR_VARS)
 
+-include $(TOP)/$(MTK_PATH_SOURCE)/hardware/mtkcam/mtkcam.mk
+
 LOCAL_SRC_FILES:= \
 	main_mediaserver.cpp
 
@@ -31,6 +62,11 @@ LOCAL_SHARED_LIBRARIES := \
 	libsoundtriggerservice \
 	libradioservice
 
+ifeq ($(MTK_HARDWARE),true)
+LOCAL_SHARED_LIBRARIES += \
+	libdl
+endif
+
 LOCAL_STATIC_LIBRARIES := \
         libicuandroid_utils \
         libregistermsext
@@ -51,6 +87,53 @@ LOCAL_C_INCLUDES := \
     frameworks/av/services/radio \
     external/sonic
 
+ifeq ($(MTK_HARDWARE),true)
+LOCAL_C_INCLUDES += \
+    $(TOP)/$(MTK_PATH_SOURCE)/frameworks/av/include \
+    $(TOP)/$(MTK_PATH_SOURCE)/frameworks/av \
+    $(TOP)/$(MTK_PATH_SOURCE)/frameworks/av/memorydumper/include
+
+LOCAL_C_INCLUDES += \
+        frameworks/av/include/media \
+        $(TOP)/$(MTK_ROOT)/frameworks-ext/av/services/audioflinger \
+        $(MTK_PATH_SOURCE)/external/audiodcremoveflt \
+        $(MTK_PATH_SOURCE)/external/AudioCompensationFilter \
+        $(MTK_PATH_SOURCE)/external/AudioComponentEngine \
+        $(MTK_PATH_SOURCE)/hardware/audio/common/aud_drv \
+        $(MTK_PATH_SOURCE)/hardware/audio/common/ \
+        $(MTK_PATH_SOURCE)/hardware/audio/common/include \
+        $(MTK_PATH_SOURCE)/hardware/audio/common/V3/include \
+        $(MTK_PATH_PLATFORM)/hardware/audio/aud_drv \
+        $(MTK_PATH_PLATFORM)/hardware/audio/aud_drv/include \
+        $(MTK_PATH_PLATFORM)/hardware/audio \
+        $(TOP)/$(MTKCAM_C_INCLUDES) \
+        $(MTK_PATH_SOURCE)/external/AudioDCRemoval \
+        $(MTK_PATH_SOURCE)/external/blisrc/blisrc32 \
+        $(MTK_PATH_SOURCE)/external/limiter \
+        $(MTK_PATH_SOURCE)/external/shifter \
+        $(MTK_PATH_SOURCE)/external/bessound_HD \
+        $(MTK_PATH_SOURCE)/external/bessound \
+        $(LOCAL_MTK_PATH)
+
+
+ifeq ($(IS_LEGACY), 0)
+LOCAL_C_INCLUDES += $(TOP)/$(MTK_PATH_SOURCE)/hardware/mtkcam/middleware/common/include
+endif
+
+LOCAL_C_INCLUDES += \
+    $(MTK_PATH_SOURCE)/external/audiocustparam
+
+
+ifeq ($(strip $(BOARD_USES_MTK_AUDIO)),true)
+LOCAL_CFLAGS += -DMTK_AUDIO
+
+endif
+
+LOCAL_SHARED_LIBRARIES += \
+    libmmsdkservice
+
+endif
+
 ifneq ($(BOARD_NUMBER_OF_CAMERAS),)
     LOCAL_CFLAGS += -DMAX_CAMERAS=$(BOARD_NUMBER_OF_CAMERAS)
 endif
diff --git a/media/mediaserver/main_mediaserver.cpp b/media/mediaserver/main_mediaserver.cpp
index f785c0d..0247b4e 100644
--- a/media/mediaserver/main_mediaserver.cpp
+++ b/media/mediaserver/main_mediaserver.cpp
@@ -44,6 +44,12 @@
 #include "ListenService.h"
 #endif
 
+#ifdef MTK_AOSP_ENHANCEMENT
+#include <dlfcn.h>
+#include <sys/capability.h>
+#include <private/android_filesystem_config.h>
+#endif
+
 using namespace android;
 
 int main(int argc __unused, char** argv)
@@ -142,6 +148,7 @@ int main(int argc __unused, char** argv)
         AudioFlinger::instantiate();
         MediaPlayerService::instantiate();
         ResourceManagerService::instantiate();
+
         CameraService::instantiate();
 #ifdef AUDIO_LISTEN_ENABLED
         ALOGI("ListenService instantiated");
@@ -151,6 +158,66 @@ int main(int argc __unused, char** argv)
         SoundTriggerHwService::instantiate();
         RadioService::instantiate();
         registerExtensions();
+#ifdef MTK_AOSP_ENHANCEMENT
+            void *pCodecUtil = NULL,*pPerfNative = NULL;
+/*
+            void (*pfn_PrepareLibrary)(int i4UID);
+            pfn_PrepareLibrary = NULL;
+            pCodecUtil = dlopen("/system/lib/libvcodec_utility.so", RTLD_LAZY);
+            if (pCodecUtil != NULL) {
+                pfn_PrepareLibrary = (void (*)(int i4UID))dlsym(pCodecUtil, "PrepareLibrary");
+                if (pfn_PrepareLibrary != NULL) {
+                    (*pfn_PrepareLibrary)(AID_MEDIA);
+                }
+                dlclose(pCodecUtil);
+            }
+*/
+            pPerfNative = dlopen("/system/lib/libperfservicenative.so",RTLD_LAZY);
+            void (*pfn_perfuserDisableAll)(void);
+            if (pPerfNative != NULL) {
+                pfn_perfuserDisableAll = (void (*)(void))dlsym(pPerfNative, "PerfServiceNative_userDisableAll");
+                if (pfn_perfuserDisableAll != NULL) {
+                    (*pfn_perfuserDisableAll)();
+                }
+                dlclose(pPerfNative);
+            }
+
+        if (AID_ROOT == getuid()) {
+            ALOGI("[%s] re-adjust caps for its thread, and set uid to media", __func__);
+            if (-1 == prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0)) {
+                ALOGW("mediaserver prctl for set caps failed: %s", strerror(errno));
+            } else {
+                __user_cap_header_struct hdr;
+                __user_cap_data_struct data;
+
+                setuid(AID_MEDIA);         // change user to media
+                int dumpable = prctl(PR_GET_DUMPABLE, 0, 0, 0, 0);
+                if(dumpable == 0)
+                {
+                    if(prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) != 0)
+                        ALOGI("[%s] set dumpable failed", __func__);
+                    else
+                        ALOGI("[%s] set dumpable successful", __func__);
+                }
+                else {
+                    ALOGI("[%s] get thread %d dumpable:%d", __func__, gettid(), dumpable);
+                }
+
+                hdr.version = _LINUX_CAPABILITY_VERSION;    // set caps again
+                hdr.pid = 0;
+                data.effective = (1 << CAP_SYS_NICE);
+                data.permitted = (1 << CAP_SYS_NICE);
+                data.inheritable = 0xffffffff;
+                if (-1 == capset(&hdr, &data)) {
+                    ALOGW("mediaserver cap re-setting failed, %s", strerror(errno));
+                }
+            }
+
+        } else {
+            ALOGI("[%s] re-adjust caps is not in root user", __func__);
+        }
+#endif
+
         ProcessState::self()->startThreadPool();
         IPCThreadState::self()->joinThreadPool();
     }
diff --git a/media/mediaserver/register.cpp b/media/mediaserver/register.cpp
index 4ffb2ba..f78289f 100644
--- a/media/mediaserver/register.cpp
+++ b/media/mediaserver/register.cpp
@@ -15,7 +15,47 @@
  */
 
 #include "RegisterExtensions.h"
+//[FIXME], remove from mediaserver
+#ifdef MTK_CAM_MMSDK_SUPPORT
+#include <utils/RefBase.h>
+using namespace android;
+
+//
+#include <stdlib.h>
+//
+#include <hardware/camera.h>
+#include <system/camera.h>
+//
+#include <Log.h>
+#include <common.h>
+//
+#include <v1/camutils/CamFormatTransform.h>
+//
+#include <v1/camutils/CamProfile.h>
+//
+#include <v1/camutils/CamMisc.h>
+#include <v1/camutils/CamInfo.h>
+#include <v1/camutils/CamFormat.h>
+#include <v1/camutils/CamProperty.h>
+//
+#include <v1/camutils/IBuffer.h>
+#include <v1/camutils/ICameraBuffer.h>
+#include <v1/camutils/IImgBufQueue.h>
+#include <v1/camutils/ImgBufQueue.h>
+#include <Format.h>
+
+using namespace MtkCamUtils;
+#include <v1/IParamsManager.h>
+#include <v1/ICamClient.h>
+
+#include <v1/sdkClient/IGestureClient.h>
+#include "MMSdkService.h"
+#endif
 
 void registerExtensions()
 {
+//
+#ifdef MTK_CAM_MMSDK_SUPPORT
+    NSMMSdk::MMSdkService::instantiate();
+#endif
 }
diff --git a/services/camera/libcameraservice/Android.mk b/services/camera/libcameraservice/Android.mk
index ab09cb3..0d80461 100644
--- a/services/camera/libcameraservice/Android.mk
+++ b/services/camera/libcameraservice/Android.mk
@@ -79,6 +79,27 @@ LOCAL_C_INCLUDES += \
 
 LOCAL_CFLAGS += -Wall -Wextra
 
+ifeq ($(MTK_HARDWARE),true)
+#//!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+-include $(TOP)/$(MTK_PATH_SOURCE)/hardware/mtkcam/mtkcam.mk
+ifneq ($(strip $(MTK_EMULATOR_SUPPORT)),yes)
+#ifeq ($(HAVE_MATV_FEATURE),yes)
+    LOCAL_CFLAGS += -DATVCHIP_MTK_ENABLE
+#endif
+endif
+
+    LOCAL_SHARED_LIBRARIES += libdl
+    LOCAL_SHARED_LIBRARIES += libmtkcamera_client
+
+    LOCAL_C_INCLUDES += $(MTK_PATH_SOURCE)/hardware/mtkcam/ext/include
+    LOCAL_C_INCLUDES += $(TOP)/$(MTK_PATH_SOURCE)/hardware/include
+    LOCAL_C_INCLUDES += $(TOP)/$(MTKCAM_C_INCLUDES)
+    LOCAL_SRC_FILES += mediatek/CameraService.cpp
+    LOCAL_SRC_FILES += mediatek/api1/CameraClient.cpp
+
+#//!----------------------------------------------------------------------------
+endif
+
 ifeq ($(BOARD_NEEDS_MEMORYHEAPION),true)
     LOCAL_CFLAGS += -DUSE_MEMORY_HEAP_ION
 endif
diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
index 3c9fd16..4baf0fb 100644
--- a/services/camera/libcameraservice/CameraService.cpp
+++ b/services/camera/libcameraservice/CameraService.cpp
@@ -57,6 +57,12 @@
 #include "utils/CameraTraces.h"
 #include "CameraDeviceFactory.h"
 
+#ifdef MTK_AOSP_ENHANCEMENT
+#if 1
+    #include <camera/MtkCameraParameters.h>
+#endif
+#endif
+
 namespace android {
 
 // ----------------------------------------------------------------------------
@@ -408,6 +414,9 @@ void CameraService::onTorchStatusChangedLocked(const String8& cameraId,
 }
 
 int32_t CameraService::getNumberOfCameras() {
+#ifdef MTK_AOSP_ENHANCEMENT
+    LOG1("[getNumberOfCameras] NumberOfCameras:%d \n", mNumberOfCameras);
+#endif
     ATRACE_CALL();
     return getNumberOfCameras(CAMERA_TYPE_BACKWARD_COMPATIBLE);
 }
@@ -433,6 +442,9 @@ status_t CameraService::getCameraInfo(int cameraId,
         return -ENODEV;
     }
 
+#ifdef MTK_AOSP_ENHANCEMENT
+    LOG1("[getCameraInfo] id:%d NumberOfCameras:%d \n", cameraId, mNumberOfCameras);
+#endif
     if (cameraId < 0 || cameraId >= mNumberOfCameras) {
         return BAD_VALUE;
     }
@@ -1021,6 +1033,21 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
         // Update all active clients' priorities
         std::map<int,int> pidToPriorityMap;
         for (size_t i = 0; i < ownerPids.size() - 1; i++) {
+#ifdef MTK_AOSP_ENHANCEMENT
+            //!++
+            //make sure VT has top priority
+            if( mActiveClientManager.getCameraClient(cameraId) != 0 &&
+                strcmp("mtk_vt_use", String8(mActiveClientManager.getCameraClient(cameraId)->getPackageName().string())) == 0)
+            {
+                int clientPid_vt = mActiveClientManager.getCameraClient(cameraId)->getClientPid();
+                if(clientPid_vt == ownerPids[i])
+                {
+                    priorities[i] = 0;
+                }
+            }
+            ALOGI("i(%d) pid(%d) priorities(%d),Priority(%d)",i,ownerPids[i],priorities[i],getCameraPriorityFromProcState(priorities[i]));
+            //!--
+#endif
             pidToPriorityMap.emplace(ownerPids[i], getCameraPriorityFromProcState(priorities[i]));
         }
         mActiveClientManager.updatePriorities(pidToPriorityMap);
@@ -1554,6 +1581,11 @@ bool CameraService::evictClientIdByRemote(const wp<IBinder>& remote) {
         for (auto& i : evicted) {
             if (i.get() != nullptr) {
                 i->disconnect();
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++ The part is merged by MTK
+                i.clear();
+        //!--
+#endif
                 ret = true;
             }
         }
@@ -1694,6 +1726,14 @@ void CameraService::doUserSwitch(const int32_t* newUserId, size_t length) {
                 i->getKey().string(), String8{clientSp->getPackageName()}.string(),
                 i->getOwnerId(), i->getPriority()));
 
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        // Notify the client of disconnection
+        ALOGW("ERROR_CAMERA_DISCONNECTED");
+        clientSp->notifyError(ICameraDeviceCallbacks::ERROR_CAMERA_DISCONNECTED,
+                CaptureResultExtras());
+        //!--
+#endif
     }
 
     // Do not hold mServiceLock while disconnecting clients, but retain the condition
@@ -1816,6 +1856,9 @@ status_t CameraService::onTransact(uint32_t code, const Parcel& data, Parcel* re
 // media players.
 
 MediaPlayer* CameraService::newMediaPlayer(const char *file) {
+#ifdef MTK_AOSP_ENHANCEMENT
+    LOG1("[CameraService::newMediaPlayer] + (%s)\r\n", file);
+#endif
     MediaPlayer* mp = new MediaPlayer();
     if (mp->setDataSource(NULL /* httpService */, file, NULL) == NO_ERROR) {
         mp->setAudioStreamType(AUDIO_STREAM_ENFORCED_AUDIBLE);
@@ -1824,26 +1867,83 @@ MediaPlayer* CameraService::newMediaPlayer(const char *file) {
         ALOGE("Failed to load CameraService sounds: %s", file);
         return NULL;
     }
+#ifdef MTK_AOSP_ENHANCEMENT
+    LOG1("[CameraService::newMediaPlayer] -\r\n");
+#endif
     return mp;
 }
 
 void CameraService::loadSound() {
     ATRACE_CALL();
 
+#ifdef MTK_AOSP_ENHANCEMENT
+    LOG1("[CameraService::loadSound] + tid:%d mSoundLock - ref=%d\r\n", ::gettid(), mSoundRef);
+#endif
     Mutex::Autolock lock(mSoundLock);
     LOG1("CameraService::loadSound ref=%d", mSoundRef);
     if (mSoundRef++) return;
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    #if 0
+    mSoundPlayer[SOUND_SHUTTER] = newMediaPlayer("/system/media/audio/ui/camera_click.ogg");
+    mSoundPlayer[SOUND_RECORDING_START] = newMediaPlayer("/system/media/audio/ui/VideoRecord.ogg");
+    mSoundPlayer[SOUND_RECORDING_STOP] = newMediaPlayer("/system/media/audio/ui/VideoStop.ogg");
+    #else
+    if( pthread_create(&mloadSoundTThreadHandle, NULL, loadSoundThread, this) != 0 )
+    {
+        ALOGE("loadSound pthread create failed");
+    }
+    #endif
+    //!--
+#endif
+}
 
+#ifdef MTK_AOSP_ENHANCEMENT
+//!++
+void CameraService::loadSoundImp() {
+    LOG1("[CameraService::loadSoundImp] E");
     mSoundPlayer[SOUND_SHUTTER] = newMediaPlayer("/system/media/audio/ui/camera_click.ogg");
     mSoundPlayer[SOUND_RECORDING_START] = newMediaPlayer("/system/media/audio/ui/VideoRecord.ogg");
     mSoundPlayer[SOUND_RECORDING_STOP] = newMediaPlayer("/system/media/audio/ui/VideoStop.ogg");
 }
 
+bool CameraService::waitloadSoundDone() {
+    if(mloadSoundTThreadHandle != 0)
+    {
+        LOG1("CameraService::waitloadSoundDone E");
+        int s = pthread_join(mloadSoundTThreadHandle, NULL);
+        mloadSoundTThreadHandle = 0;
+        LOG1("CameraService::waitloadSoundDone X");
+        if( s != 0 )
+        {
+            ALOGE("loadSound pthread join error: %d", s);
+            return false;
+        }
+    }
+    return true;
+}
+
+void* CameraService::loadSoundThread(void* arg) {
+    LOG1("[CameraService::loadSoundThread]");
+    CameraService* pCameraService = (CameraService*)arg;
+    pCameraService->loadSoundImp();
+    pthread_exit(NULL);
+    return NULL;
+}
+//!--
+
+#endif
+
 void CameraService::releaseSound() {
     Mutex::Autolock lock(mSoundLock);
     LOG1("CameraService::releaseSound ref=%d", mSoundRef);
     if (--mSoundRef) return;
 
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    waitloadSoundDone();
+    //!--
+#endif
     for (int i = 0; i < NUM_SOUNDS; i++) {
         if (mSoundPlayer[i] != 0) {
             mSoundPlayer[i]->disconnect();
@@ -1857,11 +1957,19 @@ void CameraService::playSound(sound_kind kind) {
 
     LOG1("playSound(%d)", kind);
     Mutex::Autolock lock(mSoundLock);
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    waitloadSoundDone();
+    //!--
+#endif
     sp<MediaPlayer> player = mSoundPlayer[kind];
     if (player != 0) {
         player->seekTo(0);
         player->start();
     }
+#ifdef MTK_AOSP_ENHANCEMENT
+    LOG1("playSound(%d) - tid:%d", kind, ::gettid());
+#endif
 }
 
 // ----------------------------------------------------------------------------
@@ -1988,6 +2096,18 @@ status_t CameraService::BasicClient::startCameraOps() {
     res = mAppOpsManager.startOp(AppOpsManager::OP_CAMERA,
             mClientUid, mClientPackageName);
 
+#ifdef MTK_AOSP_ENHANCEMENT
+//!++
+#if 1 //workaround for vt
+#define VT_PACKAGE "mtk_vt_use"
+    if( 0 == strcmp(VT_PACKAGE, String8(mClientPackageName).string()) )
+    {
+        ALOGI("always allow %s", VT_PACKAGE);
+        res = AppOpsManager::MODE_ALLOWED;
+    }
+#endif
+//!--
+#endif
     if (res == AppOpsManager::MODE_ERRORED) {
         ALOGI("Camera %d: Access for \"%s\" has been revoked",
                 mCameraId, String8(mClientPackageName).string());
@@ -2062,6 +2182,17 @@ void CameraService::BasicClient::opChanged(int32_t op, const String16& packageNa
     int32_t res;
     res = mAppOpsManager.checkOp(AppOpsManager::OP_CAMERA,
             mClientUid, mClientPackageName);
+#ifdef MTK_AOSP_ENHANCEMENT
+//!++
+#if 1 //workaround for vt
+    if( 0 == strcmp(VT_PACKAGE, String8(mClientPackageName).string()) )
+    {
+        ALOGI("always allow %s", VT_PACKAGE);
+        res = AppOpsManager::MODE_ALLOWED;
+    }
+#endif
+//!--
+#endif
     ALOGV("checkOp returns: %d, %s ", res,
             res == AppOpsManager::MODE_ALLOWED ? "ALLOWED" :
             res == AppOpsManager::MODE_IGNORED ? "IGNORED" :
diff --git a/services/camera/libcameraservice/CameraService.h b/services/camera/libcameraservice/CameraService.h
index 53233bd..8f05c37 100644
--- a/services/camera/libcameraservice/CameraService.h
+++ b/services/camera/libcameraservice/CameraService.h
@@ -97,6 +97,12 @@ public:
     // Implementation of BinderService<T>
     static char const* getServiceName() { return "media.camera"; }
 
+#ifdef MTK_AOSP_ENHANCEMENT
+#if 1   // defined(MTK_CAMERA_BSP_SUPPORT)
+    virtual status_t    getProperty(String8 const& key, String8& value) const;
+    virtual status_t    setProperty(String8 const& key, String8 const& value);
+#endif
+#endif
                         CameraService();
     virtual             ~CameraService();
 
@@ -172,6 +178,12 @@ public:
     };
 
     void                loadSound();
+    //!++
+    void                loadSoundImp();
+    bool                waitloadSoundDone();
+    static void*        loadSoundThread(void* arg);
+    pthread_t           mloadSoundTThreadHandle;
+    //!--
     void                playSound(sound_kind kind);
     void                releaseSound();
 
diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index af46d63..3da690b 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -24,6 +24,14 @@
 #include "device1/CameraHardwareInterface.h"
 #include "CameraService.h"
 
+#ifdef MTK_AOSP_ENHANCEMENT
+//!++
+//Add MTK header
+#include <camera/MtkCamera.h>
+#include <camera/MtkCameraParameters.h>
+//!--
+#endif
+
 namespace android {
 
 #define LOG1(...) ALOGD_IF(gLogLevel >= 1, __VA_ARGS__);
@@ -86,6 +94,15 @@ status_t CameraClient::initialize(CameraModule *module) {
         return res;
     }
 
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    // mtk callback
+    mHardware->setMtkCallbacks(
+            mtkMetadataCallback,
+            (void *)(uintptr_t)mCameraId);
+    //!--
+#endif
+
     mHardware->setCallbacks(notifyCallback,
             dataCallback,
             dataCallbackTimestamp,
@@ -95,6 +112,12 @@ status_t CameraClient::initialize(CameraModule *module) {
     enableMsgType(CAMERA_MSG_ERROR | CAMERA_MSG_ZOOM | CAMERA_MSG_FOCUS |
                   CAMERA_MSG_PREVIEW_METADATA | CAMERA_MSG_FOCUS_MOVE);
 
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    enableMsgType(MTK_CAMERA_MSG_EXT_NOTIFY | MTK_CAMERA_MSG_EXT_DATA); // Enable MTK-extended messages by default
+    //!--
+#endif
+
     LOG1("CameraClient::initialize X (pid %d, id %d)", callingPid, mCameraId);
     return OK;
 }
@@ -190,6 +213,12 @@ status_t CameraClient::unlock() {
         LOG1("clear mRemoteCallback (pid %d)", callingPid);
         // we need to remove the reference to ICameraClient so that when the app
         // goes away, the reference count goes to 0.
+
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        Mutex::Autolock _remoteCallbackLock(mRemoteCallbackLock);
+        //!--
+#endif
         mRemoteCallback.clear();
     }
     return result;
@@ -268,6 +297,12 @@ void CameraClient::disconnect() {
     }
     mHardware.clear();
 
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    mMetadataCallback.clear();
+    //!--
+#endif
+
     CameraService::Client::disconnect();
 
     LOG1("disconnect X (pid %d)", callingPid);
@@ -305,6 +340,14 @@ status_t CameraClient::setPreviewWindow(const sp<IBinder>& binder,
         }
     }
 
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    else if ( window == 0 ) {
+        result = mHardware->setPreviewWindow(window); // Notify CamDevice the window is null
+    }
+    //!--
+#endif
+
     if (result == NO_ERROR) {
         // Everything has succeeded.  Disconnect the old window and remember the
         // new window.
@@ -442,7 +485,21 @@ status_t CameraClient::startRecordingMode() {
 
     // start recording mode
     enableMsgType(CAMERA_MSG_VIDEO_FRAME);
+
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    #if 0 // Use self-defined function to control sound mute ON/OFF.
+    mCameraService->playSound(CameraService::SOUND_RECORDING_START);
+    #else
+    playRecordingSound();
+    #endif
+    //!--
+#else
     mCameraService->playSound(CameraService::SOUND_RECORDING_START);
+#endif
+
+
+
     result = mHardware->startRecording();
     if (result != NO_ERROR) {
         ALOGE("mHardware->startRecording() failed with status %d", result);
@@ -480,7 +537,21 @@ void CameraClient::stopRecording() {
 
 // release a recording frame
 void CameraClient::releaseRecordingFrame(const sp<IMemory>& mem) {
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    ssize_t offset;
+    size_t size;
+    sp<IMemoryHeap> heap = mem->getMemory(&offset, &size);
+    void *data = ((uint8_t *)heap->base()) + offset;
+    LOG2("RRF:VA(%p)", data); // print VA for debug.
+    //!--
+#endif
     Mutex::Autolock lock(mLock);
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    LOG2("RRF:VA(%p), get mLock (%d)", data, getCallingPid()); //make sure it get lock.
+    //!--
+#endif
     if (checkPidAndHardware() != NO_ERROR) return;
     mHardware->releaseRecordingFrame(mem);
 }
@@ -632,6 +703,9 @@ status_t CameraClient::sendCommand(int32_t cmd, int32_t arg1, int32_t arg2) {
     if (result != NO_ERROR) return result;
 
     if (cmd == CAMERA_CMD_SET_DISPLAY_ORIENTATION) {
+#ifdef MTK_AOSP_ENHANCEMENT
+        LOG1("CAMERA_CMD_SET_DISPLAY_ORIENTATION - tid(%d), (degrees, mirror)=(%d, %d)", ::gettid(), arg1, mCameraFacing); //Add debug log
+#endif
         // Mirror the preview if the camera is front-facing.
         orientation = getOrientation(arg1, mCameraFacing == CAMERA_FACING_FRONT);
         if (orientation == -1) return BAD_VALUE;
@@ -643,6 +717,12 @@ status_t CameraClient::sendCommand(int32_t cmd, int32_t arg1, int32_t arg2) {
                         mOrientation);
             }
         }
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        if(mHardware != 0)
+            mHardware->sendCommand(cmd, mOrientation, arg2);
+        //!--
+#endif
         return OK;
     } else if (cmd == CAMERA_CMD_ENABLE_SHUTTER_SOUND) {
         switch (arg1) {
@@ -690,6 +770,14 @@ void CameraClient::enableMsgType(int32_t msgType) {
 
 void CameraClient::disableMsgType(int32_t msgType) {
     android_atomic_and(~msgType, &mMsgEnabled);
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    if (mHardware == 0) {
+        ALOGW("[disableMsgType] mHardware == 0 (CallingPid %d) (tid %d)", getCallingPid(), ::gettid()); // Avoid NE when mHardware is null.
+        return;
+    }
+    //!--
+#endif
     mHardware->disableMsgType(msgType);
 }
 
@@ -748,6 +836,15 @@ void CameraClient::notifyCallback(int32_t msgType, int32_t ext1,
     if (!client->lockIfMessageWanted(msgType)) return;
 
     switch (msgType) {
+
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        case MTK_CAMERA_MSG_EXT_NOTIFY:
+            client->handleMtkExtNotify(ext1, ext2); // Callback extended msg notification.
+            break;
+        //!--
+#endif
+
         case CAMERA_MSG_SHUTTER:
             // ext1 is the dimension of the yuv picture.
             client->handleShutter();
@@ -773,6 +870,15 @@ void CameraClient::dataCallback(int32_t msgType,
     }
 
     switch (msgType & ~CAMERA_MSG_PREVIEW_METADATA) {
+
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        case MTK_CAMERA_MSG_EXT_DATA:
+            client->handleMtkExtData(dataPtr, metadata); // Callback extended msg notification.
+            break;
+        //!--
+#endif
+
         case CAMERA_MSG_PREVIEW_FRAME:
             client->handlePreviewData(msgType, dataPtr, metadata);
             break;
@@ -817,7 +923,15 @@ void CameraClient::handleShutter(void) {
 
     sp<ICameraClient> c = mRemoteCallback;
     if (c != 0) {
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
+        mLock.unlock();
+        #endif
+        //!--
+#else
         mLock.unlock();
+#endif
         c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
         if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
     }
@@ -831,7 +945,15 @@ void CameraClient::handleShutter(void) {
         ICameraServiceProxy::CAMERA_STATE_IDLE,
         String8::format("%d", mCameraId));
 
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
     mLock.unlock();
+    #endif
+    //!--
+#else
+    mLock.unlock();
+#endif
 }
 
 // preview callback - frame buffer update
@@ -849,12 +971,34 @@ void CameraClient::handlePreviewData(int32_t msgType,
     if (!(flags & CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK)) {
         // If the enable bit is off, the copy-out and one-shot bits are ignored
         LOG2("frame callback is disabled");
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
         mLock.unlock();
+        #endif
+        //!--
+#else
+        mLock.unlock();
+#endif
         return;
     }
 
     // hold a strong pointer to the client
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++ Temp solution to avoid NULL pointer issue
+    #if 0
+    sp<ICameraClient> c = mRemoteCallback;
+    #else
+    sp<ICameraClient> c;
+    {
+        Mutex::Autolock _remoteCallbackLock(mRemoteCallbackLock);
+        c = mRemoteCallback;
+    }
+    #endif
+    //!--
+#else
     sp<ICameraClient> c = mRemoteCallback;
+#endif
 
     // clear callback flags if no client or one-shot mode
     if (c == 0 || (mPreviewCallbackFlag & CAMERA_FRAME_CALLBACK_FLAG_ONE_SHOT_MASK)) {
@@ -872,11 +1016,29 @@ void CameraClient::handlePreviewData(int32_t msgType,
             copyFrameAndPostCopiedFrame(msgType, c, heap, offset, size, metadata);
         } else {
             LOG2("frame is forwarded");
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
+        mLock.unlock();
+        #endif
+        //!--
+#else
             mLock.unlock();
+#endif
             c->dataCallback(msgType, mem, metadata);
         }
     } else {
+
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
+        mLock.unlock();
+        #endif
+        //!--
+#else
         mLock.unlock();
+#endif
+
     }
 }
 
@@ -885,7 +1047,17 @@ void CameraClient::handlePostview(const sp<IMemory>& mem) {
     disableMsgType(CAMERA_MSG_POSTVIEW_FRAME);
 
     sp<ICameraClient> c = mRemoteCallback;
+
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
+        mLock.unlock();
+        #endif
+        //!--
+#else
     mLock.unlock();
+#endif
+
     if (c != 0) {
         c->dataCallback(CAMERA_MSG_POSTVIEW_FRAME, mem, NULL);
     }
@@ -900,7 +1072,17 @@ void CameraClient::handleRawPicture(const sp<IMemory>& mem) {
     sp<IMemoryHeap> heap = mem->getMemory(&offset, &size);
 
     sp<ICameraClient> c = mRemoteCallback;
+
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
+        mLock.unlock();
+        #endif
+        //!--
+#else
     mLock.unlock();
+#endif
+
     if (c != 0) {
         c->dataCallback(CAMERA_MSG_RAW_IMAGE, mem, NULL);
     }
@@ -917,7 +1099,17 @@ void CameraClient::handleCompressedPicture(const sp<IMemory>& mem) {
     }
 
     sp<ICameraClient> c = mRemoteCallback;
+
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
+        mLock.unlock();
+        #endif
+        //!--
+#else
     mLock.unlock();
+#endif
+
     if (c != 0) {
         c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, mem, NULL);
     }
@@ -927,7 +1119,17 @@ void CameraClient::handleCompressedPicture(const sp<IMemory>& mem) {
 void CameraClient::handleGenericNotify(int32_t msgType,
     int32_t ext1, int32_t ext2) {
     sp<ICameraClient> c = mRemoteCallback;
+
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
+        mLock.unlock();
+        #endif
+        //!--
+#else
     mLock.unlock();
+#endif
+
     if (c != 0) {
         c->notifyCallback(msgType, ext1, ext2);
     }
@@ -935,8 +1137,24 @@ void CameraClient::handleGenericNotify(int32_t msgType,
 
 void CameraClient::handleGenericData(int32_t msgType,
     const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata) {
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++ Temp solution to avoid NULL pointer issue
+    #if 0
     sp<ICameraClient> c = mRemoteCallback;
     mLock.unlock();
+    #else
+    sp<ICameraClient> c;
+    {
+        Mutex::Autolock _remoteCallbackLock(mRemoteCallbackLock);
+        c = mRemoteCallback;
+    }
+    #endif
+    //!--
+#else
+    sp<ICameraClient> c = mRemoteCallback;
+    mLock.unlock();
+#endif
+
     if (c != 0) {
         c->dataCallback(msgType, dataPtr, metadata);
     }
@@ -945,7 +1163,16 @@ void CameraClient::handleGenericData(int32_t msgType,
 void CameraClient::handleGenericDataTimestamp(nsecs_t timestamp,
     int32_t msgType, const sp<IMemory>& dataPtr) {
     sp<ICameraClient> c = mRemoteCallback;
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
+        mLock.unlock();
+        #endif
+        //!--
+#else
     mLock.unlock();
+#endif
+
     if (c != 0) {
         c->dataCallbackTimestamp(timestamp, msgType, dataPtr);
     }
@@ -971,7 +1198,16 @@ void CameraClient::copyFrameAndPostCopiedFrame(
     }
     if (mPreviewBuffer == 0) {
         ALOGE("failed to allocate space for preview buffer");
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
+        mLock.unlock();
+        #endif
+        //!--
+#else
         mLock.unlock();
+#endif
+
         return;
     }
     previewBuffer = mPreviewBuffer;
@@ -994,11 +1230,28 @@ void CameraClient::copyFrameAndPostCopiedFrame(
     sp<MemoryBase> frame = new MemoryBase(previewBuffer, 0, size);
     if (frame == 0) {
         ALOGE("failed to allocate space for frame callback");
+#ifdef MTK_AOSP_ENHANCEMENT
+        //!++
+        #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
         mLock.unlock();
+        #endif
+        //!--
+#else
+        mLock.unlock();
+#endif
         return;
     }
 
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++
+    #if 0 // There some dead lock issue in camera hal, so we need to disable this function before all dead lock issues hase been fixed.
+    mLock.unlock();
+    #endif
+    //!--
+#else
     mLock.unlock();
+#endif
+
     client->dataCallback(msgType, frame, metadata);
 }
 
diff --git a/services/camera/libcameraservice/api1/CameraClient.h b/services/camera/libcameraservice/api1/CameraClient.h
index d2cb64a..bba23f3 100644
--- a/services/camera/libcameraservice/api1/CameraClient.h
+++ b/services/camera/libcameraservice/api1/CameraClient.h
@@ -23,6 +23,9 @@ namespace android {
 
 class MemoryHeapBase;
 class CameraHardwareInterface;
+#ifdef MTK_AOSP_ENHANCEMENT
+class IMetadataCallbacks;
+#endif
 
 /**
  * Interface between android.hardware.Camera API and Camera HAL device for version
@@ -136,6 +139,11 @@ private:
 
     // Ensures atomicity among the public methods
     mutable Mutex                   mLock;
+#ifdef MTK_AOSP_ENHANCEMENT
+    //!++ Temp solution to avoid NULL pointer issue
+    mutable Mutex                   mRemoteCallbackLock;
+    //!--
+#endif
     // This is a binder of Surface or Surface.
     sp<IBinder>                     mSurface;
     sp<ANativeWindow>               mPreviewWindow;
@@ -167,6 +175,39 @@ private:
 
     bool                 mLongshotEnabled;
     int                  mBurstCnt;
+#ifdef MTK_AOSP_ENHANCEMENT
+//!++
+    sp<IMetadataCallbacks>  mMetadataCallback;
+    static void             mtkMetadataCallback(int32_t msgType,
+                                        camera_metadata_t *result,
+                                        camera_metadata_t *charateristic,
+                                        void* user);
+//#ifdef  MTK_CAMERA_BSP_SUPPORT
+        //
+        void                handleMtkExtNotify(int32_t ext1, int32_t ext2);
+        void                handleMtkExtData(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+        //
+        void                handleMtkExtBurstShutter(int32_t ext1, int32_t ext2);
+        void                handleMtkExtDataBurstShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+        //
+        void                handleMtkExtContinuousShutter(int32_t ext1, int32_t ext2);
+        void                handleMtkExtDataContinuousShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+        void                handleMtkExtContinuousEnd(int32_t ext1, int32_t ext2);
+        //
+        void                handleMtkExtCaptureDone(int32_t ext1, int32_t ext2);
+        void                handleMtkExtShutter(int32_t ext1, int32_t ext2);
+        void                handleMtkExtDataCompressedImage(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+        //
+        void                handleMtkExtDataRaw16(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+        //
+        void                playRecordingSound();
+        //
+public:
+        virtual status_t    setMetadataCallback(sp<IMetadataCallbacks>& cb);
+        void                onMetadataAvailable(camera_metadata_t *result, camera_metadata_t *charateristic);
+//#endif
+//!--
+#endif
 };
 
 }
diff --git a/services/camera/libcameraservice/device1/CameraHardwareInterface.h b/services/camera/libcameraservice/device1/CameraHardwareInterface.h
index 35947a9..84ad63b 100644
--- a/services/camera/libcameraservice/device1/CameraHardwareInterface.h
+++ b/services/camera/libcameraservice/device1/CameraHardwareInterface.h
@@ -30,6 +30,12 @@
 #include <binder/MemoryHeapIon.h>
 #endif
 
+#ifdef MTK_AOSP_ENHANCEMENT
+//!++
+#include <device/device1.h>
+//!--
+#endif
+
 namespace android {
 
 typedef void (*notify_callback)(int32_t msgType,
@@ -42,6 +48,14 @@ typedef void (*data_callback)(int32_t msgType,
                             camera_frame_metadata_t *metadata,
                             void* user);
 
+#ifdef MTK_AOSP_ENHANCEMENT
+//!++
+typedef void (*mtk_metadata_callback)(int32_t msg_type,
+                            camera_metadata_t *result,
+                            camera_metadata_t *charateristic,
+                            void *user);
+//!--
+#endif
 typedef void (*data_callback_timestamp)(nsecs_t timestamp,
                             int32_t msgType,
                             const sp<IMemory> &dataPtr,
@@ -123,6 +137,16 @@ public:
         ALOGV("%s(%s) buf %p", __FUNCTION__, mName.string(), buf.get());
 
         if (mDevice->ops->set_preview_window) {
+#ifdef MTK_AOSP_ENHANCEMENT
+            //!++
+            if  ( buf == 0 ) {
+                ALOGD("set_preview_window(0) before mPreviewWindow = 0 \r\n");
+                mDevice->ops->set_preview_window(mDevice, 0);
+                mPreviewWindow = 0;
+                return  OK;
+            }
+            //!--
+#endif
             mPreviewWindow = buf;
             mHalPreviewWindow.user = this;
             ALOGV("%s &mHalPreviewWindow %p mHalPreviewWindow.user %p", __FUNCTION__,
@@ -726,6 +750,40 @@ private:
     data_callback           mDataCb;
     data_callback_timestamp mDataCbTimestamp;
     void *mCbUser;
+#ifdef MTK_AOSP_ENHANCEMENT
+//!++
+private:
+    mtk_metadata_callback   mMetadataCb;
+public:
+    /** Set the metadata callbacks */
+    void setMtkCallbacks(
+            mtk_metadata_callback metadata_cb,
+            void* user)
+    {
+        mMetadataCb = metadata_cb;
+
+        //
+        mtk_camera_device_ops* mtk_ops = reinterpret_cast<mtk_camera_device_ops*>(mDevice->ops);
+        if (mtk_ops->mtk_set_callbacks) {
+            mtk_ops->mtk_set_callbacks(mDevice,
+                                       __mtk_metadata_cb,
+                                       this);
+        }
+    }
+private:
+    static void __mtk_metadata_cb(
+                          int32_t msg_type,
+                          camera_metadata_t *result,
+                          camera_metadata_t *charateristic,
+                          void *user)
+    {
+        ALOGV("%s", __FUNCTION__);
+        CameraHardwareInterface *__this =
+                static_cast<CameraHardwareInterface *>(user);
+        __this->mMetadataCb(msg_type, result, charateristic, __this->mCbUser);
+    }
+//!--
+#endif
 };
 
 };  // namespace android
diff --git a/services/camera/libcameraservice/mediatek/CameraService.cpp b/services/camera/libcameraservice/mediatek/CameraService.cpp
new file mode 100644
index 0000000..eeaaafb
--- /dev/null
+++ b/services/camera/libcameraservice/mediatek/CameraService.cpp
@@ -0,0 +1,63 @@
+/*
+**
+** Copyright (C) 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "CameraService"
+//
+#include <utils/Log.h>
+#include "CameraService.h"
+//
+#include <dlfcn.h>
+
+
+namespace android {
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+status_t
+CameraService::
+getProperty(String8 const& key, String8& value) const
+{
+    char const* sym = "MtkCam_getProperty";
+    void* pfn = ::dlsym(mModule->getDso(), sym);
+    if  ( ! pfn ) {
+        ALOGW("Cannot find symbol: %s", sym);
+        return  INVALID_OPERATION;
+    }
+    return  reinterpret_cast<status_t(*)(String8 const&, String8&)>(pfn)(key, value);
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+status_t
+CameraService::
+setProperty(String8 const& key, String8 const& value)
+{
+    char const* sym = "MtkCam_setProperty";
+    void* pfn = ::dlsym(mModule->getDso(), sym);
+    if  ( ! pfn ) {
+        ALOGW("Cannot find symbol: %s", sym);
+        return  INVALID_OPERATION;
+    }
+    return  reinterpret_cast<status_t(*)(String8 const&, String8 const&)>(pfn)(key, value);
+}
+
+
+};
diff --git a/services/camera/libcameraservice/mediatek/api1/CameraClient.cpp b/services/camera/libcameraservice/mediatek/api1/CameraClient.cpp
new file mode 100644
index 0000000..64b9f25
--- /dev/null
+++ b/services/camera/libcameraservice/mediatek/api1/CameraClient.cpp
@@ -0,0 +1,483 @@
+/*
+**
+** Copyright (C) 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "CameraService"
+//
+#include <binder/MemoryBase.h>
+//
+#include <camera/CameraParameters.h>
+#include <camera/MtkCamera.h>
+//
+#include "api1/CameraClient.h"
+#include "device1/CameraHardwareInterface.h"
+
+namespace android {
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+void
+CameraClient::
+playRecordingSound()
+{
+    CameraParameters params(mHardware->getParameters());
+    int value = 0;
+    value = params.getInt("rec-mute-ogg");
+    if (value != 1) {
+        mCameraService->playSound(CameraService::SOUND_RECORDING_START);
+    }
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtNotify(int32_t ext1, int32_t ext2)
+{
+    int32_t const extMsgType = ext1;
+    switch  (extMsgType)
+    {
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CAPTURE_DONE:
+        handleMtkExtCaptureDone(ext1, ext2);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER:
+        handleMtkExtShutter(ext1, ext2);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER:
+        handleMtkExtBurstShutter(ext1, ext2);
+        break;
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_SHUTTER:
+        handleMtkExtContinuousShutter(ext1, ext2);
+        break;
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END:
+        handleMtkExtContinuousEnd(ext1, ext2);
+        break;
+    //
+    default:
+        handleGenericNotify(MTK_CAMERA_MSG_EXT_NOTIFY, ext1, ext2);
+        break;
+    }
+}
+
+
+/******************************************************************************
+ *
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtData(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[handleMtkExtData] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p)", dataPtr.get(), this);
+        return;
+    }
+
+//    void*   const pvExtParam   = MtkExtDataHelper.getExtParamBase();
+//    size_t  const ExtParamSize = MtkExtDataHelper.getExtParamSize();
+    switch  (MtkExtDataHelper.getExtMsgType())
+    {
+    case MTK_CAMERA_MSG_EXT_DATA_COMPRESSED_IMAGE:
+        handleMtkExtDataCompressedImage(dataPtr, metadata);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_DATA_BURST_SHOT:
+        handleMtkExtDataBurstShot(dataPtr, metadata);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_DATA_CONTINUOUS_SHOT:
+        handleMtkExtDataContinuousShot(dataPtr, metadata);
+        break;
+    case MTK_CAMERA_MSG_EXT_DATA_RAW16:
+        handleMtkExtDataRaw16(dataPtr, metadata);
+        break;
+    //
+    default:
+        handleGenericData(MTK_CAMERA_MSG_EXT_DATA, dataPtr, metadata);
+        break;
+    }
+    MtkExtDataHelper.uninit();
+}
+
+
+/******************************************************************************
+ *  Shutter Callback (not disable CAMERA_MSG_SHUTTER)
+ *      ext2: 1: CameraService will play shutter sound.
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtShutter(int32_t /*ext1*/, int32_t ext2)
+{
+    ALOGD("[%s] (ext2, mPlayShutterSound)=(%d, %d) \r\n", __FUNCTION__, ext2, mPlayShutterSound);
+
+    if  ( 1 == ext2 ) {
+        if (mPlayShutterSound) {
+            mCameraService->playSound(CameraService::SOUND_SHUTTER);
+        }
+    }
+
+    sp<ICameraClient> c = mRemoteCallback;
+    if (c != 0) {
+//!++
+#if 1
+#else
+        mLock.unlock();
+#endif
+//!--
+        c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
+        if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
+    }
+//    disableMsgType(CAMERA_MSG_SHUTTER);
+
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+}
+
+
+/******************************************************************************
+ *  Burst Shutter Callback Handler
+ *       ext2: count-down shutter number; 0: the last one shutter.
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtBurstShutter(int32_t /*ext1*/, int32_t ext2)
+{
+    handleShutter();
+    if  (0 < ext2) {
+        //  not the last one burst shutter.
+        enableMsgType(CAMERA_MSG_SHUTTER);
+        ALOGD("[handleMtkExtBurstShutter] count-down burst shutter number:%d - enableMsgType(CAMERA_MSG_SHUTTER) \r\n", ext2);
+    }
+    else {
+        ALOGD("[handleMtkExtBurstShutter] the last one burst shutter \r\n");
+    }
+}
+
+
+/******************************************************************************
+ *  Burst Shot (EV Shot)
+ *      int[0]: the total shut count.
+ *      int[1]: count-down shut number; 0: the last one shut.
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtDataBurstShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t */*metadata*/)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    //
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const uTotalShutCount = pExtParam[0];
+    uint_t const uCountdownIndex = pExtParam[1];
+    //
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 2;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 2;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    //
+    MtkExtDataHelper.uninit();
+    //
+    //
+    if  (0 < uCountdownIndex) {
+        //  not the last one burst shut.
+        ALOGD("[%s] count-down burst shut number:%d/%d - (size, offset)=(%d, %d) \r\n", __FUNCTION__, uCountdownIndex, uTotalShutCount, imageSize, imageOffset);
+    }
+    else {
+        disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+        ALOGD("[%s] the last one burst shut - (size, offset)=(%d, %d) \r\n", __FUNCTION__, imageSize, imageOffset);
+    }
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+    //
+    sp<ICameraClient> c = mRemoteCallback;
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+
+
+/******************************************************************************
+*   Continuous Shutter Callback Handler
+*       ext2: current continuous shutter number.
+*******************************************************************************/
+void
+CameraClient::
+handleMtkExtContinuousShutter(int32_t /*ext1*/, int32_t ext2)
+{
+    //if (mPlayShutterSound) {
+    //    mCameraService->playSound(CameraService::SOUND_SHUTTER);
+    //}
+
+    sp<ICameraClient> c = mRemoteCallback;
+    if (c != 0) {
+//!++
+#if 1
+#else
+        mLock.unlock();
+#endif
+//!--
+        c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
+        if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
+    }
+    //disableMsgType(CAMERA_MSG_SHUTTER);
+
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+
+    //enableMsgType(CAMERA_MSG_SHUTTER);
+    ALOGD("[handleMtkExtContinuousShutter] current continuous shutter number:%d \n", ext2);
+}
+
+
+/******************************************************************************
+ *  Continuous Shot
+ *      int[0]: current continuous shut number.
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtDataContinuousShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t */*metadata*/)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    //
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const uCurShutCount = pExtParam[0];
+    //
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 1;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 1;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    //
+    MtkExtDataHelper.uninit();
+
+    ALOGD("[%s] current continuous shut number:%d - (size, offset)=(%d, %d) \r\n", __FUNCTION__,  uCurShutCount, imageSize, imageOffset);
+
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+    //
+    sp<ICameraClient> c = mRemoteCallback;
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+
+
+/******************************************************************************
+ *  Continuous EndCallback Handler
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtContinuousEnd(int32_t ext1, int32_t ext2)
+{
+    disableMsgType(CAMERA_MSG_SHUTTER);
+    disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+    handleGenericNotify(MTK_CAMERA_MSG_EXT_NOTIFY, ext1, ext2);
+    ALOGD("[handleMtkExtContinuousEnd] total continuous shut number is %d \n", ext2);
+}
+
+
+/******************************************************************************
+ *  Capture done (disable CAMERA_MSG_SHUTTER / CAMERA_MSG_COMPRESSED_IMAGE)
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtCaptureDone(int32_t /*ext1*/, int32_t /*ext2*/)
+{
+    ALOGD("[%s] disable CAMERA_MSG_SHUTTER / CAMERA_MSG_COMPRESSED_IMAGE \r\n", __FUNCTION__);
+    disableMsgType(CAMERA_MSG_SHUTTER);
+    disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+}
+
+
+/******************************************************************************
+ *  Compressed Image (not disable CAMERA_MSG_COMPRESSED_IMAGE)
+ *      int[0]: current shut index; 0: the first one shut.
+ ******************************************************************************/
+void
+CameraClient::
+handleMtkExtDataCompressedImage(const sp<IMemory>& dataPtr, camera_frame_metadata_t */*metadata*/)
+{
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    //
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const      uShutIndex = pExtParam[0];
+    //
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 1;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 1;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    //
+    MtkExtDataHelper.uninit();
+
+    ALOGD("[%s] current shut index:%d - (size, offset)=(%d, %d) \r\n", __FUNCTION__, uShutIndex, imageSize, imageOffset);
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+    //
+    sp<ICameraClient> c = mRemoteCallback;
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+
+
+void
+CameraClient::
+handleMtkExtDataRaw16(const sp<IMemory>& dataPtr, camera_frame_metadata_t */*metadata*/)
+{
+    ALOGV("CameraClient::handleMtkExtDataRaw16");
+    ssize_t offset;
+    size_t size;
+    sp<IMemoryHeap> heap = dataPtr->getMemory(&offset, &size);
+    sp<MemoryBase> image = new MemoryBase(heap, offset, size);
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+
+    //
+    sp<ICameraClient> c = mRemoteCallback;
+//!++
+#if 1
+#else
+    mLock.unlock();
+#endif
+//!--
+
+    if (c != 0) {
+        c->dataCallback(MTK_CAMERA_MSG_EXT_DATA, image, NULL);
+    }
+}
+
+
+status_t
+CameraClient::
+setMetadataCallback(sp<IMetadataCallbacks>& cb)
+{
+    ALOGD("setMetadataCallback");
+    if (mMetadataCallback == NULL) {
+        mMetadataCallback = cb;
+    }
+
+    return OK;
+}
+
+void
+CameraClient::
+onMetadataAvailable(camera_metadata_t *result, camera_metadata_t *charateristic) {
+    ALOGV("onMetadataAvailable");
+
+    Mutex::Autolock lock(mLock);
+    // metadata callback
+    // clone camera_metadata_t
+    CameraMetadata result_cb(clone_camera_metadata(result));
+    CameraMetadata charateristic_cb(clone_camera_metadata(charateristic));
+
+    sp<IMetadataCallbacks> remoteCb = mMetadataCallback;
+    if (remoteCb != NULL) {
+        remoteCb->onMetadataReceived(result_cb, charateristic_cb);
+    }
+}
+
+void
+CameraClient::
+mtkMetadataCallback(
+        int32_t msgType,
+        camera_metadata_t *result,
+        camera_metadata_t *charateristic,
+        void* user) {
+    ALOGV("mtkMetadataCallback(%d)", msgType);
+
+    //Mutex* lock = getClientLockFromCookie(user);
+    //if (lock == NULL) return;
+    //Mutex::Autolock alock(*lock);
+
+    //CameraClient* client =
+    //        static_cast<CameraClient*>(getClientFromCookie(user));
+    sp<CameraClient> client = static_cast<CameraClient*>(getClientFromCookie(user).get());
+    //if (client == NULL) return;
+    if (client.get() == nullptr) return;
+
+    if (!client->lockIfMessageWanted(msgType)) return;
+    //if (result == NULL && charateristic == NULL) {
+    // cannot be null
+    if (result == NULL || charateristic == NULL) {
+        ALOGE("Null data returned in data callback");
+        client->handleGenericNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0);
+        return;
+    }
+
+    switch (msgType) {
+        case MTK_CAMERA_MSG_EXT_METADATA_RAW16:
+            client->onMetadataAvailable(result, charateristic);
+        break;
+        default:
+            ALOGE("Unsupported type.");
+            break;
+    }
+}
+
+};
-- 
2.30.2

